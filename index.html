<!DOCTYPE html>
<!-- 
Light Brush - Digital Painting, Art Creation Application
Copyright (c) 2019 Dmitriy A. Burmistrov 
-->
<script>
(function(){
let referrer = document.referrer;
let domain = "";
if(referrer != ""){
	try{
		domain = (new URL(referrer)).hostname;
	}
	catch(err){
		console.log(err);
	}
}
if(domain != "www.light-brush.art" && domain != "light-brush.art"){
	window.open("https://www.light-brush.art", '_self');
}
})();
</script>
<html lang="en">

<head>
<meta name="robots" content="noindex, nofollow, noarchive, nosnippet">
<link rel="shortcut icon" type="image/ico" href="/favicon.ico">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<title>Light Brush - Paint</title>
<style>

/* 
z-index list:
1000: draw screen/tool specific action screen. initial activation.
1001: tool/feature-specific UI controls above canvas
1002: tool/feature-specific second action screen
1003: tool config menu
1004: partial screen lock, like when feature menu adjustments is open
1005: general feature menu
1006: global screen
1010: drag bars, highest point, about
1011: splash screen
*/
:root{
	--core-w:800px;
	--core-h:600px;
	--mu:8px;/* 1% of --core-w measurement unit */
	--vmu:6px;/* 1% of --core-h vertical orientation measurement unit */
	--theme-bg-color:rgb(50,50,50);
	--btn-passive-color: rgb(60,60,60);
	--btn-active-color: rgba(180,180,180,0.2);
	/*--btn-highlight-color: rgba(190,190,190,0.4);*/
	--btn-highlight-color: rgb(100,100,100);
	--border-color: rgb(40,40,40);
	--border-color-light: rgb(80,80,80);
	--select-menu-color: rgb(230,230,230);
}

html{
	font-size: 8px;
	/* 
	this is set in sizeUICore, 
	to be used as measurement unit for all elements that need relative sizing as rem 
	*/
	
}

html *
{
   /* font-size: 12px !important;*/
   font-size: 0.7rem;
   font-family: Arial, sans-serif;
}

body{
	width:100%;
	height:100%;
	background-color:var(--theme-bg-color);
	color: rgb(180,180,180);
	margin:0;
	padding:0;
	overflow:hidden;
	-webkit-user-select: none;  /* Chrome all / Safari all */
	-moz-user-select: none;     /* Firefox all */
	-ms-user-select: none;      /* IE 10+ */
	user-select: none;          /* Likely future */ 
}

html, body {
    margin: 0;
    height: 100%;
	background-color: rgb(50,50,50);
}

.crisp-render{
    image-rendering: optimizeSpeed;             /* STOP SMOOTHING, GIVE ME SPEED  */
    image-rendering: -moz-crisp-edges;          /* Firefox                        */
    image-rendering: -o-crisp-edges;            /* Opera                          */
    image-rendering: -webkit-optimize-contrast; /* Chrome (and eventually Safari) */
    image-rendering: pixelated; /* Chrome */
    image-rendering: optimize-contrast;         /* CSS3 Proposed                  */
    -ms-interpolation-mode: nearest-neighbor;   /* IE8+                           */
}

*{
	scrollbar-color: rgb(80,80,80) rgb(60,60,60);
}

/* Works on Chrome/Edge/Safari */
*::-webkit-scrollbar {
	width:auto;
	height:auto;
}
*::-webkit-scrollbar-button{
	background-color: rgb(60,60,60);
}

*::-webkit-scrollbar-corner{
	background-color: rgb(50,50,50);
}
*::-webkit-scrollbar-track {
	background: rgb(60,60,60);
}
*::-webkit-scrollbar-thumb {
	background-color: rgb(80,80,80);
	border-radius: 0;
	border: 1px solid rgb(60,60,60);
}

.crisp-render{
    image-rendering: optimizeSpeed;             /* STOP SMOOTHING, GIVE ME SPEED  */
    image-rendering: -moz-crisp-edges;          /* Firefox                        */
    image-rendering: -o-crisp-edges;            /* Opera                          */
    image-rendering: -webkit-optimize-contrast; /* Chrome (and eventually Safari) */
    image-rendering: pixelated; /* Chrome */
    image-rendering: optimize-contrast;         /* CSS3 Proposed                  */
    -ms-interpolation-mode: nearest-neighbor;   /* IE8+                           */
}

div{
	position:relative;
	/*outline:1px dotted rgb(180,180,180);*/
	margin:0;
	padding:0;
	touch-action:none;
}
.touch-scrollable{
	touch-action:auto;
}

span{
	display:block;
	position:relative;
	font-size:inherit;
	margin:0;
	padding:0;
}

ul{
	display:div;
	list-style-type: none;
	padding:0;
	margin:0;
}
li{
	padding:0;
	margin:0;
}

img{
	object-fit:contain;
	object-position: center center;
}

label{
	/*
	display:inline-block;
	position:relative;
	*/
	text-align:inherit;
	font-size:inherit;
}

.text-caption{
	display:inline-block;
	position:relative;
}


input {
	position:relative;
	padding: 0;
	margin: 0;
	vertical-align: bottom;
	height: 1.2rem;
	font-size: 0.7rem;
	background-color: rgb(190,190,190);
	color:black;
	border:none;
	box-sizing: border-box;
	-webkit-box-shadow: none;
	-moz-box-shadow: none;
	box-shadow: none;
}

input:focus{
	box-shadow:none;
	outline:none;
}

input[type=checkbox]{

	-webkit-appearance: none;
	-moz-appearance: none;
	appearance: none;
	
	-webkit-user-select: none;  /* Chrome all / Safari all */
	-moz-user-select: none;     /* Firefox all */
	-ms-user-select: none;      /* IE 10+ */
	user-select: none;          /* Likely future */ 
	
	width: 0.8rem;
	height: 0.8rem;
	border:1px solid rgb(30,30,30);
	background-color: rgb(50,50,50);
	border-radius:20%;
	vertical-align:text-top;
}

input[type=checkbox]::after{
	display:inline-block;
	content:'';
	visibility: hidden;
	position:absolute;
	height:60%;
	width:30%;
	top:0;
	left:25%;
    border-bottom: 2px solid rgb(190,190,190);
    border-right: 2px solid rgb(190,190,190);
	transform: rotate(45deg);
	vertical-align: middle;
}
input[type=checkbox]:checked::after{
	visibility: visible;
}



/* old way
input[type=checkbox]:checked + .checkmark{
	visibility:visible;
}

.checkbox{
	display:inline-block;
	position:relative;
	vertical-align: middle;
}


.checkmark{
	display:inline-block;
	visibility:hidden;
	position:absolute;
	height: 0.4rem;
    width: 0.2rem;
	margin-left: -0.55rem;
    border-bottom: 2px solid rgb(190,190,190);
    border-right: 2px solid rgb(190,190,190);
	transform: rotate(45deg);
	vertical-align: bottom;
}

*/

input[type=file]{
	appearance:none;
	-moz-appearance:none;
	-webkit-appearance:none;
	background-color:rgb(50,50,50);
	color:rgb(180,180,180);
}

.radio-btn{
	appearance:none;
	-moz-appearance:none;
	-webkit-appearance:none;
	display:inline-block;
	width: 0.9rem;
	height: 0.9rem;
	border-radius:35%;
	border:2px solid rgb(180,180,180);
	background-color: rgb(50,50,50);
	vertical-align:middle;
	line-height: 0.8rem;
}

.radio-btn::after{
	content: '';
	display:inline-block;
	visibility:hidden;
	position:relative;
	border-radius:35%;
	background-color: rgb(190,190,190);
	vertical-align:top;
	width:max(100% - 4px, 80%);
	height:max(100% - 4px, 80%);
	top: min(10%, 2px);
	left: min(10%, 2px);
}

.radio-btn:checked::after{
	visibility:visible;
}



input[type=range] {
	-webkit-appearance: none;
	-moz-appearance: none;
	appearance: none;
	height: 1rem;
	background-color: rgb(40,40,40);
	/*border: 1px solid rgb(80,80,80);*/
}
input[type=range]::-moz-range-track{
	height:100%;
}
input[type=range]::-moz-range-thumb{
	-moz-appearance:none;
	-webkit-appearance:none;
	appearance: none;
	height:100%;
	width: 0.65rem;
	background-color:rgb(90,90,90);
	/*outline:1px solid rgb(80,80,80);*/
	border:none;
	border-radius:0;
}
input[type=range]::-webkit-slider-runnable-track{
	height: 100%;
}
input[type=range]::-webkit-slider-thumb {
	-moz-appearance:none;
	-webkit-appearance:none;
	appearance: none;
	height: 100%;
	width: 0.65rem;
	background:rgb(90,90,90);
	border:none;
	border-radius:0;
}


select{
	background-color: rgba(80,80,80,0.4);
	color:inherit;
	font-size: inherit;
	outline: 1px solid rgba(80,80,80,0.4);
	outline-offset: -1px;
	border:none;
}

select:hover{
	background-color: var(--btn-active-color);
	outline: 1px solid var(--border-color-light);
}

select:focus{
	background-color: rgba(40,40,40,0.4);
	outline: 1px solid var(--border-color-light);
	border:none;
}

.drop-down-menu{
	appearance:none;
	-moz-appearance:none;
	-webkit-appearance:none;
	background-color: rgb(50,50,50);
	outline: 1px solid rgb(60,60,60);
	border:none;
	height: 1.1rem;
	/*text-align:center;*/
}

.drop-down-menu:hover{
	background-color: rgb(60,60,60);
}

.drop-down-menu:focus{
	background-color: rgb(40,40,40);
	outline: 1px solid rgb(50,50,50);
	border:none;
}


option{
	color: WindowText;
	background-color: Window;
	font-size:inherit;
	outline:none;
	border:none;
}

option:hover{
	outline:none;
	border:none;
}

.button{
	background-color: var(--btn-passive-color);
}

.button:active{
	background-color: var(--btn-active-color);
}

.btn-highlight{
	background-color: var(--btn-highlight-color);
}


.wrap-bottom{
	position:absolute;
	bottom:0;
}

.content-abs{
	position:absolute;
	width:100%;
	height:100%;
	top:0;
	left:0;
	bottom:0;
	right:0;
	text-align:center;
}

.div-relative-wrap{
	position:relative;
	width:100%;
	height:100%;
	padding:0;
	margin:0;
}

.div-absolute-wrap{
	position:absolute;
	width:100%;
	height:100%;
	padding:0;
	margin:0;
}

#container{
	display:block;
	position:relative;
	height: 100%;
	width: 100%;
	margin:0 auto;
	
}

.hidden_obj{
	display:none;
}

.panel-name{
	color: rgb(140,140,140);
	font-size: 0.7rem;
	font-weight:bold;
}

/* support micro classes (instead of inline styling) */

.float-left{
	float:left;
}

.float-right{
	float:right;
}

.clear-both{
	clear:both;
}

.text-align-center{
	text-align:center;
}

.text-align-left{
	text-align:left;
}

.text-align-right{
	text-align:right;
}

.display-inline-block{
	display:inline-block;
}
.display-inline{
	display:inline;
}

/* ================== Grid styling */

#grid-container{
display:grid;
position:relative;
grid-template-columns: 2.2rem auto 8rem 13rem;
grid-template-rows: 4.2rem auto;
width:100%;
height:100%;
}

#dock_1{
grid-column-start: 1;
grid-column-end: 3;
grid-row-start: 1;
grid-row-end: 1;
}

#dock_2{
grid-column-start: 3;
grid-column-end: 4;
grid-row-start: 1;
grid-row-end: 2;
}

#dock_3{
grid-column-start: 4;
grid-column-end: 5;
grid-row-start: 1;
grid-row-end: 3;
}

#dock_4{
grid-column-start: 1;
grid-column-end: 2;
grid-row-start: 2;
grid-row-end: 3;

}

#dock_5{
grid-column-start: 2;
grid-column-end: 4;
grid-row-start: 2;
grid-row-end: 3;
box-sizing: border-box;
border-left:1px solid rgb(40,40,40);
border-right:1px solid rgb(40,40,40);
}
/* ================== Grid styling END */

/* ================== Dock 1 / Top bar */

#general_options_bar{
	position:relative;
	height:23%;
}

.general-option-btn{
	display:inline-block;
	position:relative;
	width: 3.8rem;
	height:100%;
	font-size: 0.72rem;
	background-color: rgb(50,50,50);
}

.select-general-menu{
	position:relative;
	width:100%;
	height:100%;
	/*
	text-align:center;
	*/
	text-align-last:center;
	
	-moz-appearance:none; /* Firefox */
	-webkit-appearance:none; /* Safari and Chrome */
	appearance:none;
	border:none;
}

#general_light_brush_logo{
	display:inline-block;
	position:relative;
	height:100%;
	width: 2.2rem;
	vertical-align:top;
	transition: all 0.4s ease;
	background-color: rgb(30,30,30);
	filter:brightness(1.5);
}
/*
#general_light_brush_logo:hover{
	filter:brightness(1.5);
}
*/

#fullscreen_toggle{
	display:inline-block;
	position:relative;
	height:100%;
	width: 1.4rem;
	vertical-align:top;
}

#fullscreen_toggle:hover{
	background-color:var(--btn-active-color);
	outline:1px solid var(--btn-active-color);
}

#general_exit_btn{
	position:absolute;
	right: 2.4rem;
	background-color: rgb(40,40,40);
	text-align:center;
	height:94%;
	border: 1px dashed rgb(120,120,120);
}
#general_exit_btn:hover{
	color: rgb(190,190,190);
	background-color: rgb(50,50,50);
	text-shadow: 0 0 0.2rem rgb(140,140,140); 
	box-shadow: 0 0 0.8rem rgb(190,190,190);
	border-color: rgb(60,60,60);
	border-style: solid;
}
#general_exit_btn:active{
	color: rgb(160,160,160);
	background-color: rgb(30,30,30);
	text-shadow: 0 0 0.2rem rgb(120,120,120);
	box-shadow: 0 0 0.4rem rgb(190,190,190);
	border-color: rgb(40,40,40);
	border-style: solid;
}

#general_donate_btn{
	display:inline-block;
	position:absolute;
	right: 8.4rem;
	font-size: 0.6rem;
	font-weight:bold;
	padding-top: 0.1rem;
	padding-bottom: 0.2rem;
	padding-right: 0.8rem;
	padding-left: 0.8rem;
	
	
	text-align:center;
	vertical-align:top;
	
	color:black;
	color:white;
	text-shadow: 0 0 0.2rem black;
	
	border-radius: 0 0 50% 50%;
	overflow:hidden;
	transition: padding-top 0.1s,  background-color 0.2s;
	
	cursor: pointer;
	
	background: linear-gradient(90deg, rgba(180,180,180,1) 0, rgba(220,220,220,0) 15%, rgba(220,220,220,0) 85%, rgba(180,180,180,1) 100%); 
	background-color:rgb(220,220,220);
}




/*---------*/

/* tool options / tool config */

#tool_config_panel_container{
	display:inline-block;
	height:100%;
}

#tool_config_menu_btn{
	/* margin-left: 1.2rem; */
}

#tool_config_menu_toggler:checked ~ label>#tool_config_menu_btn{
	background-color:rgb(40,40,40);
}

#tool_config_menu_toggler:checked ~ #tool_config_menu{
	display:block;
}

#tool_config_menu{
	display:none;
	position:absolute;
	left:2.3rem;
	top: 3.1rem;
	width: 12rem;
	min-height: 4rem;
	background-color:rgb(70,70,70);
	z-index:1003;
	padding: 0.5rem;
}

.tool-config-menu-content{
	display:none;
	vertical-align: middle;
	line-height: 1.2rem;
	
}

.tool-config-cell-spacer{
	width:100%;
	height: 1.2rem;
}

.tool-config-cell{
	width:100%;
	min-height: 1.3rem;
}

.tool-config-cell-btn{
	text-align:center;
	padding: 0.1rem;
	padding-left: 0.4rem;
	padding-right: 0.4rem;
	vertical-align:middle;
}


.tool-config-cell input[type="number"], .tool-config-cell input[type="text"]{
	float:right;
	width: 3rem;
	text-align:center;
	margin-left: 0.2rem;
	vertical-align:middle;
}

.tool-config-menu-name{
	color: rgb(140,140,140);
	font-size: 0.7rem;
	font-weight:bold;
	text-align:center;
}


#tool_config_empty_menu{
	display:block;
	position:relative;
	width:100%;
	height:100%;
	padding-top:10%;
	text-align:center;
}

#move_config_menu input[type="number"]{
	width: 4rem;
	float:none;
}

#select_area_config_menu input[type="number"]{
	width: 4rem;
	float:none;
}

/* tool options / tool config end */


#bay_panel_bar{
	display:block;
	position:relative;
	height:72%;
	top:3%;
}

#bay_wrap{
	display:inline-block;
	position:relative;
	height:100%;
}

.bay-shell{
	display:inline-block;
	position:relative;
	width: 2.2rem;
	height:100%;
	vertical-align: middle;
	background-color: rgb(40,40,40);
	/*border-top:1px solid rgb(90,90,90);*/
}

.bay-draw-select{
	display:block;
	position:relative;
	appearance:none;
	-moz-appearance:none;
	-webkit-appearance:none;
	width:100%;
	padding-bottom:100%;
	background:none;
	outline:none;
	border:none;
}

.bay-draw-select:checked{
	outline:1px solid white;
	outline-offset:0;
}

.bay-draw-select:focus{
	border:none;
	outline-offset:0;
}

.bay-tip-icon{
	position:absolute;
	top:0;
	left:0;
	right:0;
	bottom:0;
	width:80%;
	height:80%;
	margin:10%;
}

.bay-erase-select{
	display:block;
	position:relative;
	appearance:none;
	-moz-appearance:none;
	-webkit-appearance:none;
	background-color:rgb(70,70,70);
	width:100%;
	height:25%;
	outline:none;
}

.bay-erase-select:checked{
	background-color:black;
}

#bay_config_wrap{
	display:inline-block;
	position:relative;
	height:100%;
}

.bay-panel-btn{
	display:inline-block;
	width: 2.2rem;
	height:100%;
	padding:0;
	margin:0;
	background-color: var(--btn-passive-color);
	vertical-align: middle;
	text-align:center;
	line-height: 0.9rem;
}

.bay-config-cell{
	display:inline-block;
	position:relative;
	width: 7rem;
	height:100%;
	background-color: var(--btn-passive-color);
	vertical-align: middle;
	text-align:center;
	line-height: 1.2rem;
}

.bay-config-value{
	display:inline-block;
	border-bottom:1px solid var(--btn-passive-color);
	width: 2.8rem;
	background-color: rgb(40,40,40);
	color: rgb(190,190,190);
	float:right;
}

.bay-config-value:focus{
	color: rgb(210,210,210);
}

.bay-config-slider{
	width:90%;
	float:right;
}

/* custom bay config cells */

#bay_config_size_cell{
	width: 8.5rem;
}

#bay_size_value{
	width: 4rem;
	padding-left: 0.3rem;
}

#bay_link_ref{
	display:inline-block;
	position:relative;
	width: 2.8rem;
	float:right;
}

/* ---- */


#undo_btn{
	box-sizing:border-box;
	display:inline-block;
	width:3rem;
	height:2rem;
	vertical-align:bottom;
	margin-left:0.6rem;
	border-radius: 0.5rem;
}
#undo_btn::before{
	content:'\27A6';
	position:absolute;
	width:100%;
	height:100%;
	left:0;
	top:0;
	margin:0;
	padding:0;
	font-size: 1.2rem;
	font-weight:bold;
	text-align:center;
	line-height:2rem;
	vertical-align:middle;
	transform: scale(-1, 1);
}
#redo_btn{
	box-sizing:border-box;
	display:inline-block;
	width:3rem;
	height:2rem;
	vertical-align:bottom;
	border-radius: 0.5rem;
}
#redo_btn::before{
	content:'\27A6';
	position:absolute;
	width:100%;
	height:100%;
	left:0;
	top:0;
	margin:0;
	padding:0;
	font-size: 1.2rem;
	font-weight:bold;
	text-align:center;
	line-height:2rem;
	vertical-align:middle;
}


/* ================== Dock 1 / Top bar END */

/* ================== Dock 2 / Spree bar */

.spree-bar-cell{
	/*font-size: 0.72rem;*/
	height: 1.25rem;
}

#spree_solid_1{
	position:absolute;
	width:38%;
	height:38%;
	left:0;
	bottom:0;
}

#spree_discard{
	position:absolute;
	width:38%;
	height:38%;
	right:0;
	bottom:0;
	margin-right:15%;
}

/* ================== Dock 2 / Spree bar END */

/* ================== Dock 3 / Layers and Nav tab with Tiny view */

/* nav tab */
#nav_tab_container{
	width:100%;
}

#nav_tab_bar{
	width:100%;
	height: 1.2rem;
	text-align:right;
}

#nav_tab_content{
	width:100%;
	padding-bottom:100%;
	
}

/* tiny preview */

.tiny-preview-btn{
	display:inline-block;
	background-color:var(--btn-passive-color);
	vertical-align:bottom;
}

.tiny-preview-filter-toggler{
	appearance:none;
	-moz-appearance:none;
	-webkit-appearance:none;
	max-height:0;
	max-width:0;
}

.tiny-preview-filter-toggler:checked + .tiny-preview-btn{
	background-color:rgb(40,40,40);
}

#tiny_preview_hide_btn{
	float:right;
	width: 1.7rem;
	height: 100%;
	padding:0;
	margin-left: 0.5rem;
}

#tiny_preview_hide_screen{
	display:none;
	position:absolute;
	top:0;
	bottom:0;
	left:0;
	right:0;
	background-color:rgb(50,50,50);
}

.tiny-preview-container{
	display:inline-block;
	/* width:20%; */
	/* padding-bottom:20%; */
	vertical-align:middle;
	
	font-size:0;
	text-align:center;
	
	width:100%;
	height:100%;
	background-color:rgb(40,40,40);
}

.tiny-preview-canvas{
	display:inline-block;
	vertical-align:middle;
	max-width:98%;
	max-height:98%;
}

.tiny-preview-canvas-align{
	display:inline-block;
	vertical-align:middle;
	height: 100%;
}

.tiny-preview-canvas-align::before{
	content:'';
	display:inline-block;
	height:100%;
	vertical-align:middle;
}

/* tiny preview end */


/* nav tab end */

#layers_tab{
	width:100%;
	height:calc(100% - 14.5rem);
	margin-top: 0.2rem;
}

.layers-tab-cell{
	margin-top: 0.1rem;
}

#layer_blending_box{
	display:inline-block;
	width:36%;
	vertical-align:top;
	
}

#layer_blending{
	width:100%;
	padding-left: 0.5ch;
	outline-offset: -1px;
}

#layer_opacity_box{
	display:inline-block;
	width:62%;
	text-align:right;
	vertical-align:middle;
	line-height: 1.2rem;
	background-color: rgb(60,60,60);
}

#layer_opacity_box input[type="number"]{
	width:40%;
	vertical-align:bottom;
	text-align:center;
	background-color:rgb(160,160,160);
}

#layer_opacity_box input[type="range"]{
	margin-top:4%;
	width:100%;
}

#layer_options{
	width:30%;
	padding-left: 0.5ch;
	outline-offset: -1px;
}

#layer_options_btn_box{
	display:inline-block;
	text-align:right;
	width:68%;
	height: 1.2rem;
	vertical-align:middle;
}

.layer-options-btn{
	position:relative;
	display:inline-block;
	width: 1.6rem;
	height:100%;
	text-align:center;
	vertical-align:top;
}



#layers_section_container{
	position:relative;
	height: calc(100% - 4.8rem - 1px);
	width:100%;
}

#layers_item_container{
	position:absolute;
	overflow-y: scroll;
	height: calc(100% - 1.6rem);
	top:0;
	left:0;
	bottom:0;
	right:0;
	margin-top: 0.2rem;
	background-color:rgb(40,40,40);
}

.layers-item{
	position:relative;
	width:100%;
	height:auto;
	padding-top: 0.3rem;
	padding-bottom: 0.3rem;
	vertical-align:middle;
	background-color:rgb(60,60,60);
	overflow:hidden;
	color:rgb(150,150,150);
	margin-top:1px;
}

/*
.layers-item span{
outline:1px solid grey;
}
*/

.layers-item-eye-container{
	position:relative;
	display:inline-block;
	margin-left:2%;
	width:10%;
	padding-bottom:20%;
	vertical-align:middle;
	background-color:rgb(50,50,50);
}

.layers-item-eye{
	position:absolute;
	width:100%;
	height:100%;
	opacity:0;
}

.layers-item-eye-toggler:checked + .layers-item-eye{
	opacity:1;
}

.layers-item-clipping-mask{
	display:inline-block;
	position:absolute;
	width:2%;
	/*padding-bottom:20%;*/

	
	background-color:green;
	top:0;
	bottom:0;
	margin-left:1%;
	/*
	outline:1px solid grey;
	*/
	
	background: linear-gradient(0deg, rgba(150,150,150,1) 0, rgba(210,210,210,1) 90%, rgba(255,255,255,0) 100%); 
}

.layer-preview{
	display:inline-block;
	margin-left:6%;
	/* width:20%; */
	/* padding-bottom:20%; */
	vertical-align:middle;
	
	font-size:0;
	text-align:center;
	
	height: 2.4rem;
	width: 2.4rem;
	
}

.layers-item-canvas{
	display:inline-block;
	vertical-align:middle;
	max-width:100%;
	max-height:100%;
	outline:1px solid black;
}

.layers-item-canvas-align{
	display:inline-block;
	vertical-align:middle;
	height: 2.4rem;
}

.layers-item-canvas-align::before{
	content:'';
	display:inline-block;
	height:100%;
	vertical-align:middle;
}

.layers-item-mask{
	display:inline-block;
	width: 2.4rem;
	height: 2.4rem;
	vertical-align:middle;
	font-size:0;
	text-align:center;
	margin-left:4%;
}

.layers-item-mask-disabled{
	position:absolute;
	top:0;
	left:0;
	width:100%;
	height:100%;
}
.layers-item-mask-disabled::before,
.layers-item-mask-disabled::after{
	position:absolute;
	width:80%;
	height:4px;
	left:10%;
	top: 50%;
	margin-top: -2px;
	content: '';
	background-color: #b01414;
	transform-origin: center;
}
.layers-item-mask-disabled::before{
	transform: rotate(45deg);
}
.layers-item-mask-disabled::after{
	transform: rotate(-45deg);
}

.layers-item-target-selected{
/*
	outline:1px dashed rgb(210,210,210);
	outline-offset:1px;
*/
}

.layers-item-target-selected::before{
	position:absolute;
	content:'';
	width:30%;
	height:calc(100% + 2px);
	border:1px solid rgb(210,210,210);
	border-right:none;
	top:-2px;
	left:-2px;
}

.layers-item-target-selected::after{
	position:absolute;
	content:'';
	width:30%;
	height:calc(100% + 2px);
	border:1px solid rgb(210,210,210);
	border-left:none;
	top:-2px;
	right:-2px;
}

.layers-item-name{
	display:inline-block;
	position:absolute;
	width:30%;
	height: 2.4rem;
	text-align:right;
	vertical-align:middle;
	overflow:hidden;
	font-size: 0.55rem;
	line-height: 0.8rem;
	margin-left:4px;
}

.layers-item-selected{
	background-color:rgb(100,100,100);
	color:rgb(230,230,230);
}
.layers-item-selected-multi{
/*
	background-color:#42617a;
	background-color:#345270;
*/
	background-color:#37526e;
	color:rgb(220,220,220);
}
.layers-item-dnd-drag{
	background-color:rgb(100,100,100);
}
.layers-item-dnd-drag::after{
	background-color:rgb(0,0,0);
	opacity:0.5;
	outline-offset:-1px;
	outline:1px solid white;
	
}
.layers-item-dnd-drop::after{
	background-color:#6181a3;
	background-color:#78a3cc;
	opacity:0.4;
}
.layers-item-dnd-zone-cover::after{
	content:'';
	position:absolute;
	width:100%;
	height:100%;
	left:0;
	top:0;
	cursor:grabbing;
}

#layers_options_bar{
	position:absolute;
	bottom:0;
	width:100%;
	height: 1.2rem;
	bottom:0;
}

.layers-options-btn{
	display:inline-block;
	position:relative;
	width:16%;
	height:100%;
	vertical-align:middle;
}

#add_layer{
	margin-left:19%;
}

/*
#add_layers_item_mask{
	margin-left:4px;
}
*/

#delete_layers_item{
	float:right;
}


/* ================== Dock 3 / Layers and Nav tab with Tiny view END */

/* ================== Dock 4 / Left tools dock */

.tool-btn{
	-moz-appearance:none;
	-webkit-appearance:none;
	appearance:none;
	width:100%;
	padding-bottom:100%;
	background-color: var(--btn-passive-color);
	border-radius: 0;
	line-height: 2.2rem;
}

.tool-btn-mini{
	-moz-appearance:none;
	-webkit-appearance:none;
	appearance:none;
	width: 100%;
	background-color: var(--btn-passive-color);
	padding-bottom: 1.7rem;
	line-height:1.7rem;
	border-radius: 0.5rem;
}

.tool-btn:checked{
	background-color: var(--btn-highlight-color);
}

.tool-spacer{
	width:100%;
	padding-bottom: 0.6rem;
	outline:none;
}

.tool-spacer-dark{
	width:100%;
	padding-bottom: 0.6rem;
	outline:none;
	background-color: rgb(30,30,30);
}

.tool-spacer-large{
	width:100%;
	padding-bottom:100%;
	outline:none;
}

#color_id{
	width:100%;
	padding-bottom:220%;
	border-top:1px solid var(--btn-passive-color);
	outline:none;
}

#spree_indicator{
	background-color:white;
	border-radius: 50%;
	cursor: pointer;
	-webkit-tap-highlight-color: rgba(0,0,0,0);
    -webkit-tap-highlight-color: transparent;
}
#spree_indicator::before{
	content:'';
	box-sizing:border-box;
	position:absolute;
	width:100%;
	height:100%;
	left:0;
	top:0;
	border: 0.6rem solid rgb(50,50,50);
	border-radius: 0.8rem;
	-webkit-tap-highlight-color: rgba(0,0,0,0);
    -webkit-tap-highlight-color: transparent;
}

#zoom_value{
	width:100%;
	text-align:center;
	background-color: rgb(160,160,160);
}

#zoom_fit{
	margin-bottom: 0.2rem;
}
#zoom_scale_one{
	margin-bottom: 0.2rem;
}
#zoom_toggle{
	margin-top: 0.2rem;
}

#undo_btn_tool{
	border-radius: 0 0 0.5rem 0.5rem;
	border-radius: 0.5rem;
	padding-bottom: 2rem;
}
#undo_btn_tool::before{
	content:'\293A';
	position:absolute;
	width:100%;
	height:100%;
	left:0;
	top:0;
	margin:0;
	padding:0;
	font-size: 1.2rem;
	font-weight:bold;
	text-align:center;
	line-height:2rem;
	vertical-align:middle;
}

/* touch keys module */

.tk-tool-btn{
	box-sizing: border-box;
	background-color: rgb(30,30,30);
}
.tk-tool-btn::after{
	content:'';
	box-sizing: border-box;
	position:absolute;
	border: 2px solid rgb(220,220,220);
	border-radius: 0.2rem;
	width: calc(100% - 0.2rem);
	height:calc(100% - 0.2rem);
	left:50%;
	top:50%;
	transform: translate(-50%,-50%);
	opacity:0;
	transition: opacity 0.15s;
}
.tk-tool-btn[data-toggle="1"]::after{
	opacity:1;
	transition: opacity 0s;
}

#touch_key_panel{
	position:absolute;
	/*
	left: 2.3rem;
	bottom: 1rem;
	*/
	cursor: pointer;
	left:0;
	bottom:0;
	padding: 0.2rem;
	border:2px solid rgba(var(--panel-theme-color), 0.4);
	border-radius: 0.5rem;
	background-color: rgba(var(--panel-theme-color), 0.4);
	
	/*
	--panel-theme-color: 101, 112, 115;
	--panel-theme-color: 178, 185, 194;
	--panel-theme-color: 120, 138, 143;
	--panel-theme-color: 101, 110, 115;
	--panel-theme-color: 119, 125, 128;
	*/
	--panel-theme-color: 120, 138, 143;
}
#touch_key_panel *{
	box-sizing: border-box;
}
.tk-panel-row{
	text-align:center;
	padding-bottom:0.2rem;
	padding-top:0.2rem;
}
.tk-panel-btn{
	display:inline-block;
	min-width: 2rem;
	text-align: center;
	padding: 0.8rem;
	background-color: rgba(var(--panel-theme-color), 0.4);
	color: white;
	text-shadow: 0 0 3px rgba(0,0,0, 0.9);
	border: 2px solid rgba(var(--panel-theme-color), 0.4);
}
.tk-panel-btn::after{
	position:absolute;
	content:'';
	width:calc(100% - 4px);
	height:calc(100% - 4px);
	left:0;
	top: 0;
	border: 2px solid rgba(255,255,255, 0.8);
	opacity: 0;
	transition: opacity 0.15s;
}
.tk-panel-btn[data-toggle="1"]::after{
	opacity: 1;
	transition: opacity 0s;
}
#tk_undo{
	width:50%;
	border-radius: 0.3rem 0 0 0.3rem;
}
#tk_redo{
	width:50%;
	border-radius: 0 0.3rem 0.3rem 0;
}
#tk_ctrl, #tk_ctrl::after{
	border-radius: 0.3rem 0 0 0;
}
#tk_alt, #tk_alt::after{
	border-radius: 0 0.3rem 0 0;
}
#tk_shift, #tk_shift::after{
	border-radius: 0.3rem 0.3rem 0.8rem 0.8rem;
}
#tk_ctrl, #tk_alt{
	width:50%;
}
#tk_shift{
	padding-left:0;
	padding-right:0;
	width:100%;
}




/* touch keys module end */

/* ================== Dock 4 / Left tools dock END */

/* ================== Dock 5 / canvas view */

#canvasContainer{
	position:relative;
	text-align:center;
	left:0;
	top:0;
	height:100%;
	width:100%;
	overflow:scroll;
	overflow:hidden;
	

	-webkit-user-select: none;  /* Chrome all / Safari all */
	-moz-user-select: none;     /* Firefox all */
	-ms-user-select: none;      /* IE 10+ */
	user-select: none;          /* Likely future */    
}

.visibleCanvas{
	position:absolute;
	top:0;
	left:0;
	-webkit-user-select: none;  /* Chrome all / Safari all */
	-moz-user-select: none;     /* Firefox all */
	-ms-user-select: none;      /* IE 10+ */
	user-select: none;          /* Likely future */   
}

#canvas_view_margin{
	position:absolute;
	margin:auto;
	top:0;
	left:0;
	padding:100px;
	/* outline:2px solid green;*/
	background-color:rgb(40,40,40);
	-moz-transform-origin:center;
}

#canvas_view{
	position:relative;
	left:0;
	top:0;
	border:1px solid black;
	border:none;
	outline:1px solid black;
	outline-offset:0;
	width:100%;
	height:100%;
}

.sticky-container{
	position: -webkit-sticky; /* Safari */
	position: sticky;
	left:0;
	top:0;
	width:100%;
	height:100%;
	margin-top:-100%;
}

.sticky-screen{
	position: -webkit-sticky; /* Safari */
	position: sticky;
	left:0;
	top:0;
	width:100%;
	height:100%;
	margin-top:-100%; /*make screens stackable*/
}

#canvas_draw_screen{
	position: absolute;
	left:0;
	top:0;
	width:100%;
	height:100%;
	/*cursor:none;*/
	z-index:1000;
}

#refLayer{
	display:block;
	/* position:absolute; */
	top:0;
	left:0;
	width:100%;
	height:100%;
	z-index:1001;
}

#canvas_pan_screen{
	z-index: 1001;
}

#stamp_sample_screen{
	display:none;
	cursor: crosshair;
	z-index: 1001;
}

#brush_size_screen{
	z-index:1001;
}

#quick_zoom_panel{
	position:absolute;
	display:block;
	outline:none;
	width:100px;
	height:100px;
}

#zoom_in_knob{
	position:absolute;
	width:50%;
	right:0;
	height:100%;
	outline:none;
}

#zoom_in_knob:active{
	background-color:var(--btn-active-color);
}

#zoom_out_knob{
	position:absolute;
	width:50%;
	left:0;
	height:100%;
	outline:none;
}

#zoom_out_knob:active{
	background-color:var(--btn-active-color);
}

#zoom_in_knob_icon{
	position:absolute;
	left:14px;
	bottom:2px;
	width:20px;
	height:20px;
	outline:none;
	text-align:center;
	/*outline:1px dotted green;*/
	
	line-height:20px;
	vertical-align:middle;
	font-size: 20px;
	color:rgb(190,190,190);
	border-radius:25%;
	border:1px solid rgb(100,100,100);
	background-color:rgb(50,50,50);
	opacity:0.7;
}

#zoom_out_knob_icon{
	position:absolute;
	left:14px;
	bottom:2px;
	width:20px;
	height:20px;
	outline:none;
	text-align:center;
	/*outline:1px dotted green;*/
	
	text-align:center;
	line-height:20px;
	vertical-align:middle;
	font-size: 20px;
	color:rgb(190,190,190);
	border-radius:25%;
	border:1px solid rgb(100,100,100);
	background-color:rgb(50,50,50);
	opacity:0.7;
}


#mt_transform_box{
	display:none;
	position:absolute;
	transform: translate(-50%, -50%);
	width:20%;
	height:10%;
	left:50%;
	top:50%;

	z-index: 1001;
}

#mt_rotate_handle{
	position:absolute;
	transform: translate(-50%,-100%);
	left:50%;
	top:0;
	width: 2.4rem;
	height: 2.8rem;
}

#mt_rotate_handle::before{
	content:'';
	position:absolute;
	width:0;
	height: 1rem;
	left:50%;
	bottom: 0.6rem;
	transform:translate(-50%,0);
	border:1px dashed white;
}

#mt_rotate_handle::after{
	content:'';
	position:absolute;
	top: 0;
	left:50%;
	transform:translate(-50%,0%) rotate(45deg);
	height: 0.6rem;
	width: 0.6rem;
	border-radius: 50% 50% 0 50%;
	background-color: #83c5e6;
	/* background-color: #a683e6; */
	border:1px solid white;
}

.mt-dpoint{
	position:absolute;
	width: 1.2rem;
	height: 1.2rem;
	transform: translate(-50%,-50%);
	outline-offset: -4px;
	outline:1px solid rgba(20,20,20,0.6);
}
.mt-dpoint::before{
	content:'';
	position:absolute;
	left:0;
	top:0;
	width:100%;
	height:100%;
	outline-offset: -5px;
	outline:1px solid rgba(220,220,220,0.6);
}
#mt_dpoint_1{
	left:0;
	top:0;
}
#mt_dpoint_2{
	left:50%;
	top:0;
}
#mt_dpoint_3{
	left:100%;
	top:0;
}
#mt_dpoint_4{
	left:0;
	top:50%;
}
#mt_dpoint_5{
	left:100%;
	top:50%;
}
#mt_dpoint_6{
	left:0;
	top:100%;
}
#mt_dpoint_7{
	left:50%;
	top:100%;
}
#mt_dpoint_8{
	left:100%;
	top:100%;
}

#mt_action_screen{
	display:none;
	z-index: 1002;
}

/* ================== Dock 5 / canvas view END */

/* ================== Feature Menus */

/* generic structure */

.drag-bar{
	position:absolute;
	width:100%;
	/* for vertical orientation to keep bar same height
	top: min(-1.3rem, -1.3*var(--vmu));
	height: max(1.3rem, 1.3*var(--vmu));
	*/
	top: -1.3rem;
	height: 1.3rem;
	background:rgba(80,80,80,0.5);
	outline:1px solid rgba(80,80,80,0.7);
	z-index:1010;
}

.drag-bar-name{
	width:100%;
	height:100%;
	/* for vertical orientation
	line-height: max(1.3rem, 1.3*var(--vmu));
	font-size:max(0.6rem, 0.6*var(--vmu));
	*/
	line-height: 1.3rem;
	font-size: 0.6rem;
	vertical-align:middle;
	text-align:center;
	
	font-weight:bold;
	color:rgb(130,130,130);
}

.fm-general{
	background-color:rgb(50,50,50);
	border:1px solid rgba(80,80,80, 0.7);
	
	line-height: 1.2rem;
	vertical-align:middle;
	
	z-index:1005;
}

.fm-general-name{
	width:100%;
	line-height: 1.3rem;
	font-size: 0.6rem;
	vertical-align:middle;
	text-align:center;
	
	
	font-weight:bold;
	color:rgb(130,130,130);
}

.fm-cell-spacer{
	width:100%;
	height: 0.4rem;
}

.fm-cell-field-name{
	display:inline-block;
	position:absolute;
	text-align:right;
	/* right:calc(100% + 1ch); */
	right:100%;
	white-space:nowrap;
}

.fm-list-bottom-spacer{
	width:100%;
	height: 2.4rem;
}

.fm-lib-section{
	display:block;
	position:relative;
	width:100%;
	height:calc(100% - 3.4rem);/*0.4 is spacing between panel and section*/
}

.fm-lib-action-panel{
	position:relative;
	height: 2.8rem;
	line-height: 1.2rem;
	bottom: 0;
	margin-top: 0.4rem;
	vertical-align:top;
}

.fm-lib-a-p-btn{
	display: inline-block;
	padding: 0.2rem;
	padding-left: 0.5rem;
	padding-right: 0.5rem;
	vertical-align: top;
	text-align: center;
}

.fm-lib-a-p-close-btn{
	position: absolute;
	padding: 0.9rem;
	right: 0;
	float: right;
	border-radius: 25% 0 0 25%;
}

.fm-lib-a-p-apply-btn{
	position:absolute;
	padding: 0.9rem;
	left:0;
	float:left;
	
}

.fm-cell-container{
	width: calc(100% - 2rem);
	margin-left:auto;
	margin-right:auto;
}

.fm-cell{
	width:100%;
	padding-top: 0.3rem;
	padding-bottom: 0.3rem;
}

.fm-cell-name{
	/* color: rgb(140,140,140); */
}

.fm-cell-btn{
	display:inline-block;
	padding: 0.2rem;
	padding-left: 0.5rem;
	padding-right: 0.5rem;
}


/* generic structure end */

/* adjustments / color filter */

#color_filter_menu{
	display:none;
	position:absolute;
	right: 15rem;
	top: 6rem;
	width: 16rem;
}

.cf-menu-btn{
	display:inline-block;
	background-color:var(--btn-passive-color);
	vertical-align:bottom;
}

#color_filter_menu input[type="number"]{
	width: 3rem;
	text-align:center;
}

#color_filter_menu input[type="range"]{
	width:100%;
	margin-bottom: 0.2rem;
}

#cf_mem:checked + #cf_mem_btn{
	background-color: rgb(40,40,40);
}



/* adjustments / color filter end */

/* brush preset library */

#brush_preset_lib{
	display:none;
	position:absolute;
	width: 30rem;
	height: 36.7rem;
	left: 3rem;
	top: 8rem;
}

#brush_preset_lib input[type="number"]{
	text-align:center;
	border-bottom:1px solid var(--btn-passive-color);
	width: 4rem;
	background-color: rgb(40,40,40);
	color: rgb(190,190,190);
}

#brush_preset_lib input[type="range"]{
	width:100%;
	margin-bottom: 0.2rem;
}

#brush_preset_container{
	display:block;
	position:absolute;
	left:0;
	top:0;
	bottom:0;
	height:auto;
	width:40%;
	text-align:left;
	overflow-y:scroll;
	overflow-x:hidden;
}

.brush-preset-item{
	position:relative;
	display:block;
	width:100%;
	height: 2.4rem;
	overflow:hidden;
	background-color:rgb(50,50,50);
	border-bottom:1px solid rgb(60,60,60);
	color:rgb(140,140,140);
}

.brush-preset-item-btn:checked + .brush-preset-item{
	background-color:rgb(80,80,80);
	color:rgb(210,210,210);
}

.brush-preset-item-icon{
	display:inline-block;
	position:relative;
	width: 1.8rem;
	height: 1.8rem;
	padding: 0.3rem;
	background-color:rgb(40,40,40);
}

.brush-preset-item-name{
	display:inline-block;
	position:absolute;
	top:0;
	width: calc(100% - 2.8rem);
	height:100%;
	padding-left: 0.2rem;
	padding: 0.2rem;
	line-height: 0.9rem;
}

#brush_preset_config_container{
	display:block;
	position:absolute;
	width:60%;
	right:0;
	top:0;
	bottom:0;
	height:auto;
	overflow-y:scroll;
	overflow-x:hidden;
}

#brush_preset_config_name{
	padding-left: 0.3rem;
	width:48%;
}

#brush_preset_delete_btn{
	margin-left: 0.5rem;
	margin-right: 0.5rem;
}

#brush_preset_new_btn{
	padding-top: 0.9rem;
	padding-bottom: 0.9rem;
}

#brush_preset_use_btn{
	padding: 0.9rem;
	padding-left: 1.2rem;
	padding-right: 1.2rem;
}

#brush_preset_close_btn{
	position:absolute;
	padding: 0.9rem;
	right:0;
	float:right;
	border-radius: 25% 0 0 25%;
}

/* brush preset library end */

/* ref layer library */

#ref_layer_lib{
	display:block;
	position:absolute;
	width: 30rem;
	height: 29rem;
	left: 34rem;
	top: 8rem;
	opacity:0;/* invisible loading */
}

#ref_layer_preset_container{
	display:block;
	position:absolute;
	left:0;
	top:0;
	bottom:0;
	height:auto;
	width:40%;
	text-align:left;
	overflow-y:scroll;
	overflow-x:hidden;
}

#ref_layer_preset_config_container{
	display:block;
	position:absolute;
	width:60%;
	right:0;
	top:0;
	bottom:0;
	height:auto;
	overflow-y:scroll;
	overflow-x:hidden;
}


.ref-layer-preset-item{
	position:relative;
	display:block;
	width:100%;
	height: 2.4rem;
	overflow:hidden;
	background-color:rgb(50,50,50);
	border-bottom:1px solid rgb(60,60,60);
	color:rgb(140,140,140);
}

.ref-layer-preset-item-btn:checked + .ref-layer-preset-item{
	background-color:rgb(80,80,80);
	color:rgb(210,210,210);
}

.ref-layer-preset-item-name{
	display:block;
	position:relative;
	top:0;
	width: calc(100% - 1.8rem);
	height:100%;
	
	padding-top: 0.2rem;
	padding-bottom: 0.2rem;
	
	margin-left:auto;
	margin-right:auto;
	line-height: 0.9rem;
}

#ref_layer_preset_config_container{
	overflow:auto;
}

#ref_layer_preset_config_name{
	padding-left:0.3rem;
	width:60%;
}

#ref_layer_config_preview_container{
	width:100%;
	padding-bottom:100%;
	/*background-color:rgb(128,128,128);*/
	background-color:rgb(40,40,40);
}

#ref_layer_config_preview{
	display:block;
	position:absolute;
	top:0;
	left:0;
	width:100%;
	height:100%;
}

.ref-layer-config-align{
	display:inline-block;
	position:relative;
	background-color:rgb(60,60,60);
	width:20%;
}

.ref-layer-config-align-btn:checked + .ref-layer-config-align{
	background-color:rgb(40,40,40);
}

#ref_layer_preset_delete_btn{
	margin-left:0.5rem;
	margin-right:0.5rem;
}

#ref_layer_preset_new_btn{
	padding-top:0.9rem;
	padding-bottom:0.9rem;
}

#ref_layer_preset_use_btn{
	padding:0.9rem;
	padding-left:1.2rem;
	padding-right:1.2rem;
}

#ref_layer_preset_close_btn{
	position:absolute;
	padding:0.9rem;
	right:0;
	float:right;
	border-radius: 25% 0 0 25%;
}

/* ref layer library end */

/* color picker */

#color_picker_menu{
	display:none;
	position:absolute;
	width: 26rem;
	height:auto;
	/*old
	top: 17rem;
	left: 37rem;
	*/
	top: 24.2rem;
	right: 22rem;
}

#color_picker_field_container{
	display:inline-block;
	position:relative;
	width:60%;
	padding-bottom:60%;
	margin-top:0.3rem;
	background-color:grey;
}

.color-picker-field{
	position:absolute;
	top:0;
	left:0;
	width:100%;
	height:100%;
	margin:0;
}

#cpf_hue_sb{
	background-color: rgb(255,0,0);
}
#cpf_hue_sb::before{
	position:absolute;
	content:'';
	width:100%;
	height:100%;
	background: linear-gradient(90deg, rgba(255,255,255,1) 0%, rgba(255,255,255,0) 100%); 
}
#cpf_hue_sb::after{
	position:absolute;
	content:'';
	width:100%;
	height:100%;
	background: linear-gradient(0deg, rgba(0,0,0,1) 0%, rgba(0,0,0,0) 100%); 
}

#cpf_selector{
	overflow:hidden;
}
#cpf_selector_cursor{
	position:absolute;
	width:1rem;
	height:1rem;
	left:0;
	top:100%;
	border: 1px solid black;
	border-radius: 50%;
	opacity: 0.8;
	transform: translate(-50%,-50%);
}
#cpf_selector_cursor::before{
	position:absolute;
	content:'';
	width: calc(100% - 2px);
	height: calc(100% - 2px);
	border: 1px solid white;
	border-radius: 50%;
}

#color_picker_hue_container{
	display:inline-block;
	position:relative;
	width:6%;
	padding-bottom:60%;
	left:2%;
	margin-top:0.3rem;
	background-color:grey;
}


.cpf-hue-field{
	position:absolute;
	left:0;
	top:0;
	width:100%;
	height:100%;
}

#cpf_hue_gradient{
	background: linear-gradient(0deg, rgba(255,0,0,1) 0%, rgba(255,255,0,1) 16.667%, rgba(0,255,0,1) 33.333%, rgba(0,255,255,1) 50%, rgba(0,0,255,1) 66.667%, rgba(255,0,255,1) 83.333%, rgba(255,0,0,1) 100%); 
}
#cpf_hue_selector_cursor{
	position:absolute;
	width:100%;
	top:100%;
	border-top: 2px solid white;
	border-bottom:1px solid rgb(20,20,20);
	opacity: 0.7;
	transform: translateY(-1px);
}

#cp_sample{
	position:absolute;
	top:0;
	left:0;
	width:100%;
	height:100%;
	/* border-radius:50%; */
	background-color: rgb(0,0,0);
}

#color_picker_sample_container{
	position:absolute;
	top:-25%;
	left:-11%;
	width:10%;
	padding-bottom:10%;
	outline:none;
	/* border-radius:50%; */
}

#color_picker_input_panel{
	position:absolute;
	display:block;
	top: 0;
	right: 0;
	bottom: 0;
	height:100%;
	width:30%;
}

.cp-input-label{
	display:inline-block;
	margin-left:12%;
	width:14%;
}

#color_picker_input_panel input[type="text"]{
	border-bottom:1px solid var(--btn-passive-color);
	
	background-color: rgb(40,40,40);
	color: rgb(190,190,190);
	padding-left: 0.3rem;
}

#cp_apply{
	display:inline-block;
	padding:0.9rem;
	margin-left:-4px;
}

#cp_close{
	display:inline-block;
	padding:0.9rem;
	/* border-radius: 25% 0 0 25%; */
}

#cp_dropper_screen{
	display:none;
	z-index: 1001;
}

/* color picker end */

/* canvas size */

#doc_canvas_size{
	display:none;
	position:absolute;
	width: 18rem;
	height: 12rem;
	/* centering: width + tools dock - layers dock - scrollbar */
	left: calc( (100% - 18rem + 2.2rem - 13rem - 1.2rem )/2 );
	/* left: 35rem; */
	top: 4.2rem;
}

.doc_cs_config0{
	display:inline-block;
	width:56%;
	text-align:right;
	vertical-align:top;
}

.doc_cs_config1{
	display:inline-block;
	width:42%;
	text-align:center;
	vertical-align:top;
}

#doc_canvas_size input[type="text"]{
	padding-left:0.2rem;
	width: 3rem;
}

#doc_canvas_size_config_container{
	display:inline-block;
	vertical-align:top;
	text-align:center;
}

#doc_cs_anchor_btn_container{
	width:84%;
	padding-bottom:84%;
	margin:auto;
	font-size:0;
	line-height:0;
	overflow:hidden;
}

.doc-cs-anchor-btn{
	display:inline-block;
	appearance:none;
	-moz-appearance:none;
	-webkit-appearance:none;
	width: calc(33% - 1px);
	padding-bottom:calc(33% - 1px);
	margin-right:1px;
	margin-bottom:1px;
	background-color:rgb(70,70,70);
}

.doc-cs-anchor-btn:checked{
	background-color:rgb(120,120,120);
}

/* canvas size end */

/* image size */

#doc_image_size{
	display:none;
	position:absolute;
	width: 18rem;
	height: 12rem;
	/* centering: width + tools dock - layers dock - scrollbar */
	left: calc( (100% - 18rem + 2.2rem - 13rem - 1.2rem)/2 );

	top: 4.2rem;
}

.doc_imgs_config0{
	display:inline-block;
	width:56%;
	text-align:right;
	vertical-align:top;
}

.doc_imgs_config1{
	display:inline-block;
	width:42%;
	text-align:center;
	vertical-align:top;
}

#doc_image_size input[type="text"]{
	padding-left:0.2rem;
	width: 3rem;
}

#doc_image_size_config_container{
	display:inline-block;
	vertical-align:top;
	text-align:center;
}

/* image size end */

/* make new document / doc new */

#doc_new{
	display:none;
	position:absolute;
	width: 38rem;
	height: 28rem;
	/* centering: width + tools dock - layers dock - scrollbar */
	left: calc( (100% - 38rem + 2.2rem - 13rem - 1.2rem )/2 );

	top: 4.2rem;
}

.doc_new_config0{
	display:inline-block;
	width:27%;
	text-align:right;
	vertical-align:top;
}

.doc_new_config1{
	display:inline-block;
	width:72%;
	height: calc(100% - 3.4rem);
	text-align:center;
	vertical-align:top;
}

#doc_new input[type="text"]{
	padding-left:0.2rem;
	vertical-align:bottom;
}

#doc_new_name {
	width: 6.2rem;
	margin-left: 0.2rem;
}
/*
#doc_new_name {
	width: 6.2rem;
	margin-left: 0.2rem;
	background-color: rgb(50,50,50);
	border-bottom: 1px solid rgb(60,60,60);
	color: rgb(190,190,190);
	transition: border 0.5s, color 0.3s;
}
#doc_new_name:focus{
	color: rgb(210,210,210);
	border-bottom: 1px solid rgb(120,120,120);
}
*/
#doc_new_width{
	width: 3.2rem;
}
#doc_new_height{
	width: 3.2rem;
}
#doc_new_dpi{
	width:1.8rem;
	background-color:rgb(40,40,40);
	color:rgb(190,190,190);
	margin-right:10%;
}
#doc_new_dpi:focus{
	color: rgb(210,210,210);
}

.doc-new-units{
	display:inline-block;
	position:relative;
	background-color:rgb(60,60,60);
	text-align:center;
	width:20%;
}

.doc-new-units-btn:checked + .doc-new-units{
	background-color:rgb(40,40,40);
}

.doc-new-orientation-btn{
	appearance:none;
	-moz-appearance:none;
	-webkit-appearance:none;
	display:inline-block;
	position:relative;
	background-color:rgb(60,60,60);
	/* width:20%; */
}

.doc-new-orientation-btn::after{
	content:'';
	position:absolute;
	left:3px;
	right:3px;
	top:3px;
	bottom:3px;
	border:2px solid rgb(80,80,80);
}
.doc-new-orientation-btn:checked::after{
	border-color:rgb(180,180,180);
}

.doc-new-orientation-btn:checked{
	background-color:rgb(40,40,40);
}

#doc_new_orientation_landscape{
	width: 2.6rem;
	height: 1.8rem;
}
#doc_new_orientation_portrait{
	height: 2.6rem;
	width: 1.8rem;
}

#doc_new_presets{
	display:block;
	margin-left:5%;
	width:95%;
	height: 100%;
	overflow-y:scroll;
	/* background-color:rgb(40,40,40); */
	background-color:#3e4247;
	text-align:left;
}

.doc-new-presets-group{
	min-height: 1.4rem;
	padding-left:0.1%;
	padding-right:0.1%;
}

.doc-new-presets-group-name{
	display:block;
	background-color:rgb(60,60,60);
	padding-right:2%;
	text-align:right;
	color:rgb(140,140,140);
	font-size: 0.6rem;
	line-height: 0.7rem;
	border-top: 1px solid rgb(80,80,80);
	border-bottom: 1px solid rgb(50,50,50);
}

#doc_new_presets_recent .doc-new-presets-group-name{
	background-color:rgb(90,90,90);
	color:rgb(180,180,180);
}

.doc-new-presets-tile{
	display:inline-block;
	width:19.3%;
	padding-bottom:19.3%;
	background-color:rgb(60,60,60);
	border-radius:3%;
	cursor: pointer;
}

.doc-new-presets-tile-description{
	position:absolute;
	width:100%;
	height:100%;
	left:0;
	top:0;
	text-align:center;
}

.doc-new-presets-tile-name{
	top:19%;
	font-weight: bold;
	width:80%;
	padding-left:10%;
	padding-right:10%;
	color: rgb(220,220,220);
	line-height: 0.8rem;
}

.doc-new-presets-tile-dimensions{
	position:absolute;
	color: rgb(190,190,190);
	width:100%;
	bottom: 20%;
}

.doc-new-presets-tile-units{
	position:absolute;
	font-size: 0.6rem;
	bottom:4%;
	width:100%;
	color: rgb(140,140,140);
}

.doc-new-presets-tile-btn:checked + .doc-new-presets-tile{
	background-color: rgb(80,80,80);
}

#doc_new_create_btn{
	padding:0.9rem;
	/* margin-left:1rem; */
}
#doc_new_open_btn{
	padding:0.9rem;
}

#global_doc_new_menu_lock_screen{
	opacity:0;
	background-color:rgba(0,0,0,0.6);
	z-index:1005;
}

/* make new document / doc new end */

/* save as file */
#save_as_file_menu{
	display:none;
	position:absolute;
	min-width: 20rem;
	height: 12.2rem;
	left: calc( (100vw - 13.2rem) / 2 - 10rem);
	/* left: 33rem; */
	top: 20rem;
}

.saf-menu-option-cell{
	display:inline-block;
	border: 1px solid rgb(80,80,80);
	vertical-align:top;
}

.saf-menu-option-btn{
	width: 7rem;
	height: 7rem;
	background-color: rgb(60,60,60);
	color:rgb(60,60,60);/*needed for see-through text of icon*/
}

.saf-menu-option-btn:active{
	background-color:rgb(80,80,80);
	color: rgb(80,80,80);
}

#saf_menu_option_project_btn{
	background-color:rgb(200,200,200);
	color:rgb(200,200,200);
}

#saf_menu_option_project_btn:active{
	background-color:rgb(220,220,220);
	color:rgb(220,220,220);
}


#saf_menu_option_jpg_quality_slider{
	position:absolute;
	transform-origin: top right;
	transform: rotate(-90deg);
	-moz-transform: rotate(-90deg); /*do same for other browsers if required*/
	display:inline-block;
	width: 7rem;
	top:0;
	right:1rem;
}



.file-format-icon{
	position:absolute;
	--file-icon-color:rgb(160,160,160);
	width: 3rem;
	height: 3.3rem;
	top:50%;
	left:50%;
	transform: translate(-50%, -50%);
}

.file-format-icon::before{
	display:block;
	position:absolute;
	content:'';
	width: 80%;
	height:calc(100% - 0.18rem);
	border: 0.18rem solid var(--file-icon-color);
	margin-left: -0.18rem;
	border-radius: 0.3rem;
	left:20%;
	top:0;
}

.file-format-icon::after{
	display: block;
	position: absolute;
	content:'';
	background-color: var(--file-icon-color);
	width:auto;
	min-width:1.9rem;
	height:auto;
	border-radius: 0.2rem;
	vertical-align:top;
	
	padding:3%;
	padding-left:8%;
	padding-right:8%;
	
	top: 40%;
	font-size:125%;

	font-weight:bold;
	color: inherit;
}

#saf_menu_option_project_btn > .file-format-icon{
	--file-icon-color:#3c3c3c;
}
#saf_menu_option_png_btn > .file-format-icon::after{
	content:'PNG';
}
#saf_menu_option_jpg_btn > .file-format-icon::after{
	content:'JPG';
}
#saf_menu_option_project_btn > .file-format-icon::after{
	content:'Proj';
	font-weight:normal;
}

#saf_menu_doc_name{
	width: 14.5rem;
	padding-left: 0.4rem;
	margin-left: 0.2rem;
	background-color: rgb(120,120,120);
	transition: background-color 0.3s;
}
#saf_menu_doc_name:focus{
	background-color: rgb(190,190,190);
}

/* save as file end */

/* hotkeys list */

#hk_list{
	display:none;
	position:absolute;
	width: 21.4rem;
	height: 38rem;
	left: 2.4rem;
	top: 6rem;
}

#hk_list_item_container{
	position:relative;
	overflow-y:scroll;
	height:100%;
	width:100%;
}

.hkl-item {
	border-top:1px solid rgb(90,90,90);
	border-bottom:1px solid rgb(40,40,40);
	background-color:rgb(60,60,60);
	padding-left:2%;
	padding-right:2%;
	width:96%;
}

.hkl-item:hover .hkl-item-bind-keytag{
	background-color:rgb(210,210,210);
}
.hkl-item:hover .hkl-item-action{
	color:rgb(240,240,240);
}

.hkl-item-action{
	display:inline-block;
	width:35%;
	vertical-align:top;
}

.hkl-item-bind-description{
	display:inline-block;
	padding-left:5%;
	width:58%;
	border-left:1px solid rgb(50,50,50);
}

.hkl-item-bind-keytag{
	display:inline-block;
	border-radius: 0.1rem;
	padding:0.2rem;
	padding-top:0;
	padding-bottom:0;
	color:rgb(30,30,30);
	background-color:rgb(140,140,140);
	transition: background-color 0.2s;
}

/* hotkeys list end */

/* manual menu */

#manual_menu{
	display:none;
	position:absolute;
	width: 40rem;
	height: 42rem;
	
	/* centering: width + tools dock - layers dock - scrollbar */
	/*note: scroll bar width seem to be 0.6 mu */
	left: calc( (100% - 40rem + 2.2rem - 13rem - 1.2rem )/2 );
	
	top: 5.4rem;
}
#manual_menu > .fm-lib-section{
	letter-spacing:0;
}

#manual_index{
	display:inline-block;
	width:27%;
	height:100%;
	overflow-y:scroll;
	background-color:rgb(40,40,40);
	touch-action: auto;
}

#manual_index_link_container{
	font-size:0.8rem;
}

.manual-index-link{
	font-size:inherit;
	cursor:pointer;
	padding-left:5%;
	padding-right:5%;
	border-top:1px solid rgb(60,60,60);
	color: rgb(140,140,140);
	background-color: rgb(50,50,50);
	transition: background-color 0.3s;
}

.manual-index-link:hover{
	color: rgb(190,190,190);
}
/*
.manual-index-link:active{
	background-color: rgb(110,110,110);
}
*/
.manual-index-link[data-selected="1"]{
	color: rgb(230,230,230);
	background-color: rgb(80,80,80);
	text-decoration:underline;
}

.manual-index-spacer{
	height: 1.4rem;
}

.manual-index-category{
	padding-top: 0.3rem;
	padding-bottom: 0.3rem;
	text-align:center;
	color: rgb(100,100,100);
	font-weight:bold;
	font-size: 0.7rem;
}


#manual_page_view{
	display:inline-block;
	width: 72%;
	height:100%;
	overflow-y:scroll;
	touch-action:auto;
}
#manual_page_view * {
	touch-action: inherit;
}
#manual_page_container{
	width:80%;
	margin:auto;
	-webkit-user-select: text;  /* Chrome all / Safari all */
	-moz-user-select: text;     /* Firefox all */
	-ms-user-select: text;      /* IE 10+ */
	user-select: text;          /* Likely future */ 
	padding: 1.2rem;
}

.manual-page{
	font-size: 0.8rem;
	color: rgb(140,140,140);
	/* line-height: 1rem; */
}

.manual-page section, p, strong, h1{
	font-size:inherit;
}
.manual-page h1{
	color: rgb(110,110,110);
	font-size:0.9rem;
	text-align:center;
}
.manual-page strong{
	color: rgb(190,190,190);
}
.manual-page-sample-icon{
	display:inline-block;
	padding:0;
	margin:0;
	width:1.4rem;
	height:1.4rem;
	border:1px solid rgb(80,80,80);
}
.manual-page-clickable{
	cursor:pointer;
}
.manual-page-page-link{
	display:inline-block;
	cursor:pointer;
	text-decoration:underline;
	color:rgb(190,190,190);
}
.manual-page .hkl-item-bind-keytag{
	font-size:0.7rem;
}

#manual_menu_drag_bar{
	background-color:rgb(220,220,220);
}


/* manual menu end */

/* about */

#about{
	display:none;
	position:absolute;
	width: 20rem;
	height: 30rem;
	
	/* centering: width + tools dock - layers dock - scrollbar */
	/*note: scroll bar width seem to be 0.6 mu */
	left: calc( (100% - 20rem + 2.2rem - 13rem - 1.2rem )/2 );
	top: calc(50% - 15rem);
	
	border-radius: 0.6rem 0.6rem 1.8rem 1.8rem;
	overflow:hidden;
	color:rgb(220,220,220);
	
	/*
	animation: about_menu_glow 2s infinite alternate;
	*/
	box-shadow: 0 0 7px 2px #c8f2f7, 0 15px 25px 10px rgba(0,0,0, .3);
	
	z-index: 1010;
}
/* glow animation is choppy in Firefox, so change to static 
@supports (-moz-appearance:none) {
	#about { 
		animation:none;
		box-shadow: 0 0 10px 3px #c8f2f7, 0 20px 40px 10px rgba(0,0,0, .5);
	}
}
*/

@keyframes about_menu_glow {
  from {
    box-shadow: 0 0 10px 0 #c8f2f7, 0 20px 40px 10px rgba(0,0,0, .5);
  }
  to {
    box-shadow: 0 0 10px 3px #c8f2f7, 0 20px 40px 10px rgba(0,0,0, .5);
  }
}

#about section, p, strong, h1{
	font-size:inherit;
}
#about p{
	margin:0;
}

#about h1{
	font-size: 1.1rem;
	line-height: 1.1rem;
	vertical-align:top;
	margin:0;
}
.about-color-1{
	color:inherit;
}
.about-color-2{
	color:rgb(140,140,140);
}
.about-color-3{
	color:#c8f2f7;
}
.about-trademark{
	display:inline;
	font-size: 0.7rem;
	line-height: 0.7rem;
	vertical-align:top;
}

#about a{
	color:inherit;
	text-decoration:underline;
}

#about_content_container{
	padding: 2rem;
	height: calc( 100% - 4rem);
	overflow:hidden;
	-webkit-user-select: text;  /* Chrome all / Safari all */
	-moz-user-select: text;     /* Firefox all */
	-ms-user-select: text;      /* IE 10+ */
	user-select: text;          /* Likely future */ 
}

#about_credits{
	min-height: 8rem;
	max-height: 10rem;
	overflow-y:scroll;
	background-color:rgba(0,0,0,0.1);
	padding: 0.8rem;
	color: rgb(140,140,140);
	font-size: 0.65rem;
	line-height: 0.8rem;
}
#about_credits span{
	display:inline;
}

/* about end */

/* dialog box */

#dialog_box{
	display:none;
	position:absolute;
	width: 22rem;
	min-height: 4rem;
	right: 14.2rem;
	top: 5.6rem;
}
#dialog_box_options{
	text-align:center;
}
#dialog_box_options .fm-lib-a-p-btn{
	min-width: 4.8rem;
}
#dialog_box_text{
	padding-top: 1.2rem;
	padding-bottom: 1.2rem;
	overflow: hidden;
}

/* --- */

.element-attention-pulse::after{
	content: '';
	position:absolute;
	left:0;
	top:0;
	width:100%;
	height:100%;
	box-shadow: 0 0 4px 2px rgb(179, 227, 255) inset;
	animation: attention_pulse_opacity 1s infinite linear alternate;
}

@keyframes attention_pulse_opacity{
	from { opacity: 1; }
	to { opacity: 0.1; }
}

/* dialog box end */

/* ================== Feature menus END */

/* ================== icons */

[class*="icon-"]{
	/* applies to any class with prefix icon- */
	background-size: contain;
	background-repeat: no-repeat;
	background-position: center center;
}

/* 
Note: icon images/SVG can be used as background-image on original element
this preserves original colors of icons
OR
as masks on ::after element, with background-color of choice
for masks to not cause CORS - need to embed SVG as URI
mask-image: url('data:image/svg+xml;base64, encoded svg code');
mask-* properties similar to background-*
the svg code can be base64 encoded or URL escaped/encoded

when URL encoding is used - it may be good to omit the charset (i.e. base64,utf-8 etc.)
for browser compatibility purposes
*/

/*
[class*="icon-"]::after{
	background-color:rgb(170,170,170);
	content:'';
	position:absolute;
	top:0;
	bottom:0;
	left:0;
	right:0;
	mask-size:contain;
	mask-position:center center;
	mask-repeat:no-repeat;
}
*/

/*example: 
.icon-move_tool{
	background-image:url("resources/icons/icon_move_tool.png");
}
*/

.icon-light_brush_logo{
background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0\
IArs4c6QAACfBJREFUWEeNVwtMlFcWPnf+f2aYB8PwGAYUQRhAQBweIiOgyKu8pODbbmt3rUlpUl\
LTJtvaNtku0W6z7babanftI03T7G53t920qa2NBSmoVRREGZAC4oC8h+HlMO/H/9jcsRd/6fMmf/\
65M3fu+c53vnPOvQh+xXgq8YRKRCmiRZQkkqJEYTwvUgHiZDzFi4HlAAHnB5p3IwlvY3nPIif2zX\
KMyPxWx2HbL22Pfm4BNuxBVIJMLIuTSmQxMipIi2hxeMwarSpEo5LzwIuRiAfgwW9bcrhmpqdsLL\
ALLO+zeH3uSQ6YMQ/rGfk5ID8JoD7xhI5C0hS5NChRKlXEJyQlrIlZGxnNidnIBe9E+JJnXubxuy\
mO40DESNhQRYQ7OnjtggjRsw6H22xbXJyYGB2/7fJ4TRzrGvzLtSeGf8zZHwHAo8eTTmbIkHyDQi\
FLUwapkwsqN+lG7D263vlupcncCxOWfuBYLyAEwPN84AEeICY0EXQRG0AfW+BIi9o0bDHfGR7sGR\
hy2h39bt5z403jwR4AxAuBrADAo8eTj+fIROqsELk6IzNvfbo/dFF/4eYp9cXB0xCsjYfQqCQQMV\
5wWSfB71kCjvUH9vP7/eDxeIBlWeA5HvJ0VbBF96BVK0nsNd+29I2ZJnrsnKv7deP+LiQAcR+Ah5\
Ney1RS8lx1kDbHsCUra5y/lvll9wf0nH0aJBIJqDWrQZNUACp1LLiWpuHO9HfgXBgHnvMDDgUZDo\
cDvF4vRChXQUXqb5m8uGrjwqy1e6BrsMvDuDpfMe4zkrXLAPanH9PJQJa/zVC0OSZmde6V8dM5n1\
7/O7AcGzAul8sBIQTyiDWwKtEAEatTwe3xwkRfM9gsJmB9LuA5LrAGD6fTCT6fD3B0dmc2QFH8nq\
7pEXPnxOjYFTtnb3+5/aGAJgKrHzE0qpAzaGuabsOWzTk5+dfMrfn/vPhnmhMYX0aMENBSBaxJLQ\
DN2kxgpSqYG++H2f5z4LXN3KcLDMZms4Hfz8CBjc8xebGV7fOT0+0Tk0MXl8S+bxvPHLAFABzMfC\
2ToqTbHtqxt9DiGi55v+2oet5hvs/zgNAw4u89FEvlEBqbDrGp+aBQa2FxzgKmS/8Bj30uAEIYEs\
yEDInhcOU+a4ivunV62HjB7bWfr//8MSPC3stYVfFDdfuKFUpV0Qfnj2ZcNn0NYrEYZDJZwCA2Lh\
KJlmNMQAASgUwdCQm5VRC7Tg+z5gm40fIpeK2TABxz33qr1Qol+ih4entpz/RY7bmJ0QttjMPXhg\
7lHFuXt6m0LCUhsWTAfK38RPNzSpxTwcHBd9ML7qYaRVEBrzAQDIB8xiuk6nDI3X4AolMyYMxiBt\
OVNljovQLI78R/DuyBWXC7XPCnQ8mOpLDa5uHBxVa3h2lBB7cd3VplqH0gWKks+7jjeN718XNA0z\
RIpdKAYZxW2DhhghjGQJZrwPcgNx5sgPhNW8Dh9kLv55+AuaMFEHuPCbvdDnV5Cqjfrrk81J/b4m\
PRWfRw8ZG6revLyrXhERV/O/u8jsQeb46NEm8JAKID4ZwwRUkkELO5BDZU7AKXzQ7dZ06D7WYHiG\
gKOI8rwEKshoO/Phk2fHsmv8nnQ81ob0XDo8VpFeWciKl572yjGm9MvMNvIiYSdzxfCYywgsGJpV\
KI0W+GCN16mBr6DpBcDMrkFLhjuglW41Xw3FmA1w4HW9WR8aen5mKb0a4dD9eXFRVWzE9at3/y9b\
+kmG6h6BjmLoVCo2ROwBC1LTNBi4GWykAsC4KS+idhbUEBWEbHoffLU3Drm6/hmd+JvXr9qq96nU\
lNaOcjNQ2Fe9dV3L4xVdX6cR9NqCebYiNkYyJIAmalYeF/MHuK0FCoaXgKDHV14Ha4oPNME7S8fR\
wO7kRMdn7UmevelCa081BFQ9HudRVTQ4tVX7zbFQBAVC/MgpWiI0wJGwsBe48JGuLS06G6vh7WGw\
wwdq0bPnjpD7B9zyomszT9TN+0vQntqi+vL6xLrViacWz/6NVvpZhyogOhh0JtLNcBgXUhWBIa/K\
axMJOTIa+iEuLi18K/X38DSh81eOMKs7+aGuhqQnsbSh5Ny40pV6vVNe8caVIzfibQ2bCHJNbEey\
H1K0EQ5ggQwkYgjWkaomNjIVWvh5H+ASh68YhVk5xwer7z3Wa055niOmWoqLxqd37FO8+e1U3eWg\
h0MjKwcVJ8iDhXZgFZi43hQTJHGBJcWUPUatCmpELlG8eHPTZvk8P4RjPa80LBVqVa9MCO/aVlX7\
x9Le/CpwMBBvBmpPwSg8RrYTgISxgcMUgAkHCSuUKhgKzfPALbfv/i5d6OnpYQy//OotpjOetCQq\
my4qKNJYsmpvy9I+eULMMGDhdCjwkY8hbWg5W0C8NBfsOVlRaLYcdbJx2a9K3NrZcutCY4WlpQ1Q\
mDSiHzFketFhVXGWqLPjp6KaPj9MgyC8uK/l4TKyshqZSEejxfGQqsJ+x9Wm0dlP3x5Z7rff5z/f\
OmtsTRU22BdrzjvbRM5Wp+W+2mysLFm1zJ+y98o16cdgGmED/C2kAEKUw/YX3AzJCHfI8bW1hsHF\
S+8qpVlZTd2jrgumBZHDlv3JllDACoOpGoksWhrTkpSVv00Vn5Vz8fy/9H4yUan+3wZgQEyX3SoI\
gBYQpiBoSg8UlKLJFA6fMvMck1+9t7Jpj2y/OzF8OG+r/tOFx990CCR8l/E3WRGjZfq5VsLoqtzj\
3/4WjOqTeNgQOm2+1e7g9EiMLUXFmAhF0yWKWCoqefhY37D3WNmP2dfTb3leH+nnbTE6X3jmQERP\
VHSZnBWi53Q1xijl6zKevqZ6OZn53spJ3zvvvCIdSBkAUiTJxymK2QVTGQ//iTTMqDu403Z/zd35\
gdXbDk7by1L/6Hh9IACB5Q5YcJOXI1lVWYWpCxJjgmve3MkL6taUjtvGpd7gk4BLi1Cgc2is8Rgc\
5IUZBeUwcZNfusYVnZvbfu8H2tJmcP67B0j+xf3wXo3t3ghxcTHlDRybQMES/aIKdQ2q5tZclfzE\
zpRr+b1fl67UpmwAXsjC9wERGWany8DU9OglVZ2bA6O8cRnpE97JVGD/eN+4aGph39yHnnxq3H0n\
7pYnJv043H0nWUCFKCxXSiPmlt/GyUfI3J74y2zTsjvePucLTEyyi/mFJT0RAs07BxybnuqPUbFy\
RK7azbA2bjqHvilkd0m2I4Ez82Nmg6XPBrr2b3QBgaDSrO500IkkNcEC2NkSCJdiRcFO4Kp1W0SC\
pXKMLEGqocNKFZflqicc3aeNuwZWmB45GF8ngnmYWZMXpudsTUeOAnb8k/ezsmUDAQmmKjgyhFJC\
cKCuM4hQokITJWHCJ2RVaDK0jjZyRKN7hYGzs3uggLg7PUrNVseqvxF6/n/wfyZ2VgbN0R/gAAAA\
BJRU5ErkJggg==");
}

.icon-fullscreen_toggle{
background-image: url("data:image/svg+xml,%3Csvg xmlns='http:\
//www.w3.org/2000/svg' viewBox='0 0 72 60' width='72' height='60'%3E%3Cpath \
d='M 58.41,8 H 13.59 A 5.59,5.59 0 0 0 8,13.56 V 46.41 A 5.59,5.59 0 0 0 13.59,\
52 H 58.41 A 5.59,5.59 0 0 0 64,46.41 V 13.56 A 5.59,5.59 0 0 0 58.41,8 Z M 30,\
20 H 21.24 A 1.24,1.24 0 0 0 20,21.24 V 26 a 2,2 0 0 1 -4,0 V 21.24 A 5.24,5.24 \
0 0 1 21.24,16 H 30 a 2,2 0 0 1 0,4 z M 56,38.76 A 5.24,5.24 0 0 1 50.76,44 H \
42 a 2,2 0 0 1 0,-4 h 8.76 A 1.24,1.24 0 0 0 52,38.76 V 34 a 2,2 0 0 1 4,0 z' \
fill='%23aaa' data-name='Layer 2'/%3E%3C/svg%3E");
}

.icon-solidify_spree_btn{
background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' \
xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='none' d='M-1 -1H101V101H-\
1z'/%3E%3Cg%3E%3Cpath fill='%23aaa' stroke='%23aaa' d='m36.799999,52c0.200001,-\
0.299999 0.5,-0.599998 0.700001,-1l3.200001,7.700001c-1.400002,-0.100002 -\
2.900002,-0.200001 -4.299999,0l-2.5,-6.200001c0.399998,0.099998 0.799999,\
0.200001 1.199997,0.200001c0.100002,0 0.200001,0 0.200001,0c0.5,0.099998 \
1.100002,-0.200001 1.5,-0.700001zm-15.199999,-30.200001c0.299999,0.700001 \
0.199999,1.400002 -0.300001,2l-3.699999,4.700001c0.4,1.4 0.9,2.799999 1.4,\
4.099998c3.4,8.300003 9.6,14.700001 15.299999,16c3.100002,-5 2.900002,-\
13.799999 -0.5,-22.099998s-9.599998,-14.7 -15.299999,-16c-1.5,2.4 -2.299999,\
5.799999 -2.200001,9.700001l3.6,0.4c0.800001,0 1.4,0.5 1.700001,\
1.199999zm62.599997,50.299999c-0.299995,-0.099998 -0.699997,-0.099998 -\
1.099998,-0.199997c-3.299995,-0.599998 -5.5,-2 -9,-4.400002l-0.900002,-\
0.599998c-0.099998,0 -0.099998,-0.099998 -0.199997,-0.099998c-6.099998,-\
5.000004 -14.099998,-5.700005 -20.799999,-1.600006l-0.200001,0.300003l0,\
17.400002c7.700001,-3.800003 16.699997,-2.800003 23.5,2.799995l0.699997,\
0.400002c2.700005,1.800003 4.300003,2.900002 6.100006,3.5l8.699997,0l0,-\
17.199997c-2.300003,0.299995 -4.599998,0.199997 -6.800003,-0.300003zm-\
57.299997,-5.299995c0,0 -0.1,0.099998 -0.199999,0.099998l-0.800001,0.599998c-\
3.6,2.400002 -5.699999,3.800003 -9.1,4.400002c-0.4,0.099998 -0.799999,0.099998 -\
1.099999,0.199997c-2.2,0.5 -4.5,0.599998 -6.8,0.200005l0,17.199997l8.700001,\
0c1.799999,-0.599998 3.4,-1.699997 6.1,-3.5l0.599998,-0.400002c6.800001,-\
5.599998 15.900002,-6.599998 23.5,-2.799995l0,-17.300003l-0.299999,-0.199997c-\
6.5,-4.100002 -14.5,-3.500004 -20.6,1.5zm0,22c0,0 -0.1,0.099998 -0.199999,\
0.099998l-0.700001,0.5c-0.1,0 -0.200001,0.099998 -0.200001,0.199997l22.200001,\
0l0,-2.099998l-0.299999,-0.199997c-6.700001,-4.100006 -14.700001,-3.5 -\
20.800001,1.5zm46.299997,0.099998c-0.099998,0 -0.099998,-0.099998 -0.199997,-\
0.099998c-6.099998,-5 -14.099998,-5.700005 -20.799999,-1.600006l-0.200001,\
0.300003l0,2.099998l22.199997,0c-0.099998,0 -0.099998,-0.099998 -0.199997,-\
0.199997l-0.800003,-0.5z'/%3E%3C/g%3E%3C/svg%3E");
	background-size:auto 80%;
}

.icon-discard_spree_btn{
background-image: url("data:image/svg+xml,%3Csvg width='48' height='48' \
xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='none' d='M-1 -1H581V401H-\
1z'/%3E%3Cg%3E%3Cpath fill='%231e1e1e' d='M3.6 47.5l40.9 0c1.700001 0 3-\
1.400002 3-3l0-40.9-43.9 43.9zM44.400002.5l-40.900002 0c-1.7 0-3 1.4-3 3l0 \
40.900002 43.900002-43.900002z'/%3E%3C/g%3E%3C/svg%3E");
	background-size:auto 76%;
}

.icon-tiny_preview_btn{
background-image: url("data:image/svg+xml,%3Csvg xmlns='http:\
//www.w3.org/2000/svg' width='118' height='101'%3E%3Cg fill='%23aaa' \
transform='translate(-4.8 -13.4)'%3E%3Cpath d='M98.1 33.4H29.9c-2.8 0-5.1 2.3-\
5.1 5.1v50.9c0 2.8 2.3 5.1 5.1 5.1H98c2.8 0 5.1-2.3 5.1-5.1V38.5c.1-2.8-2.2-5.1-\
5-5.1zm-2.2 7.2v34.7L83.8 63.2c-1.6-1.6-4.3-1.6-5.9 0l-16 16-8.1-8.1c-1.6-1.6-\
4.3-1.6-5.9 0L32 87V40.6z'/%3E%3Ccircle cx='50.700001' cy='54.5' \
r='7'/%3E%3C/g%3E%3C/svg%3E");
}



.icon-tool_options{
/* old
background-image: url("data:image/svg+xml,%3Csvg width='630' height='512' \
xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='none' d='M-1 -1H631V513H-\
1z'/%3E%3Cg%3E%3Cpath fill='%23c8c8c8' d='M107.508347 186.609573c-9.10865-4.731018-\
19.424339-7.28949-29.835228-7.711212-20.955338-.825562-42.014179 8.273514-\
56.302408 23.42627-14.25052 15.231995-21.98664 35.986053-21.33233 \
56.303055.44984 20.343811 9.33613 40.136841 23.84927 53.785461 14.411549 \
13.780243 34.276779 21.308685 53.785469 20.706757 19.548302-.737366 38.238449-\
9.754639 50.529228-23.964294 12.448593-14.044769 19.363632-32.127869 19.777695-\
50.527924.456863-18.341278-5.125259-37.367538-17.371933-52.935638-6.194908-\
7.639633-14.006439-14.322083-23.099762-19.082474zm17.584724 119.438065c-\
13.300987 11.570618-30.640984 17.464569-47.419952 16.603241-16.816029-.476685-\
32.981567-7.860748-44.162437-19.862061-11.267761-11.942505-17.293972-28.181549-\
16.722092-44.161133.531631-16.009003 7.708651-31.287003 19.23904-41.646149 \
11.303551-10.627502 26.276119-16.440933 41.645489-17.145096 15.29142-.52652 \
31.568794 3.447937 45.014198 13.777679 13.534225 10.024307 22.863968 27.027557 \
23.199432 45.013565.536102 17.92337-7.460724 35.872314-20.793678 \
47.419952zM348.505066 186.609573c-9.108002-4.731018-19.424347-7.28949-29.834595-\
7.711212-20.955963-.825562-42.01416 8.273514-56.302399 23.42627-14.250534 \
15.231995-21.987289 35.986053-21.332977 56.303055.449203 20.343811 9.336136 \
40.136841 23.849274 53.785461 14.412201 13.780243 34.276764 21.308685 53.786102 \
20.706757 19.547668-.737366 38.237183-9.754639 50.528595-23.964294 12.448608-\
14.044769 19.363617-32.127869 19.77832-50.527924.456238-18.341278-5.125885-\
37.368805-17.372559-52.935638-6.194275-7.639633-14.006439-14.322083-23.099762-\
19.082474zm17.584717 119.438065c-13.300995 11.570618-30.641632 17.464569-\
47.419312 16.603241-16.81665-.476685-32.981567-7.860748-44.162415-19.862061-\
11.268433-11.942505-17.294006-28.181549-16.722748-44.161133.532257-16.009003 \
7.708649-31.287003 19.239044-41.646149 11.303528-10.627502 26.276123-16.440933 \
41.646118-17.145096 15.290771-.52652 31.568146 3.447937 45.01355 13.776398 \
13.534241 10.025589 22.864624 27.028839 23.199432 45.014847.536102 17.92337-\
7.460083 35.872314-20.793671 47.419952zM612.602173 205.693329c-6.194946-\
7.640915-14.00708-14.323364-23.100403-19.083755-9.107971-4.731018-19.423035-\
7.28949-29.834595-7.711212-20.954651-.825562-42.012878 8.272232-56.302399 \
23.42627-14.250519 15.233276-21.985992 35.986053-21.331696 56.303055.449219 \
20.343811 9.33551 40.136841 23.848633 53.785461 14.41156 13.780243 34.277466 \
21.308685 53.785461 20.706757 19.547668-.737366 38.238464-9.754639 50.529236-\
23.964294 12.448608-14.044769 19.363037-32.127869 19.77771-50.527924.456848-\
18.341278-5.125244-37.367538-17.371948-52.934357zm-5.514404 100.353027c-\
13.301636 11.571899-30.641602 17.465851-47.420593 16.604523-16.815369-.475403-\
32.981567-7.860748-44.161133-19.862061-11.268402-11.942505-17.293976-28.181549-\
16.722748-44.161133.532288-16.009003 7.708649-31.287003 19.239044-41.646149 \
11.303589-10.627502 26.275513-16.440933 41.644836-17.145096 15.291443-.52652 \
31.568176 3.447937 45.014221 13.777679 13.53418 10.024307 22.863953 27.027557 \
23.199463 45.013565.5354 17.92337-7.460815 35.872314-20.793091 \
47.418671z'/%3E%3C/g%3E%3C/svg%3E");
	background-position: center 95%;
	background-size:60% auto;
*/

background-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' \
%3F%3E%3Csvg viewBox='0 0 64 64' \
xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%234398d1%3B%7D.cls-\
2%7Bfill:%23c1c7c9%3B%7D.cls-3%7Bfill:%233e8cc7%3B%7D.cls-4%7Bfill:%233269a1%3B%7D.cls-5%7Bfill:%23fda72f%3B%7D.cls-\
6%7Bfill:%23b8bdbf%3B%7D.cls-7%7Bfill:%23ff9945%3B%7D.cls-8%7Bfill:%23e34b87%3B%7D.cls-9%7Bfill:%23f285b0%3B%7D.cls-\
10%7Bfill:%23d94881%3B%7D%3C/style%3E%3C/defs%3E%3Cg id='flat'%3E%3Cpath class='cls-1' d='M42 61H39a2.4 2.4 0 0 0-4 0H30a5 5 0 0 \
1-5-5h0a5 5 0 0 1 5-5H42Z'/%3E%3Cpolygon class='cls-2' points='42 58 53 58 57 59 61 58 \
61 54 57 53 53 54 42 54 42 58'/%3E%3Cpath class='cls-3' d='M42 51H30a5 5 0 0 0 0 \
10h5a2.39 2.39 0 0 1 2.885-.885L42 56Z'/%3E%3Cpolygon class='cls-4' points='38 3 32.615 \
4.615 36.385 8.385 38 3'/%3E%3Cpolygon class='cls-5' points='32.615 4.615 28 6 35 13 \
36.385 8.385 32.615 4.615'/%3E%3Crect class='cls-1' height='4.95' \
transform='translate(-8.267 18.543) rotate(-45)' width='32.527' x='1.987' y='16.775'/%3E%3Crect \
class='cls-3' height='4.95' transform='translate(-9.716 22.043) rotate(-45)' width='32.527' \
x='5.487' y='20.275'/%3E%3Cpath class='cls-2' d='M34 33V29a1 1 0 0 1 1-1h5a6.909 6.909 0 \
0 0-6.26-4A6.987 6.987 0 0 0 28 27H9v8H28a6.987 6.987 0 0 0 5.74 3A6.909 6.909 0 \
0 0 40 34H35A1 1 0 0 1 34 33Z'/%3E%3Crect class='cls-6' height='2' width='11' \
x='17' y='30'/%3E%3Crect class='cls-5' height='9.899' transform='translate(-17.018 \
43.914) rotate(-45)' width='36.77' x='26.115' y='37.55'/%3E%3Crect class='cls-7' \
height='2.828' transform='translate(-18.054 46.414) rotate(-45)' width='36.77' x='28.615' \
y='43.586'/%3E%3Cpath class='cls-8' d='M38 53.222h0A7.778 7.778 0 0 1 30.222 61h0a7.777 7.777 0 0 \
1-5.5-2.278L5.278 39.278A7.777 7.777 0 0 1 3 33.778H3A7.778 7.778 0 0 1 10.778 26h0a7.777 7.777 \
0 0 1 5.5 2.278L35.722 47.722A7.777 7.777 0 0 1 38 53.222Z'/%3E%3Cpath \
class='cls-9' d='M8 33.778H6a4.783 4.783 0 0 1 .564-2.251l1.763.946A2.728 2.728 0 0 0 8 \
33.778Z'/%3E%3Cpath class='cls-9' d='M12.293 42.051 7.4 37.157a4.881 4.881 0 0 \
1-.486-.566l1.614-1.182a2.838 2.838 0 0 0 .287.335l4.892 4.893Z'/%3E%3Crect class='cls-4' height='4.243' \
transform='translate(-6.19 46.056) rotate(-45)' width='2' x='51.5' y='28.379'/%3E%3Crect class='cls-4' \
height='2.828' transform='translate(-8.983 44.314) rotate(-45)' width='2' x='48' \
y='31.586'/%3E%3Crect class='cls-4' height='4.243' transform='translate(-12.19 43.571) rotate(-45)' \
width='2' x='45.5' y='34.379'/%3E%3Crect class='cls-4' height='2.828' \
transform='translate(-14.983 41.828) rotate(-45)' width='2' x='42' y='37.586'/%3E%3Crect class='cls-4' \
height='4.243' transform='translate(-18.19 41.086) rotate(-45)' width='2' x='39.5' \
y='40.379'/%3E%3Cpath class='cls-10' d='M35.722 47.722 16.278 28.278A7.777 7.777 0 0 0 10.778 \
26h0a7.861 7.861 0 0 0-1.5.147 7.778 7.778 0 0 1 4 2.131L32.722 47.722a7.777 7.777 0 0 \
1-4 13.131 7.829 7.829 0 0 0 1.5.147h0a7.778 7.778 0 0 0 \
5.5-13.278Z'/%3E%3Cpolygon class='cls-6' points='42 54 42 58 46 54 42 54'/%3E%3C/g%3E%3C/svg%3E");

	background-position: center 70%;
	background-size:60% auto;
}





.icon-layers_eye{
background-image: url("data:image/svg+xml,%3Csvg xmlns='http:\
//www.w3.org/2000/svg' width='130' height='100' viewBox='0 0 169 130'%3E%3Cpath \
fill='none' d='M-1 -1H101V101H-1z'/%3E%3Cg transform='translate(34.4555,\
13.635002)' fill='%23aaa'%3E%3Cpath d='M 50.044998,20.698999 C 26.083,20.698999 \
0,51.365001 0,51.365001 c 0,0 23.757999,30.665997 50.044998,30.665997 26.286003,\
0 50.044002,-30.665997 50.044002,-30.665997 0,0 -26.084003,-30.666002 -\
50.044002,-30.666002 z m 0,51.681997 c -11.605,0 -21.020998,-9.405998 -\
21.020998,-21.015995 0,-11.611 9.415998,-21.018002 21.020998,-21.018002 11.605,\
0 21.015999,9.407001 21.015999,21.018002 0,11.609997 -9.410995,21.015995 -\
21.015999,21.015995 z'/%3E%3Ccircle cy='40.73893' cx='59.581703' stroke-\
opacity='null' stroke-width='null' stroke='null' \
r='9.3332596'/%3E%3C/g%3E%3C/svg%3E");
}

.icon-clear_btn{
background-image: url("data:image/svg+xml,%3Csvg width='128' height='128' \
xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='none' d='M-1 -1H581V401H-\
1z'/%3E%3Cg%3E%3Cpath fill='%23aaa' d='m122.300003,31.700001c-1,-1.6 -2.600006,-\
2.700001 -4.5,-2.700001l-53.800003,0c-2.400002,0 -4.599998,1.299999 -5.900002,\
3.299999l-16.699997,24.700001l-33.100001,0c-1.1,0 -2,0.900002 -2,2c0,0 0,0 0,\
0.099998c0,0.200001 0,0.300003 0,0.5s4.3,17.099998 22.099999,19.400002l-6.4,\
10.300003c-1,1.599998 -1.1,3.599998 -0.200001,5.299995c0.900002,1.599998 2.6,\
2.5 4.5,2.5l58.700001,0c2.900002,0 5.5,-1.299995 6.900002,-3.799995l9.699997,-\
17.900002l-69.099998,0.099998c-14.200001,0 -19.7,-9.900002 -21.5,-14.5l62.5,\
0c0.300003,0.900002 0.699997,2.200001 1.300003,3.5c2.199997,5.199997 7.399994,\
8.5 13,8.5l15.199997,0l19.400002,-35.900002c0.900002,-1.599998 0.799995,-\
3.799999 -0.099998,-5.399998z'/%3E%3C/g%3E%3C/svg%3E");
}



.icon-brush_library{
background-image: url("data:image/svg+xml,%3Csvg width='32' height='32' \
xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='none' d='M-1 -1H33V33H-\
1z'/%3E%3Cg%3E%3Cpath fill-rule='evenodd' fill='%23aaa' d='m26,20.006001l0,8c0,\
2.209 -1.791,4 -4,4l-12,0c-2.209,0 -4,-1.791 -4,-4l0,-8c-1.104,0 -2,-0.895 -2,-\
2c0,-1.104 0.896,-2 2,-2l4,0l12,0l4,0c1.104,0 2,0.896 2,2c0,1.105 -0.896,2 -2,\
2zm-2.799999,-6.000001l-6.400002,0c-0.441,0 -0.799999,-0.356999 -0.799999,-\
0.799999l0,-2.400001l0,-1.599999c0,-0.450001 1,-2.399 1,-2.399c0.200001,-0.398 \
0.358,-0.801 0.799999,-0.801l4.400002,0c0.441,0 0.605999,0.402 0.799999,0.801c0,\
0 1,1.938 1,2.399l0,1.599999l0,2.400001c0,0.441999 -0.358,0.799999 -0.799999,\
0.799999zm-1.800001,-10l-2.799999,0c-0.204,0 -0.399,-0.206 -0.399,-0.4c0,-0.449 \
1,-2.799 1,-2.799c0.199999,-0.398 0.358,-0.801 0.799999,-0.801s0.606001,0.402 \
0.800001,0.801c0,0 1,2.337 1,2.799c-0.001001,0.194 -0.215,0.4 -0.401001,0.4zm-\
8.2,10l-4.4,0c-0.441,0 -0.8,-0.349999 -0.8,-0.799999s1,-2.400001 1,-\
2.400001c0.2,-0.396999 0.358,-0.8 0.8,-0.8l2.4,0c0.441,0 0.606,0.402 0.8,0.8c0,\
0 1,1.938001 1,2.400001c0,0.462 -0.358,0.799999 -0.8,0.799999zm-2.2,-6c-1.656,\
0 -3,-1.342999 -3,-3c0,-1.656 2.1,-5 3,-5s3,3.344 3,5c0,1.657 -1.343,3 -3,3z' \
clip-rule='evenodd'/%3E%3C/g%3E%3C/svg%3E");
	background-size:52% auto;
	background-position: center 67%;
}



.icon-move_tool{
background-image: url("data:image/svg+xml,%3Csvg height='512px' viewBox='0 0 \
512 512' width='512px' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath clip-\
rule='evenodd' d='M247.084,7.938l-74.375,94.022 c-3.027,5.439-3.926,8.766-2.118,\
11.788c1.819,3.327,5.145,3.931,11.189,3.931h51.698v115.794H117.684v-51.696 c0-\
6.049-0.599-9.375-3.926-11.188s-6.354-0.909-11.798,2.118L7.935,247.078c-10.58,\
8.161-10.58,9.669,0,18.146l94.025,74.063 c5.445,3.027,8.771,4.236,11.798,\
2.428c3.327-1.818,3.926-5.145,3.926-11.488V278.52h115.793v115.8H181.78 c-6.044,\
0-9.37,0.898-11.189,3.926c-1.808,3.326-0.909,6.653,2.118,11.787l74.375,\
94.032c8.162,10.579,9.681,10.579,18.142,0 l74.076-94.032c3.017-5.134,4.225-\
8.461,2.417-11.787c-1.818-3.027-5.145-3.926-11.488-3.926h-51.697v-\
115.8h115.793v51.706 c0,6.344,0.898,9.67,3.926,11.488c3.327,1.809,6.653,0.6,\
11.788-2.428l94.026-74.063c10.578-8.477,10.578-9.985,0-18.146 l-94.026-74.373c-\
5.135-3.027-8.461-3.931-11.788-2.118c-3.027,1.813-3.926,5.14-3.926,\
11.188v51.696H278.533V117.678h51.697 c6.344,0,9.67-0.604,11.488-3.931c1.808-\
3.322,0.6-6.349-2.417-11.788L265.226,7.938C256.765-2.646,255.246-2.646,247.084,\
7.938 L247.084,7.938z' fill='%23AAA' fill-rule='evenodd'/%3E%3C/svg%3E");
	background-size: 54% auto;
}

.icon-auto_select_tool{
background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' \
xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='none' d='M-1 -1H581V401H-\
1z'/%3E%3Cg%3E%3Cpath fill='%23aaa' d='M59.662998 51.929001l-28.323997-\
28.324001c.045-.094999.095999-.185999.139-.281.229-.501999.007-1.095999-.496-\
1.323999-.373001-.17-.791-.087-1.078001.171l-1.316999-1.316999 0 0-.768999-\
.769001 0 0-.926001-.925999 0-.000999-7.532-7.532001-.769001-.769-1.538-1.538-\
.706999-.707c-.388-.388-1.015-.389001-1.405001-.006001-.002.003-.006.003-\
.009.006001l-1.943 1.943999c0 0 0 0-.001.001l-.552.552-1.304 1.304 0 0-\
.619.618999 0 0-1.237 1.237 0 0-.708.708c-.095.094999-.167.205999-.217.328-\
.042.103-.058.212-.064.322-.000999.02-.011.038-.011.058001 0 \
.02.01.037.011.056.006001.11.022.22.064.322999.05.122002.123.234001.218.328001l.707.707001 \
1.537 1.536999c0 0 0 0 0 .000999l.769.769001c0 0 0 0 .001 0l1.536 \
1.537001.000999.000999.77.768999 5.224999 5.225 3.013 3.013c-.257.285999-\
.34.705-.171 1.077999.167.369001.531.586.910999.586.139 0 .278999-.028999.414-\
.09.095001-.042999.187-.094.281-.139l28.325001 \
28.323999c.195.195.451.292999.707001.292999s.511997-.098.706997-\
.292999l6.364002-6.363998c.188-.188.292999-.442001.292999-.707001s-.107998-\
.521999-.296001-.709999zm-39.842999-27.115002l-.673-.672998c0 0-.000999 0-\
.000999-.001001l-1.537001-1.536999 0 0-.768999-.769001 0 0-1.538-1.538c0 0 0-\
.000999-.001-.000999l-.422999-.423-4.190001-4.191 3.092-3.092999.001-\
.001.441999-.441999 1.414001-1.414001 3.844001 3.844c0 0 0 0 0 \
.001l.768999.769c0 0 0 0 .000999.000999l1.537001 1.537 0 0 .768999.769001 0 0 \
1.537001 1.536999 0 .001001.673.673-4.947001 4.950998zM30.167 \
11.769c.198.574.362 1.168.486 1.765.098.471999.514.796.978001.796.066999 0 .136-\
.007.203999-.021.541-.112.889-.642.776001-1.183-.140999-.68-.327999-1.356-\
.553001-2.011001-.180998-.521-.748999-.797999-1.271999-.618999-.521999.182-\
.799999.750999-.618999 1.273zM30.940001 17.181c-.028.610001-.096001 1.223-\
.200001 1.821001-.096001.543999.269001 1.061998.812 \
1.157.059.01.115999.014999.174.014999.476999 0 .898001-.341999.983-\
.827999.118999-.682001.195999-1.379002.229-2.073.025002-.552-.401001-1.02-\
.952999-1.045-.549-.015001-1.019001.400999-1.045.952999zM28.540001 \
8.482c.191999.29.509998.446.832998.446.190001 0 .382-.054001.553001-\
.167001.459999-.306.584-.926.278999-1.386-.382999-.576-.806999-1.134-1.261-\
1.659-.361-.418-.993-.465-1.410999-.103-.417002.361-.463001.993-.103001 \
1.41.4.462.772999.953 1.110001 1.459001zM17.906 2.071c.605999.061 1.215.16 \
1.808001.296.074999.018.15.025.223999.025.455999 0 .868-.313.974001-.776.123999-\
.539-.213001-1.075-.751001-1.198-.674999-.155-1.366999-.268-2.056999-.337-\
.551001-.06-1.039.347-1.094.896-.054001.55.346001 1.04.896 1.094zM12.186 \
2.596c.091001 0 .183001-.013.274-.039.585999-.167 1.188-.298 1.79-.391.546-\
.083.921-.593.837-1.139-.083-.546-.592999-.922-1.14-.838-.684999.105-1.37.254-\
2.035999.445-.531.151-.839001.705-.687 1.236.126.44.526.726.962.726zM6.974 \
5.238c.214 0 .43-.068.612-.209.48-.373.991-.719 1.516-1.028.476-.28.634-\
.893.354-1.369-.281-.476-.894-.635-1.37-.354-.597001.352-1.178.746-1.726 1.17-\
.437.338-.516.967-.178 1.403.198.254.493.387.792.387zM23.143 3.631c.540001.281 \
1.066999.6 1.568001.947.174.121.372999.178.569.178.316 0 .628-.15.821999-\
.43.315001-.454.202002-1.077-.251999-1.392-.57-.396-1.17-.758-1.784-1.077-.49-\
.255-1.094-.065-1.349001.425-.254.49-.063999 1.094.426001 1.349zM13.454 \
30.688999c-.596001-.125-1.189-.290998-1.765-.49-.521-.181999-1.091001.095001-\
1.272.616001-.182.521999.094 1.091999.616 1.273001.655.228001 1.331.416 \
2.009.558998.069.014999.139.021.207.021.463 0 .878-.322998.978001-.793999.113-\
.541-.233-1.071001-.773-1.185001zM.985 15.107c.052.007999.103.012.153.012.485 0 \
.911-.354.987-.848001.093-.602.226-1.204.394-1.789.152-.531-.154-1.084001-.685-\
1.237-.53-.156-1.085.154-1.237.685-.192.665999-.343 1.351-.448 2.037-\
.084.545.29 1.056.836 1.14zM18.921 30.791c-.601.102999-1.213999.168999-\
1.820999.195-.552.024-.98.490999-.956001 \
1.042.023001.536999.466002.957001.999001.957001.015001 0 .030001 0 .044001-\
.000999.691999-.030003 1.389999-.105 2.073-.223.544001-.093002.91-.610001.816-\
1.155001-.094-.544001-.612-.913-1.155001-.815001zM6.963 27.459999c-.418-.362-\
1.049-.316999-1.411.1-.361.417-.316 1.049.101 1.411001.524.455 1.082.879 1.657 \
1.262999.17.114.363.168001.554.168001.323 0 .641-.156.833-.445.307-.459002.182-\
1.081001-.276999-1.387001-.507-.337-.997-.709999-1.457-1.110001zM3.418 6.387c-\
.425.547-.819 1.126-1.172 1.722-.281.474999-.124 1.087999.352 \
1.37.16.095.335.14.508.14.342 0 .675-.175.862-.491.31-.524.656-1.033 1.03-\
1.514.339-.436.26-1.064-.176-1.403-.437-.339-1.065-.261-1.404.176zM2.318 \
19.736c-.135-.593-.233-1.202-.292-1.808001-.054-.549-.542-.955-1.093-.897999-\
.55.053999-.952.542-.898 1.091999.067.690001.179 1.382.333 \
2.057001.105.463999.518.778.974.778.073 0 .148-.008001.223-.025002.538-.122.875-\
.657999.753-1.195999zM3.576 23.167c-.254-.49-.858-.681-1.348-.427-.491.254-\
.682.858-.428 1.348.319.616001.681 1.217001 1.075 \
1.787001.194.281.506.431.823.431.196 0 .395-.058001.568-.177999.454-.314001.567-\
.937.253-1.391001-.345-.500999-.663-1.028999-.943-\
1.57z'/%3E%3C/g%3E%3C/svg%3E");
	background-size:57% auto;
}

.icon-select_tool{
background-image: url("data:image/svg+xml,%3Csvg width='26' height='20' \
xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='none' d='M-1 -1H581V401H-\
1z'/%3E%3Cg%3E%3Cpath fill='%23aaa' d='M0 7H1V13H0zM25 7H26V13H25zM7 \
0H12V1H7zM7 19H12V20H7zM14 0H19V1H14zM14 19H19V20H14zM0 0L0 5 1 5 1 1 5 1 5 \
0zM1 15L0 15 0 20 5 20 5 19 1 19zM25 19L21 19 21 20 26 20 26 15 25 15zM21 0L21 \
1 25 1 25 5 26 5 26 0z'/%3E%3C/g%3E%3C/svg%3E");
	background-size:57% auto;
}

.icon-lasso_tool{
background-image: url("data:image/svg+xml,%3Csvg width='128' height='128' \
xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='none' d='M-1 -1H581V401H-\
1z'/%3E%3Cg%3E%3Cpath fill='%23aaa' d='m107.913002,13.282c-12.234001,-7.841 -\
28.242004,-11.908 -45.096001,-11.452c-22.093002,0.618 -42.883001,9.077 -\
54.174002,22.122999c-6.507,7.515001 -9.436,15.973999 -8.46,24.563c1.692,\
14.803001 15.911,23.164001 28.47,30.515999c0.325001,0.195 0.651001,0.390999 \
0.976,0.585999c-1.886999,1.952003 -3.058001,4.327003 -3.285999,6.962006c-0.618,\
7.971001 7.775999,14.932999 19.099001,15.810997c0.780998,0.065002 1.562,0.097 \
2.342999,0.097c0.748001,0 1.497002,-0.032997 2.212002,-0.097c-0.163002,\
9.889999 -7.483002,19.748001 -7.581001,19.877998l5.173,3.936005c0.521,-0.716003 \
9.436001,-12.688004 8.98,-25.181c1.593998,-0.553001 3.057999,-1.269005 4.327,-\
2.115005c2.993,-2.016998 5.043003,-4.75 5.660999,-7.905998c16.365997,-0.651001 \
31.659004,-5.530998 43.111,-13.859001c12.136002,-8.783997 18.643997,-20.300999 \
18.318001,-32.467999c-0.355003,-12.167 -7.481003,-23.293999 -20.072998,-\
31.393999zm-61.983002,82.634001c-8.069,-0.651001 -13.373001,-5.173004 -\
13.080002,-8.816002c0.098003,-1.399002 1.041,-2.797997 2.603001,-\
3.969002c4.197002,2.603004 7.972,5.270004 10.639999,8.198006c1.302002,1.463997 \
2.245003,2.992996 2.863003,4.619995c-0.976002,0.065002 -1.984001,0.032005 -\
3.026001,-0.032997zm9.468998,-1.463997c-0.877998,-2.603004 -2.342999,-5.140007 -\
4.489998,-7.515007c-2.146999,-2.341995 -4.75,-4.489998 -7.646,-\
6.506996c0.651001,-0.065002 1.334,-0.098 2.049999,-0.098c0.618,0 1.236,0.032997 \
1.855,0.098c8.069,0.617996 13.373001,5.139999 13.080002,8.816002c-0.164001,\
1.985001 -1.954002,3.936996 -4.849003,5.206001zm50.464001,-22.578003c-10.542,\
7.644997 -24.727997,12.135002 -40.019997,12.687996c-2.408001,-5.627998 -\
9.403004,-9.922997 -18.188004,-10.637993c-4.424999,-0.358002 -8.524998,\
0.292999 -11.940998,1.691994c-1.236,-0.715996 -2.505001,-1.463997 -3.774,-\
2.211998c-11.779001,-6.898003 -23.948,-14.055 -25.282001,-25.637001c-0.781,-\
6.702 1.627,-13.468998 6.898,-19.552998c10.152,-11.679001 29.088001,-19.324 \
49.456001,-19.877001c15.553001,-0.423 30.259003,3.253 41.387001,\
10.410999c10.737,6.897001 16.789001,16.169001 17.082001,26.124002c0.259995,\
9.921997 -5.271004,19.518997 -15.618004,27.001999z'/%3E%3C/g%3E%3C/svg%3E");
	background-size:57% auto;
}

.icon-brush_tool{
background-image: url("data:image/svg+xml,%3Csvg xmlns='http:\
//www.w3.org/2000/svg' x='0px' y='0px' viewBox='0 0 24 24'%3E%3Cpath \
fill='%23AAA' d='M23 0C16.6 3.5 10 9 6.6 15.4l2 2C15 14 20.5 7.4 24 1L23 0zM1.9 \
17.7C.7 18.9 0 22 0 24c2 0 5.1-.7 6.3-1.9 1.2-1.2 1.2-3.1 0-4.3S3.1 16.5 1.9 \
17.7C1.9 17.7 1.9 17.7 1.9 17.7z'/%3E%3C/svg%3E");
	background-size:54% auto;
}

.icon-eraser_tool{
background-image: url("data:image/svg+xml,%3Csvg width='128' height='128' \
xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='none' d='M-1 -1H581V401H-\
1z'/%3E%3Cg%3E%3Cpath fill='%23aaa' d='m97.300003,11.3c-2.800003,-2.8 -6.5,-\
4.3 -10.5,-4.3s-7.700005,1.5 -10.5,4.3l-72.000003,71.500003c-2.8,2.799995 -4.3,\
6.5 -4.3,10.399994s1.5,7.700005 4.3,10.400002l16.900001,16.800003c0.4,0.400002 \
0.9,0.599998 1.4,0.599998l70.499998,0c1.099998,0 2,-0.900002 2,-2s-0.900002,-2 -\
2,-2l-28.400002,0l59,-58.599998c5.800003,-5.800003 5.800003,-15.100002 0,-\
20.900002l-26.399994,-26.2zm-38.300003,105.7l-35.6,0l-16.2,-16.199997c-2,-2 -\
3.2,-4.700005 -3.2,-7.600006s1.1,-5.599998 3.2,-7.599998l35.3,-\
35.099998l41.699997,41.5l-25.199997,25z'/%3E%3C/g%3E%3C/svg%3E");
	background-size:54% auto;
}

.icon-bucket_tool{
background-image: url("data:image/svg+xml,%3Csvg xmlns='http:\
//www.w3.org/2000/svg' width='60' height='60'%3E%3Cpath fill='none' d='M-1 -\
1H581V401H-1z'/%3E%3Cg transform='translate(-15.749638,-15.254999)'%3E%3Cpath \
fill='%23aaa' d='M41.75 74.294998c1.529999 0 2.966-.594002 4.037998-\
1.673996L64.681 53.731998 66.348999 55.402 68.752998 52.998001 48.459999 \
32.707001V16.215h-3.399998v13.094l-3.384003-3.386999v0L39.477001 23.723l-\
2.403999 2.404001 2.198997 2.198999-22.934 22.931999 21.367002 \
21.363003c1.075996 1.079994 2.511997 1.673996 4.044998 1.673996zm6.799999-\
28.116997c0 .981998-.802998 1.786999-1.791 1.786999-.983997 0-1.785-.805-1.785-\
1.786999 0-.986.801003-1.785 1.785-1.785.988003 0 1.791.798 1.791 \
1.785zM75.161278 65.985931c-.0011-2.352783-3.369705-6.262218-4.045372-7.021622l-\
.728432-.819054-.728432.819054c-.676811.759403-4.04995 4.669418-4.051094 \
7.021622 0 2.631538 2.143982 4.773232 4.778954 4.773232 2.63382 0 4.774376-\
2.142273 4.774376-4.773232z'/%3E%3C/g%3E%3C/svg%3E");
	background-size:60% auto;
}

.icon-cp_dropper_tool{
background-image: url("data:image/svg+xml,%3Csvg width='16' height='16' \
xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='none' d='M-1 -1H17V17H-\
1z'/%3E%3Cg%3E%3Cpath fill='%23aaa' d='m15,1c-1.547,-1.547 -3.297,-0.703 -4.463,\
0.463l-2.623,2.623c-0.487,-0.119 -0.953,-0.047 -1.256,0.256c-0.447,0.447 -0.4,\
1.248 0.049,1.951l-4.342,4.342c-0.389,0.389 -0.707,1.157 -0.707,1.707s-0.318,\
1.318 -0.707,1.707l-0.586,0.586c-0.389,0.389 -0.482,0.932 -0.207,1.207c0.107,\
0.106 0.254,0.158 0.417,0.158c0.257,0 0.552,-0.127 0.79,-0.365l0.586,-\
0.586c0.389,-0.389 1.157,-0.707 1.707,-0.707s1.318,-0.318 1.707,-0.707l4.342,-\
4.342c0.703,0.448999 1.504001,0.495999 1.951,0.049c0.303,-0.303 0.375,-0.769 \
0.256,-1.256l2.623,-2.623001c1.166,-1.166 2.010001,-2.916 0.463,-4.463zm-10.342,\
11.928c-0.201,0.200999 -0.715,0.414 -1,0.414c-0.402,0 -0.851,0.102 -1.272,\
0.272c0.171,-0.422 0.272,-0.87 0.272,-1.272c0,-0.285 0.213,-0.799 0.414,-\
1l4.293,-4.293l1.586,1.586l-4.293,4.293z'/%3E%3C/g%3E%3C/svg%3E");
	background-size:45% auto;
}

.icon-color_palette_tool{
background-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' %3F%3E%3Csvg \
width='47px' height='52px' viewBox='0 0 47 52'  xmlns='http://www.w3.org/2000/svg'\
 xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg%3E%3Cpath d='M40.432,13.098c-\
5.528-2.646-10.562-1.053-14.606,0.227c-3.601,1.14-5.704,1.703-7.025,0.075 c-0.40\
2-0.537-0.091-1.572,0.237-2.668c0.482-1.608,1.083-3.609-0.242-5.337c-1.709-2.243\
-5.522-1.924-8.023-0.212 C4.653,9.491,1,16.526,1,24c0,12.682,10.318,23,23,23c10.\
247,0,19.348-6.878,22.143-16.758 C46.465,28.94,49.051,17.407,40.432,13.098z M34,\
28c-2.209,0-4-1.791-4-4s1.791-4,4-4c2.209,0,4,1.791,4,4S36.209,28,34,28z' fill='\
%23464646'/%3E%3Ccircle cx='10' cy='24' fill='%23E86C60' r='3'/%3E%3Ccircle cx='\
15' cy='34' fill='%23EFD358' r='3'/%3E%3Ccircle cx='26' cy='38' fill='%2343A6DD'\
 r='3'/%3E%3C/g%3E%3C/svg%3E");
	background-size: 74% auto;
}

.icon-blend_assist_tool{
background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' xmlns=\
'http://www.w3.org/2000/svg'%3E%3Cpath fill='%23aaaaaa' id='svg_2' d='m50.000001\
,82.800001c-18.1,0 -32.8,-14.7 -32.8,-32.8s14.7,-32.8 32.8,-32.8c18.1,0 32.8,14.\
7 32.8,32.8s-14.7,32.8 -32.8,32.8zm0,-61.2c-15.7,0 -28.4,12.7 -28.4,28.4s12.7,28\
.4 28.4,28.4c15.7,0 28.4,-12.7 28.4,-28.4s-12.8,-28.4 -28.4,-28.4z'/%3E%3Cpath f\
ill='%235d8fa8' id='svg_3' transform='rotate(40 50 50)' d='m44.000001,27.800001c8.3,-0.9 17,5.6 15.3,13.2c-0.\
8,3.5 -4.3,6.3 -8,8.9c-3.8,2.6 -8,5.8 -8,11.2c0,7.6 8,12.5 16.2,10.1c8.5,-3.5 14\
.4,-11.7 14.4,-21.3c0,-12.7 -10.5,-23 -23.3,-23c-2.3,0 -5.5,0.4 -6.6,0.9z'/%3E%3\
C/svg%3E");
	background-size: 82% auto;
}

.icon-hand_tool{
background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 100 100' xmlns='ht\
tp://www.w3.org/2000/svg'%3E%3Cg fill='%23aaaaaa' fill-rule='evenodd' class='fil\
l-000000'%3E%3Cpath d='M27.135 29.673c.452 0 .906-.154 1.276-.469a1.95 1.95 0 0 \
0 .219-2.76 13.5 13.5 0 0 1-3.258-8.788c0-7.47 6.108-13.547 13.617-13.547 7.509 \
0 13.617 6.077 13.617 13.547a13.5 13.5 0 0 1-3.258 8.789 1.95 1.95 0 0 0 .218 2.\
759 1.974 1.974 0 0 0 2.774-.217 17.41 17.41 0 0 0 4.086-9.378h13.992l-2.222 1.7\
94a1.95 1.95 0 0 0-.287 2.752c.388.477.956.724 1.528.724.436 0 .874-.143 1.239-.\
438l6.527-5.27.005-.005c.053-.043.103-.089.152-.137l.038-.043c.034-.036.068-.072\
.098-.11l.044-.059c.027-.036.053-.072.077-.11a1.922 1.922 0 0 0 .188-.377l.022-.\
057a1.89 1.89 0 0 0 .042-.146l.015-.056c.01-.051.019-.104.026-.157l.008-.05a1.93\
 1.93 0 0 0 0-.424l-.008-.05a2.072 2.072 0 0 0-.026-.158l-.015-.056a1.92 1.92 0 \
0 0-.042-.146l-.021-.058a1.845 1.845 0 0 0-.15-.315l-.039-.061a1.87 1.87 0 0 0-.\
077-.11c-.014-.02-.028-.04-.044-.059a1.872 1.872 0 0 0-.098-.11c-.013-.014-.025-\
.03-.038-.043a1.972 1.972 0 0 0-.152-.137l-.005-.005-6.527-5.27a1.974 1.974 0 0 \
0-2.767.286 1.95 1.95 0 0 0 .287 2.752l2.222 1.795H56.429c-.983-8.708-8.428-15.5\
-17.44-15.5-9.678 0-17.552 7.833-17.552 17.46 0 4.152 1.492 8.177 4.201 11.332.3\
9.453.941.686 1.497.686'%3E%3C/path%3E%3Cpath d='M72.306 49.245c-1.339 0-2.61.36\
3-3.719 1.006v-.304c0-4.397-3.433-7.974-7.654-7.974a7.37 7.37 0 0 0-3.719 1.007v\
-.316c0-4.396-3.433-7.973-7.654-7.973a7.417 7.417 0 0 0-3.713.99V16.459c0-3.828-\
3.12-6.931-6.968-6.931s-6.967 3.103-6.967 6.93v50.764c0 .804-.623 1.504-1.43 1.5\
29a1.472 1.472 0 0 1-1.521-1.468v-11.41c0-2.141-2.556-3.297-4.152-1.86l-.042.037\
C21.604 56.925 20 61.576 20 67.873c0 9.971 6.632 18.624 7.282 19.447.734 1.033 9\
.355 12.677 24.282 12.677 8.387 0 15.155-2.86 20.115-8.5 3.584-4.075 5.864-9.455\
 6.42-15.15l1.852-18.94c.006-.058.01-.117.01-.176.006-4.402-3.43-7.986-7.655-7.9\
86'%3E%3C/path%3E%3C/g%3E%3C/svg%3E");
	background-size: 55% auto;
}




.icon-new_layer_btn{
background-image: url("data:image/svg+xml,%3Csvg width='16' height='16' \
xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='none' d='M-1 -1H581V401H-\
1z'/%3E%3Cg%3E%3Cpath fill='%23aaa' d='m3.00195,2l0,9l-0.00195,0.001953l0.00195,\
0.001953l2.99414,2.990295l0,0.003906l7.00586,0l0,-11.998108l-0.5,0c-3.00006,0 -\
6.00013,0.00061 -9,0l-0.5,0zm1,1c2.66678,0.000366 5.33339,0.000122 8,0l0,\
9.998108l-5.00586,0l0.00391,-2.994202l-2.99805,0l0,-7.003906zm0.41407,\
8.003906l1.58398,0l-0.00195,1.578186l-1.58203,-\
1.578186z'/%3E%3C/g%3E%3C/svg%3E");
}

.icon-add_layer_mask_btn{
background-image: url("data:image/svg+xml,%3Csvg width='24' \
height='24' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath \
fill='none' d='M-1 -1H581V401H-1z'/%3E%3Cg%3E%3Cpath fill='%23aaa' d='m19,5l-14,\
0a2,2 0 0 0 -2,2l0,10a2,2 0 0 0 2,2l14,0a2,2 0 0 0 2,-2l0,-10a2,2 0 0 0 -2,-2zm-\
7,11a4,4 0 1 1 4,-4a4,4 0 0 1 -4,4z'/%3E%3C/g%3E%3C/svg%3E");
}

.icon-trash_bin{
background-image: url("data:image/svg+xml,%3Csvg xmlns='http:\
//www.w3.org/2000/svg' x='0px' y='0px' viewBox='0 0 1000 1000'%3E%3Cg \
fill='%23AAA'%3E%3Cpath d='M812.5 208.3H666.7v-41.7c-.1-46-37.3-83.3-83.3-\
83.3H416.7c-46 .1-83.3 37.3-83.3 83.3v41.7H187.5c-11.5 0-20.8 9.3-20.8 20.8 0 0 \
0 0 0 0v41.7c0 11.5 9.3 20.8 20.8 20.8 0 0 0 0 0 0h625c11.5 0 20.8-9.3 20.8-\
20.8 0 0 0 0 0 0v-41.7C833.3 217.7 824 208.3 812.5 208.3 812.5 208.3 812.5 \
208.3 812.5 208.3zM625 208.3H375v-41.7c0-23 18.7-41.6 41.7-41.7h166.7c23 0 41.6 \
18.7 41.7 41.7V208.3zM208.3 833.3c.1 46 37.3 83.3 83.3 83.3h416.7c46-.1 83.3-\
37.3 83.3-83.3v-500H208.3V833.3zM604.2 479.2c0-11.5 9.3-20.8 20.8-20.8s20.8 9.3 \
20.8 20.8v291.7c0 11.5-9.3 20.8-20.8 20.8s-20.8-9.3-20.8-20.8V479.2zM479.2 \
479.2c0-11.5 9.3-20.8 20.8-20.8 11.5 0 20.8 9.3 20.8 20.8v291.7c0 11.5-9.3 20.8-\
20.8 20.8-11.5 0-20.8-9.3-20.8-20.8V479.2zM354.2 479.2c0-11.5 9.3-20.8 20.8-\
20.8s20.8 9.3 20.8 20.8v291.7c0 11.5-9.3 20.8-20.8 20.8s-20.8-9.3-20.8-\
20.8V479.2z'/%3E%3C/g%3E%3C/svg%3E");
}


/* ================== icons END */

/* ================== Other (like global screens etc) */

.global-screen{
	display:none;
	position:absolute;
	top:0;
	left:0;
	width:100%;
	height:100%;
	outline:none;
	z-index:1006;
}

.screen-lock{
	display:none;
	position:absolute;
	top:0;
	left:0;
	width:100%;
	height:100%;
	outline:none;
	z-index:1004;
	transition: background 0.9s;
}

.screen-lock:active{
	background-color:rgba(80,80,80,0.4);
	transition: background 0s;
}


.hidden-toggler{
	display:block;
	position:absolute;
	left:0;
	top:0;
	appearance:none;
	-moz-appearance:none;
	-webkit-appearance:none;
	width:1px;
	height:1px;
	visibility:hidden;
	opacity:0;
}

.overflow-hidden{
	overflow:hidden;
}

.bg-checkerboard-small{
	background-image: /* tint image */
	linear-gradient(to right, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.8)),
	/* checkered effect */
    linear-gradient(to right, black 50%, white 50%),
    linear-gradient(to bottom, black 50%, white 50%);
    background-blend-mode: normal, difference, normal;
    background-size: 0.5rem 0.5rem;
}

.bg-checkerboard-large{
	background-image: /* tint image */
	linear-gradient(to right, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.8)),
	/* checkered effect */
    linear-gradient(to right, black 50%, white 50%),
    linear-gradient(to bottom, black 50%, white 50%);
    background-blend-mode: normal, difference, normal;
    background-size: 1rem 1rem;
}

.bg-white{
	background-color:white;
}

.bg-black{
	background-color:black;
}

.filter-grayscale-100{
	-webkit-filter: grayscale(100%);
	filter: grayscale(100%);
}

.mirror-content{
	-webkit-transform: scaleX(-1);
	transform: scaleX(-1);
}

.general-fade-transition{
	transition: opacity 0.7s ease;
}


/* ================== Other END */

/* ================== Technical Support Elements */

#technical_support_elements{
	display:none;
	position:absolute;
}

#file_loading_screen{
	display:none;
	background-color:rgb(40,40,40);
	z-index: 1002;
}
#file_loading_screen_text{
	top:50%;
	transform:translateY(-50%);
}

#canvas_loading_screen{
	display:block;
	background-color:rgb(40,40,40);
	transition: opacity 0.7s;
	z-index: 1002;
}
#canvas_loading_screen_text{
	top:50%;
	transform:translateY(-50%);
}

/* splash screen */
#splash_screen{
	position:fixed;
	width:100%;
	height:100%;
	z-index: 1011;
	transition: opacity 0.7s;
}

#splash_screen_backdrop{
	position:absolute;
	left:0;
	right:0;
	top:0;
	bottom:0;
	background: rgba(40,40,40,0.6);
}

#splash_badge{
	position:absolute;
	width: 18rem;

	bottom: 2.6rem;
	left: calc( (100% - 18rem + 2.2rem - 13rem - 1.2rem)/2 );
	background-color: rgb(40,40,40);
	border-radius: 0.8rem;
	border:1px solid rgb(60,60,60);
	border-bottom: 1px solid rgb(65, 42, 94);
	border-left: 1px solid rgb(65, 42, 94);
	box-sizing: border-box;
	padding: 0.8rem;
	box-shadow:  0 5px 15px 2px rgba(0,0,0, .5);
	color: rgb(220,220,220);
	
	text-align:center;
}
#splash_badge::before{
	content:'';
	position:absolute;
	width:100%;
	height:100%;
	border-radius: 0.8rem;
	top:0;
	left:0;
	background: linear-gradient(10deg, rgba(150, 82, 235, 0.12) 0, rgba(0,0,0,0) 22%);
}
#splash_badge_program_name{
	font-size: 1.2rem;
	color: rgb(220,220,220);
}
#splash_badge_info{

	position:relative;
	text-align:right;
	color: #b8af8c;
}
/*
#splash_badge_info span{
	display:inline-block;
	color:#7d7968;
	float:left;
}
*/

/* splash screen end */

/* ================== Technical Support Elements END */

</style>
</head>
<body>


<script>

function sizeUICore(){
	const d_t = 2560;//dimension threshold
	var w = Math.max(
    document.documentElement["clientWidth"],
    document.body["scrollWidth"],
    document.documentElement["scrollWidth"],
    document.body["offsetWidth"],
    document.documentElement["offsetWidth"]
	);
	var h = Math.max(
    document.documentElement["clientHeight"],
    document.body["scrollHeight"],
    document.documentElement["scrollHeight"],
    document.body["offsetHeight"],
    document.documentElement["offsetHeight"]
	);
	
	if((w/h)*10 - 18 > 2.5){
	//wide screen horizontal
		w = Math.floor(h * 1.8);
	}else{
	//vertical orientation
		h = Math.min(h, w * 1.8);
	}

	
	w = Math.min(w,d_t);
	var mu = w/10/10;//1% of --core-w measurement unit 
	
	h = Math.min(h,d_t);
	var vmu = h/10/10;//1% of --core-h vertical measurement unit
	
	document.documentElement.style.setProperty("--core-w",w+"px");
	document.documentElement.style.setProperty("--core-h",h+"px");
	//possible UI scaling through --mu 
	//document.documentElement.style.setProperty("--mu",mu*0.7+"px");
	document.documentElement.style.setProperty("--mu",mu+"px");
	
	document.documentElement.style.setProperty("--vmu",vmu+"px");
	
	document.documentElement.style.fontSize = mu+"px";
	
}

sizeUICore();

</script>

<div id="technical_support_elements">
<!-- can put html elements here that will be hidden but needed to support features -->
<!--<a id="ts_download_btn"></a>--> 
<!--<input id="ts_brush_preset_import" type="file" autocomplete="off">-->

<!-- manual page pool -->
<div id="manual_page_pool">

<!-- sample manual page 
<div class="manual-page" data-item_name="Sample Page" data-item_id="sample_p_0" data-item_type="page">
<section>
<h1>Page name heading</h1>
<span>Some instructions information.</span>
<span>Anything goes within page container .manual-page</span>
<span>Page containers will be parsed and corresponding links will be generated</span>
<span>data-item-type can be group/page/category/spacer</span>
<span>group means it will nest pages or other groups</span>
<span>category is a spacer with its name as heading for the links below</span>
<span>data-item-id should be unique</span>
<span>note: currently groups aren't supported, because are not needed
check manual_keeper.parseUIManualPagePool notes for support update
data-item-id may become unique only to containing group</span>
<span>data-item-name is (for example) page name that appears as a link</span>
</section>
</div> sample manual page end -->

<!-- sample manual index category
<span data-item_type="category">Tools</span>
 sample manual index category end -->

<!-- sample manual page
<div class="manual-page" data-item_name="Sample Page 2" data-item_id="sample_p_1" data-item_type="page">
<span>Some instructions information.</span>
sample 2
</div> sample manual page end -->

<!-- sample manual index spacer
<span data-item_type="spacer"></span>
sample manual index spacer end -->

<!-- sample manual page
<div class="manual-page" data-item_name="Sample Page 3" data-item_id="sample_p_2" data-item_type="page">
<span>Some instructions information.</span>
sample 3
</div> sample manual page end -->

<div class="manual-page" data-item_name="Welcome" data-item_id="welcome" data-item_type="page">
<section>
<h1>Welcome</h1>
<p class="text-align-center">A few things worth mentioning</p>
<p><strong>Spree</strong> - allows to retouch laid colors and more. Toggle by pressing <span class="hkl-item-bind-keytag">X</span> on keyboard.
Instead of drawing - brush will be erasing recently laid color or undoing eraser.</p>
<p class="manual-page-clickable" onclick="showUIElement(UI.hk_list);"><strong>Hotkeys</strong> - click here to show all hotkeys</p>
<p title="hovering"><strong>Tooltips</strong> - hover over UI elements to view available descriptions.</p>
<p><strong>Important notice</strong>: all settings (including presets) are stored in browser's cache.
Use Import / Export features to migrate configuration.</p>
<p>This menu can be accessed in Help->Manual</p>
</section>
</div>

<span data-item_type="category">General</span>

<div class="manual-page" data-item_name="File" data-item_id="file" data-item_type="page">
<section>
<h1>File</h1>
<p>
<strong>Open file</strong>
supports the following format types:<br>
<strong>Image: </strong>png, jpg/jpeg, gif, bmp, webp, webm, svg <br>
<i>note: some image types like svg will be rasterized</i><br>
<strong>Project: </strong> LBC (.lbc)<br><i>(stands for Light Brush Canvas. lbc is a Light Brush project file format)</i>
</p>
<p>
<strong>Save as</strong>
supports saving in the following format types:<br>
<strong>Image: </strong> png, jpg <br>
when saving as jpg, use slider for jpeg quality (0 to 10)<br>
<strong>Project: </strong> lbc <br>
</p>
</section>
</div>

<div class="manual-page" data-item_name="Import / Export / Clipboard" data-item_id="import_export" data-item_type="page">
<section>
<h1>Copy / Cut / Paste / Import / Export</h1>
<p>
<strong>Copy / Cut </strong> image or selected content:<br>
to copy press 
<span class="hkl-item-bind-keytag">Ctrl</span>+<span class="hkl-item-bind-keytag">C</span>
key combination on keyboard<br>
to cut press 
<span class="hkl-item-bind-keytag">Ctrl</span>+<span class="hkl-item-bind-keytag">X</span>
key combination on keyboard<br><br>
note: ability to copy / cut content outside the program depends on browser engine<br><br>
note: copying image with transparency outside the program, also depends on your current OS clipboard functionality
</p>
<p>
<strong>Paste</strong> - to paste image content onto a layer or a mask press
<span class="hkl-item-bind-keytag">Ctrl</span>+<span class="hkl-item-bind-keytag">V</span>
</p>
<p>
<strong>Import Image</strong> - you can import an image that is saved on your computer.<br>
File->Import Image and choose the image file.<br>
This will import the image onto an active layer in your project<br><br>
supported image formats for importing:<br> png, jpg/jpeg, gif, bmp, webp, webm, svg
</p>
<p>
<strong>Export Content</strong><br>
File->Export Content - this will export selected content of a layer or a mask as png.
Will export whole layer or mask if no selection is active.<br>
</p>
</section>
</div>

<div class="manual-page" data-item_name="Selection" data-item_id="selection" data-item_type="page">
<section>
<h1>Selection</h1>
<p>
<strong>Selection</strong> is a feature that allows to isolate 
a region for a variety of uses. Applicable to both, layers and masks.<br>
e.g. copy / cut, color fill / draw &amp; erase within the selection etc.
</p><p>
<strong>Making and Modifying selections</strong><br>
<strong>Select menu</strong> - over on the top panel in general menu 
there is a Select menu drop-down. It contains various options in regard to selection control.<br>
<strong>Area Select Tool</strong> allows to make a rectangular selection.<br>
<i>More on Area Select Tool <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('area_select_tool')">here</span></i><br>
<strong>Lasso Tool</strong> is a freehand selection making tool.<br>
<i>More on Lasso Tool <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('lasso_tool')">here</span></i><br>
<strong>Auto Select Tool</strong> allows to automatically select "similar" pixels.
The criteria for pixel similarity can be set in Tool Options menu.<br>
<i>More on Auto Select Tool <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('auto_select_tool')">here</span></i><br>
<br>
Use modifier keys <span class="hkl-item-bind-keytag">Ctrl</span> to Add to current selection
and <span class="hkl-item-bind-keytag">Alt</span> to Subtract from current selection when using selection tools.<br>
<br>
<strong>Additionally</strong> you may want to use Move Tool transformations to transform selections.<br>
<i>More on Move Tool <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('move_tool')">here</span></i><br>
<br>
<strong>Spree to selection</strong> - turn contents of spree layer into a selection by
pressing <span class="hkl-item-bind-keytag">Ctrl</span>+<span class="hkl-item-bind-keytag">B</span><br>
note: content transparency will be transponded to a resulting selection.<br>
<br>
<strong>From layer</strong> - contents of layer can be used for creating a selection.
Content transparency will be transponded to a resulting selection.
Mask presence, and layer opacity will be taken into account, when creating a selection from layer view.<br>
Usage: select a layer, then:<br> 
Select->From Layer + (if you would like to add to selection), or<br> 
Select->From Layer - (if you would like to subtract from active selection)<br>
Alternatively <span class="hkl-item-bind-keytag">Ctrl</span>+Click on a layer in layers tab, to create a new selection using layer.<br>
note: in this case layer does not have to be active/selected, and a layer can be hidden.<br>
<br>
<strong>Select content</strong> is a part of general Select menu drop-down.<br>
Select->Select Content. <br>
Alternatively press <span class="hkl-item-bind-keytag">Ctrl</span>+<span class="hkl-item-bind-keytag">A</span><br>
This will make an opaque selection of all content present on the selected layers (multiple layers can be selected).<br>
note: mask content can be selected same way, but only one mask can be selected at a time.<br>
<strong>Deselect / Toggle Selection</strong><br>
Select->Deselect to clear selection<br>
Press <span class="hkl-item-bind-keytag">Ctrl</span>+<span class="hkl-item-bind-keytag">D</span>
to toggle selection on and off.<br>
note: this will not bring back a selection cleared by deselect method above,
only the one that has been initially toggled.
<br>
<strong>Moving selection</strong> - selection can be moved by click &amp; dragging
on selected region. One of the selection tools must be in use.<br>
Additionally, can use arrow keys on keyboard to nudge.<br>
note: Area Select Tool has a special embedded feature -
selection will not move past canvas boundary. This is especially useful for cropping.<br>
</p>
</section>
</div>

<div class="manual-page" data-item_name="Masks" data-item_id="masks" data-item_type="page">
<section>
<h1>Masks</h1>
<p>
<strong>Masks</strong> are used to hide parts of the layer without altering layer's contents.<br>
<br>
There are two types of masks available: <br>
<strong>Layer Mask</strong> - applies to a single layer<br>
<strong>Clipping Mask</strong> - a layer becomes a mask for a number of layers clipped onto it<br>
<br>(!) Both mask types use Alpha channel, meaning that masks use transparency of their contents to hide or show layers' contents.
</p><p>
<strong>Controls</strong><br>
Use dedicated buttons and layers options drop-down.<br>
A few extra controls include:<br>
<strong>Disable / Enable Layer Mask </strong> - <span class="hkl-item-bind-keytag">Shift</span>+Click on mask<br>
<strong>Move Layer Mask</strong> to another layer - Click &amp; Drag mask to a destination layer<br>
<strong>Copy Layer Mask</strong> to another layer - hold <span class="hkl-item-bind-keytag">Ctrl</span>+Click &amp; Drag mask to a destination layer.<br>
<strong>Clear Layer Mask</strong> - clicking on dedicated clear button multiple times will alternate between clear and fill.
</p>
</section>
</div>

<div class="manual-page" data-item_name="Spree" data-item_id="spree" data-item_type="page">
<section>
<h1>Spree</h1>
<p>
<strong>Spree</strong> is a transparent layer to which most things you draw(or erase) goes first,
before being solidified into a selected layer. This means, by using spree controls,
you can retouch things you put unto a layer, beyond just undo.
<br><br>Spree feature has two modes: draw and erase.
<br>Toggle spree mode by pressing <span class="hkl-item-bind-keytag">X</span> key 
<br>or clicking Spree indicator on the left toolbar.
<br><br>e.g. when using Brush Tool you can draw in draw mode, and then erase parts of what you just drew
in erase mode. Leaving layer's previous contents untouched.
<br>Similar is available for Eraser Tool too, spree erase mode will be undoing erasing, bringing original content of a layer back.
<br><br>note: layer Mask does not use spree; spree is active only when drawing to a layer.
</p><p>
<strong>Solidify / Discard / Auto</strong><br>
Top panel features a spree options tab.
<br><strong>Auto option</strong> automatically draws contents of spree to selected layer (solidify spree)
when you pick a new color.
<br><strong>Solidify spree</strong> button allows to manually solidify spree.
<br>hotkey: <span class="hkl-item-bind-keytag">Shift</span>+<span class="hkl-item-bind-keytag">S</span>
<br><strong>Discard spree</strong> button discards contents of a spree layer
</p><p>
<strong>Usage</strong><br>
<strong>Spree indicator</strong> shows which spree mode is currently active draw / erase.
<br><i>More information about Spree indicator <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('spree_indicator')">here</span></i>
<br><strong>Tools</strong> - many tools support and utilize Spree feature.
<br>Check with each tool for more information.
<br>As an example: Fill Tool, when filling to spree first - can then toggle spree mode erase, and it will
change the tool to Brush and you will be able to retouch the filled region.
<br><br>note on Fill Tool: to fill directly to a layer / color replace - set 'Direct' option in tool options menu.
<br><br><strong>Selection from Spree</strong><br>
Spree can be used to make a selection. Turn spree into a selection by:
<br>Press <span class="hkl-item-bind-keytag">Ctrl</span>+<span class="hkl-item-bind-keytag">B</span>
<br>or Select->Spree to selection
</p><p>
<strong>Undo Solidify</strong>
If spree has just solidified and you would like to get back to the state before - 
<br>Use Undo and then a single Redo.<br>
<br>for Undo: press <span class="hkl-item-bind-keytag">Ctrl</span>+<span class="hkl-item-bind-keytag">Z</span> keys or Edit->Undo
<br>for Redo: press <span class="hkl-item-bind-keytag">Ctrl</span>+<span class="hkl-item-bind-keytag">Shift</span>+<span class="hkl-item-bind-keytag">Z</span> keys or Edit->Redo
</p>
</section>
</div>

<div class="manual-page" data-item_name="Image Adjustments" data-item_id="image_adjustments" data-item_type="page">
<section>
<h1>Image Adjustments</h1>
<p>
Image->Adjustments<br>
<strong>HSB</strong> - Hue, Saturation, Brightness<br>
These sliders work on offset principle. In essence any color can be turned into any other
by shifting its hue, saturation, and brightness similar to an hsb color picker.
</p>
<p>
<strong>Colorize Grayscale</strong> is an option which allows to colorize
pixels of no saturation (grayscale).<br> 
Tick the option and then give it some saturation along with adjusting any other sliders to your liking.
</p>
<p>
<strong>Effect Area</strong> sliders help to isolate area of effect
by seeking only pixels that correspond to set limits
</p>
note: large images may take a long time to process, please allow time.
</section>
</div>

<div class="manual-page" data-item_name="Color Palette" data-item_id="palette" data-item_type="page">
<section>
<h1>Color Palette</h1>
<p>
<strong>Palette</strong> is a special layer for picking color.<br>
To show palette layer hold <span class="hkl-item-bind-keytag">C</span> key on keyboard.<br>
You can then click anywhere on the layer to sample color from it.
</p>
<p>
<strong>Snap for Palette</strong> feature can be accessed in layers panel<br>
Options->Snap for Palette<br>
This feature allows to add image/color to palette layer in a live session.<br>
1. Select a layer, that contains an image or color you would like to add to palette.<br>
2. Pan and zoom canvas to position and scale content;<br>
3. do Options->Snap for Palette in layers panel<br>
(!) Snap for Palette will imprint the canvas view onto a palette<br>
<br>(contents of a selected layer will be imprinted onto a palette layer, of the scale and position same way you see them in canvas view)
</p>
<p>
<strong>Palette Library</strong> is a menu for managing palette presets<br>
Access it in Other->Palette Library <br>
<strong>Capture</strong> feature in palette library allows to capture current
state of palette layer into a preset.<br>
You can also <strong>export</strong> any preset as a .png image file.<br>
<br>note: resizing program window will also resize and re-position contents of a palette layer
</p>
</section>
</div>

<div class="manual-page" data-item_name="Brush Library" data-item_id="brush_lib" data-item_type="page">
<section>
<h1>Brush Library</h1>
<p>
Other->Brush Library<br>
or click on the <span class="manual-page-sample-icon icon-brush_library"></span> icon at the top left near brush bays<br><br>
<strong>Brush Library</strong> is a menu where all brush presets are stored. You can create and modify brushes, and load them into bays to paint with.<br>

</p><p>
<strong>Bay Capture / [ bay-c ]</strong> <br>
Edit->Brush preset from bay<br>
captures active brush (bay in top panel) into a brush preset<br><br>
<strong>Layer Capture / [ layer-c ]</strong><br>
Edit->Brush preset from layer<br>
creates a brush preset using content of a selected layer. 
You may use selection tools to isolate area which shall be the tip of the new brush.
Otherwise, the whole layer will be sampled.<br>

<br>note: empty / transparent pixels will be truncated. 
If you would like to preserve empty space - 
manually create a new preset and choose an image from desktop (in brush tip).
</p>
<p>
<strong>Import</strong> allows to add a preset from a file.<br>
<strong>Export</strong> allows to export selected preset to a file.
</p>
<p><strong>Blend Assist option</strong> sets default state of brush to blend if checked. 
Hold <span class="hkl-item-bind-keytag">Z</span> key to toggle blend assist on the canvas.
</p>
</section>
</div>

<div class="manual-page" data-item_name="Preview" data-item_id="tiny_preview" data-item_type="page">
<section>
<h1>Preview</h1>
<p>
<strong>Preview</strong> allows to see whole canvas for reference, with effects available.<br>
<strong>Mirror</strong> effect keeps preview horizontally reflected compared to canvas view.<br>
<strong>Grayscale</strong> effect turns preview black and white.<br>
<strong>Toggle preview</strong> button will show/hide preview.
</p>
</section>
</div>

<div class="manual-page" data-item_name="Settings" data-item_id="settings" data-item_type="page">
<section>
<h1>Settings</h1>
<p>
<strong>Import Settings</strong><br>
Help->Import Settings<br>
<strong>Export Settings</strong><br>
Help->Export Settings<br>
<br>Import and Export features help backup and migrate configurations, using .dat file. 
<br>The file will contain all presets and settings, such that
you can take your Light Brush environment to another machine.<br>
You may also choose to use separate configurations for different kinds of work.
Then just backup your settings with Export and use them interchangeably using Import.
</p>
<p><strong>Reset All Settings</strong><br>
Help->Reset All Settings<br>
Using this feature will reset everything about the program.<br>
If issues occur after reset - you may try clearing browser's cache.
(first make sure Light Brush is closed, then clear cache, then open it again)
</p>
<p><strong>Exiting program</strong><br>
please use dedicated Exit button or File->Exit,
as this helps the program to tidy up before closing.
</p>
<p><strong>Notes:</strong><br>
Pen pressure may be limited on some systems due to dropped in-browser/engine support for older OS standards. 
But perhaps there are workarounds.<br><br>
All settings (including presets) are stored in browser's cache.
Use Import / Export features to migrate configuration.
</p>
</section>
</div>

<span data-item_type="category">Tools</span>

<div class="manual-page" data-item_name="Tool Options" data-item_id="tool_options" data-item_type="page">
<section>
<h1>Tool Options</h1>
<p>
<strong>Tool Options</strong> - tools (brush, fill, select, etc.) have additional features available in tool options menu.
<br>The &quot;multi-tool&quot; icon <span class="manual-page-sample-icon icon-tool_options"></span> button on top panel (top-left).<br>
<br>(!) Options will appear in this menu for each tool separately, when the corresponding tool is active.
</p>
<i>You can read about specific options and features, available for each tool, in corresponding user manual sections under the Tools category.</i>
</p>
</section>
</div>

<div class="manual-page" data-item_name="Move Tool" data-item_id="move_tool" data-item_type="page">
<section>
<h1>Move Tool</h1>
<p>
<strong>Move Tool</strong> can be used to transform and position content, along with selections.
Make a selection of layer / mask content you would like to alter, then use Move Tool features as outlined below:<br>
<i>More on Selection <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('selection')">here</span></i><br>
note: if no selection available - whole content of target layer / mask will be affected.<br>
note: empty selections can be transformed too.<br>
hotkey: <span class="hkl-item-bind-keytag">V</span>
</p><p>
<strong>Move</strong> - click &amp; drag anywhere in the canvas view to move content.
To nudge use the arrow keys on keyboard<br>
<strong>Scale</strong> - scaling content can be done by dragging square handles on the corners and sides.<br>
Modifiers: <br>
hold <span class="hkl-item-bind-keytag">Shift</span> key to preserve content proportions.<br>
hold <span class="hkl-item-bind-keytag">Alt</span> key for symmetry.<br>
<strong>Rotate</strong> - click &amp; drag the teardrop-looking handle located above content.<br>
note: you may need to zoom out a bit if the handle is not apparent in the current scope.<br>
Modifier: hold <span class="hkl-item-bind-keytag">Shift</span> for 5 degree increments snapping.
</p><p>
<strong>Tool Options</strong><br>
<strong>Position</strong> - content position can be monitored and set through X and Y fields.<br>
(!) Position used is the center point of content.<br>
<strong>Angle</strong> - content rotation can be monitored, set and reset through angle field; in degrees.<br>
<strong>Dimensions</strong> - content dimensions in pixels can be monitored and set through W and H fields.<br>
Also use dedicated buttons:<br>
<strong>[ fit ]</strong> to scale fit content within the canvas boundaries<br>
<strong>[ h ]</strong> to center horizontally content on a canvas<br>
<strong>[ v ]</strong> to center vertically content on a canvas<br>
<strong>[ reset ]</strong> to restore original content size<br>
<br>note: pasted or imported content that does not fit canvas boundaries - will be automatically fit.
However you may still restore content's original dimensions by pressing reset button.
</p>
</section>
</div>

<div class="manual-page" data-item_name="Auto Select Tool" data-item_id="auto_select_tool" data-item_type="page">
<section>
<h1>Auto Select Tool</h1>
<p>
<strong>Auto Select Tool</strong> helps selecting pixels that are "similar" by criterias, such as: 
color, and tone. Clicking on a canvas pixel will automatically select other pixels that are within range,
as specified in Tool Options menu.<br>
hotkey: <span class="hkl-item-bind-keytag">W</span>
</p><p>
<strong>Modifier Keys</strong><br>
<span class="hkl-item-bind-keytag">Ctrl</span> - hold to Add to an existing selection.<br>
<span class="hkl-item-bind-keytag">Alt</span> - hold to Subtract from an existing selection.<br>
</p><p>
<strong>Tool Options</strong><br>
<strong>All Layers</strong> - tool will sample any visible pixel as it appears in canvas view.
Otherwise, only current layer will be sampled.<br>
<strong>Contiguous</strong> - tool will select pixels that are directly adjacent/chained together, within clicked region.
Otherwise, all matching canvas pixels will be selected.<br>
<strong>Color</strong> - tells the tool how different color code, across Red Green Blue channels, can be
for it to still be counted as similar. Number represents total COMBINED difference taken between each channel.<br>
note: for Fill Tool, color difference is evaluated per channel, not combined.
<br><i>More on Fill Tool <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('fill_tool')">here</span></i><br>
<strong>Tone</strong> - is a calculated lightness value of a pixel.
</p><p>
<strong>Using Fill Tool</strong> - since Fill Tool has a bit different approach to determining which pixels to be affected,
it may be beneficial in some cases to use Fill Tool in spree mode, to fill region, then convert spree to selection.
</p><p>
<strong>Selection continued...</strong><br>
More information on Selection feature <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('selection')">here</span>
</p>
</section>
</div>

<div class="manual-page" data-item_name="Area Select Tool" data-item_id="area_select_tool" data-item_type="page">
<section>
<h1>Area Select Tool</h1>
<p>
<strong>Area Select Tool</strong> is a rectangular area selection tool.<br>
hotkey: <span class="hkl-item-bind-keytag">M</span>
</p><p>
<strong>Modifier Keys</strong><br>
<span class="hkl-item-bind-keytag">Ctrl</span> - hold to Add to an existing selection.<br>
<span class="hkl-item-bind-keytag">Alt</span> - hold to Subtract from an existing selection.<br>
</p><p>
<strong>Tool Options</strong><br>
<strong>Make Selection</strong> of specific Width and Height dimensions:<br>
Use dedicated W and H fields for width and height, and press <br><strong>[ Make Selection ]</strong> button.<br>
This will create a rectangular selection of secified dimensions (in pixels)<br>
<strong>Aspect ratio lock</strong> helps creating selections of width and height dimensions relative to one another.
Using W and H fields, provide ratio dimensions and activate by checking the Aspect Lock checkbox.<br>
e.g. 1 and 1 would be a square, or another example 16 and 9 is a standard ratio for many displays.<br>
<strong>Additionally</strong> moving any active selection with a cursor, while Area Select Tool is in use - 
will keep selection bound to canvas boundary.
</p><p>
<strong>Selection continued...</strong><br>
More information on Selection feature <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('selection')">here</span>
</p>
</section>
</div>

<div class="manual-page" data-item_name="Lasso Tool" data-item_id="lasso_tool" data-item_type="page">
<section>
<h1>Lasso Tool</h1>
<p>
<strong>Lasso Tool</strong> is a freehand selection tool. Draw an outline
with lasso tool to select an area.<br>
hotkey: <span class="hkl-item-bind-keytag">L</span>
</p><p>
<strong>Modifier Keys</strong><br>
<span class="hkl-item-bind-keytag">Ctrl</span> - hold to Add to an existing selection.<br>
<span class="hkl-item-bind-keytag">Alt</span> - hold to Subtract from an existing selection.<br>
</p><p>
<strong>Color Fill</strong> is an option of Lasso Tool, available in Tool Options menu; 
allows to automatically fill selected area with current color.<br>
This works for both: layer and mask.<br>
Layer - color fills to spree 
<br><i>More on Spree <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('spree')">here</span> </i><br>
Mask - affected directly, color does not matter, since masks are alpha channel based
<br><i>More on Masks <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('masks')">here</span> </i><br>
<strong>Additionally</strong> using modifier keys subtract function, while Color Fill option is active - also allows to erase spree and mask contents.
</p><p>
<strong>Selection continued...</strong><br>
More information on Selection feature <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('selection')">here</span>
</p>
</section>
</div>

<div class="manual-page" data-item_name="Brush Tool" data-item_id="brush_tool" data-item_type="page">
<section>
<h1>Brush Tool</h1>
<p>
<strong>Brush Tool</strong> is a primary drawing tool; on the left toolbar.
hotkey: <span class="hkl-item-bind-keytag">B</span><br>
Content drawn with Brush Tool first goes onto Spree layer.
<br> <i>More on Spree <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('spree')">here</span> </i><br>
Both Brush and Eraser tools use Bay interface, through which multiple features like sizing, brush selection and other options are available.
<br> <i>More on Brush Bays <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('brush_bays')">here</span> </i>
<br>
<strong>Quick Menu</strong> allows for a quick and visual way to change the size of a brush.<br>
Hold <span class="hkl-item-bind-keytag">Q</span> key, while hovering cursor above the canvas, and move cursor to the right to increase size, and to the left to decrease.<br>
<strong>Blending</strong> by default is done by holding <span class="hkl-item-bind-keytag">Z</span>
key and drawing with brush. Also brushes may have blending ON by default in brush preset, then holding the key
will toggle such brush to draw instead of blend.<br>
<i>More on Brush Library <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('brush_lib')">here</span> </i>
<br>
<strong>Smoothing</strong> is a Brush and Eraser tool option (sync'd for both); it helps with drawing rounder curves.<br>
Higher the level (0 - 7), the more prominent assistance effect will be applied to your brush / eraser strokes. <br>
note: very slow brush work may have minimal assistance even at the highest level, to accomodate detailing.
</p><p>
More Brush / Eraser features are available through Brush Bay interface.
<i>More on Brush Bays <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('brush_bays')">here</span> </i>
</p>
</section>
</div>

<div class="manual-page" data-item_name="Brush Bays" data-item_id="brush_bays" data-item_type="page">
<section>
<h1>Brush Bays</h1>
<p>
<strong>Brush Bays</strong> are slots for brushes. A brush that is loaded into a bay, then can be used to draw with.
Bays have settings similar to that of a brush preset (size, opacity, flow, hardness). These can be used to modify brush on the go; 
these will not modify the preset in Brush Library. 
<br>You can capture bay as a brush preset Edit->Brush preset from bay.
<br>Select bays by clicking, or by using <span class="hkl-item-bind-keytag"> 1, 2, ... 8 </span> keys
</p><p>
<strong>Size</strong> - there are 3 ways available for changing brush size:
<br>1) Use the size slider on the top panel. Also can use fine tune buttons in the size field.
<br>2) Quick Menu - hold <span class="hkl-item-bind-keytag">Q</span> key and move cursor to the right to increase size, and to the left to decrease.
<br>3) Keyboard <span class="hkl-item-bind-keytag">[</span> <span class="hkl-item-bind-keytag">]</span> keys
</p><p>
<strong>Zoom Size</strong> feature changes brush size automatically when you zoom.
Brush cursor size will look same in view but will change in relation to canvas.
</p><p>
<strong>Size Link</strong> - allows to link sizes of multiple bays/brushes together.
Brush sizes of linked bays will stay in set % proportions. You can change one brush's size and the other will update accordingly.
<br>1. Go to / select bay that you want to link
<br>2. Choose target bay from drop-down in size link.
<br>3. Set size % value, that you want currently selected bay to have, in relation to target bay.
<br>4. Activate link by checking the checkbox.
<br>You can link multiple bays to the same target bay, 
<br>e.g. bay2-bay1, bay3-bay1 etc.
<br><br>note: chaining bays is not a feature. e.g. bay1-bay2-bay3.
Can do one-one and many-one.
</p><p>
<strong>Keep Color</strong> allows to preserve and use color in bay.
<br>Pick color, then check 'keep color' option, and this color will be stored in current bay.
<br>Returning to this bay will switch color to the one stored in it.
<br>As long as the 'keep color' option is active, every newly picked color will be stored.
</p><p>
<strong>One Brush</strong> option allows to use the same brush bay across: Brush Tool, Eraser Tool, and Spree modes for each.
Alternatively when this option is off - you can choose a separate brush bay for each of the mentioned above.
</p><p>
<strong>Spree mode</strong> - each bay can be chosen in relation to the spree mode 'draw' / 'erase'.
To choose separate bays for each mode for the tool: 
<br>Select the tool, e.g. Brush Tool and turn OFF the One Brush option.
<br>Now you can set bay for spree mode 'draw' by clicking on brush bay lower portion (where the brush icon is shown)
and a white outline should appear around the icon, indicating that the bay is chosen for drawing.
<br><br>To set bay (any bay, doesn't have to be the same one) for spree mode 'erase' click on upper portion that looks like
a big dash above a brush icon. It should turn black, indicating that this bay will now be used for spree erasing.
</p><p>
<strong>Stamp Mode</strong> allows to draw with area sampled from the canvas.
To sample area - align brush cursor with the area and press <span class="hkl-item-bind-keytag">O</span> key.
This will put area under the brush into bay and activate stamp mode.
Sampled area couples with the brush, and you can draw with it.
<br>note: since the stamp resides in a bay, you can load different brushes, from Brush Library,
into that same bay and the stamp will use the new brush.
</p>
</section>
</div>

<div class="manual-page" data-item_name="Eraser Tool" data-item_id="eraser_tool" data-item_type="page">
<section>
<h1>Eraser Tool</h1>
<p>
<strong>Eraser Tool</strong> properties are similar to Brush Tool.<br>
hotkey: <span class="hkl-item-bind-keytag">E</span><br>

<i>More on Brush Tool <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('brush_tool')">here</span> </i><br>
<strong>Spree</strong><br>
Erasing layer content with Eraser Tool - the erase effect first goes onto a Spree layer.<br>
Pressing <span class="hkl-item-bind-keytag">X</span> key
will toggle spree erase mode and you will be able to un-erase back the content you just erased with Eraser Tool.<br>
<i>More on Spree <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('spree')">here</span> </i> 
</p>
</section>
</div>

<div class="manual-page" data-item_name="Fill Tool" data-item_id="fill_tool" data-item_type="page">
<section>
<h1>Fill Tool</h1>
<p>
<strong>Fill Tool</strong> allows to fill layer regions with color<br>
hotkey: <span class="hkl-item-bind-keytag">G</span><br>
</p><p>
<strong>Tool Options</strong><br>
<strong>Layers reference</strong> - there are a few options available when it comes to 
which layer to sample/use as a reference for fill.<br>
<strong>All Layers</strong>: reference canvas view as it appears.<br>
<strong>Top Visible</strong>: reference only the top most layer that is visible. <br>e.g. a layer with line art on it.<br>
<strong>Current Layer</strong>: by default, current layer will be referenced,
when the other two options are unchecked.<br>
<br>
<strong>Direct / Spree</strong> option allows to choose whether to fill to spree(default), or directly to layer(when enabled).
<br>Using direct to layer approach also yields ability to replace color of the region, retaining transparency.
<br>Another use case would be making a graduated color effect by using a selection with feathered/transparent edges.<br>
<i>More on Selection <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('selection')">here</span></i><br>
<strong>Spree</strong> - when filling to spree, can toggle brush spree erase mode,
by pressing <span class="hkl-item-bind-keytag">X</span> key or clicking on spree indicator.
This will allow to retouch/erase filled region with a brush tool.<br>
<i>More on Spree <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('spree')">here</span></i><br>
<i>More on Brush Tool <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('brush_tool')">here</span></i><br>
<br>
<strong>Tolerance</strong> - samples existing colors on canvas in order to decide whether to fill them.
Color difference (0-255) per each channel separately.<br>
<strong>Opacity Barrier</strong> - samples existing colors on canvas in alpha (transparency) channel.
Fill tool is able to fill in under partially transparent pixels. Opacity Barrier (0-100%)
tells the tool how much opacity in percentages to count as a boundary for fill.<br>
e.g. 100% means fill everything to the border of fully opaque pixels.<br>
<br>
<strong>Selection with Fill Tool</strong><br>
Using the Spree to selection feature, it is possible to create selections
with Fill Tool. 
<br>To do so, make sure 'Direct' option is disabled.
After filling a region, you may want to adjust it with a brush, and after you are done
<br>press <span class="hkl-item-bind-keytag">Ctrl</span>+<span class="hkl-item-bind-keytag">B</span>
or Select->Spree to selection.<br>
This method is useful, in comparison to Auto Select Tool, in a way that tolerance options are
different between the two, and also the ability to retouch region with a brush.<br>
<i>More on Auto Select Tool <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('auto_select_tool')">here</span></i><br>
<br>
note: another way is to use fill on a separate layer and then make selection from layer instead of Spree to selection.<br>
<i>More on Selection <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('selection')">here</span></i>
</p>
</section>
</div>

<div class="manual-page" data-item_name="Color Picker" data-item_id="color_picker" data-item_type="page">
<section>
<h1>Color Picker</h1>
<p>
<strong>Color Picker</strong><br>
Access color picker by clicking on color indicator located on the left toolbar,
or by pressing <span class="hkl-item-bind-keytag">F</span> key to toggle.
<br><strong>Color square</strong> represents current color in picker.
It is located on the outside of the color picker menu.
You can position square in regard to canvas, to visually approximate
how the color will fit.
</p><p>
<strong>Eyedropper Tool</strong> is used to sample color from the canvas.<br>
Hold <span class="hkl-item-bind-keytag">Shift</span> key and click on the canvas to sample color.
Alternatively, if the Shift key is reserved as a modifier for a particular tool - 
use Eyedropper Tool hotkey: <span class="hkl-item-bind-keytag">D</span><br>
<strong>Dropper layer mode</strong> is an option available in Color Picker menu,
and allows for Eyedropper Tool to sample color from selected layer at maximum opacity.<br>
e.g. If a layer has black color semi-transparent and it looks gray on white background of a layer underneath - 
sampled color will be pure black. The idea is that this option should help you with transparent overlays 
by giving you absolute color of the region.
</p>
</section>
</div>

<div class="manual-page" data-item_name="Spree Indicator" data-item_id="spree_indicator" data-item_type="page">
<section>
<h1>Spree Indicator</h1>
<p>
<strong>Spree Indicator</strong> is on the left toolbar. 
<br>It is color White for draw, and color Black for erase spree modes.
<br>Clicking on the indicator, or pressing <span class="hkl-item-bind-keytag">X</span> key
will switch between spree modes for Brush and Eraser tools.<br>
In case when layer Mask is selected - Eraser Tool will be selected automatically in place of spree eraser.
<br><br><i>More information about Spree feature <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('spree')">here</span></i>
</p>
</section>
</div>

<div class="manual-page" data-item_name="Hand Zoom & Pan" data-item_id="zoom" data-item_type="page">
<section>
<h1>Hand Zoom &amp; Pan</h1>
<p>
<strong>Zoom controls</strong> include:<br>
<strong>[ fit ]</strong>: will fit canvas in view; 
hotkey: <span class="hkl-item-bind-keytag">Ctrl</span>+<span class="hkl-item-bind-keytag">0</span><br>
<strong>[ 1:1 ]</strong>: will set 100% zoom, as in - 1:1 actual pixels of display you are using.<br>
<strong>[ t ]</strong> - toggle feature allows to toggle between two most recent zoom and panning positions;
hotkey: <span class="hkl-item-bind-keytag">R</span><br>
<strong>Quick menu</strong> features two buttons for zooming - and +.
Click and hold the buttons to zoom in and out.<br>
(to bring up Quick menu hold <span class="hkl-item-bind-keytag">Q</span>
key on your keyboard)<br>
<strong>Mouse</strong> - zooming with a mouse is available by holding <span class="hkl-item-bind-keytag">Ctrl</span>
key and using mouse scroll wheel.<br>
<strong>Manual input</strong> is also available. You can manually enter zoom level in percentages, for example number 200 means 200% = 2x zoom.<br>
</p>
<p>
<strong>Hand Tool / Touch</strong> is activated by holding <span class="hkl-item-bind-keytag">H</span> or <span class="hkl-item-bind-keytag">Space</span>
key on your keyboard. <br>
Alternatively activate hand tool via <span class="manual-page-sample-icon icon-hand_tool"></span> button on the left toolbar.
<br>You will be able to pan the canvas and pinch-zoom.<br>
Touch keys panel with modifier keys (Ctrl, Alt, Shift) will also appear. These can be toggled on/off, to use when no keyboard is available.
</p>
</section>
</div>

<span data-item_type="spacer"></span>

<div class="manual-page" data-item_name="Pen Pressure" data-item_id="pen-pressure" data-item_type="page">
<section>
<h1>Pen Pressure</h1>
<p>
<strong>Pen Pressure</strong> should work normally.<br>
Make sure to check that the brush you are using has the corresponding pressure option enabled,
and also that the brush is loaded in the bay, after the preset been changed.
<br><i>More on Brush Library <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('brush_lib')">here</span> </i>
<br><i>More on Brush Bays <span class="manual-page-page-link" onclick="manual_keeper.selectPageById('brush_bays')">here</span> </i>
</p><p>
<strong>Troubleshooting</strong><br>
<strong>Browser</strong> - Chromium browsers, such as: Chrome, Edge, Opera etc.
officially support pen pressure. It is known that some other browsers do not support pen pressure,
for example Firefox.
</p><p>
<strong>Windows Ink</strong> - it is possible that on your system configuration 
you may need to enable or disable Windows Ink. 
This option is usually located in your tablet driver menu.
<br>It is typical for Chromium browsers to use Windows Ink, in order to read pen pressure from your drawing tablet.
Though, it is also possible that your system is configured differently and disabling this option may yield the proper result.
</p><p>
<strong>Operating System (OS)</strong><br>
There is currently known only one limitation - it is that pen pressure may not work on older Windows systems, such as Windows 7 and earlier.
The reason is that these versions of Windows have a different approach to pen pressure.
Newer browser versions have dropped support for older pen pressure standards.
</p>
</section>
</div>

<div class="manual-page" data-item_name="Hotkeys" data-item_id="hotkeys" data-item_type="page">
<section>
<h1>Hotkeys</h1>
<p>
<strong>Hotkeys</strong><br>
Help->Hotkeys<br>
Allow for feature access through keyboard key-combinations.<br>
<i>note: in this version of the program hotkey re-mapping is not supported. </i>

</p>
<p class="manual-page-clickable" onclick="showUIElement(UI.hk_list);">Click here to open hotkeys list</p>
</section>
</div>

</div><!-- manual page pool end -->

</div><!-- technical_support_elements end -->

<!-- container -->
<div id="container">

<div id="splash_screen">
<div id="splash_screen_backdrop"></div>

<div id="splash_badge">
<span id="splash_badge_program_name">Light Brush<span class="about-trademark">&trade;</span></span>
<span id="splash_badge_program_version">Version 1.1.3</span>
<br>
<br>
<span id="splash_badge_info"><!-- <span>by:</span> --> Dmitriy Burmistrov</span>
</div>

</div>

<div id="grid-container">

<!-- dock 1 -->
<div id="dock_1">

<!-- general menu bar -->
<div id="general_options_bar">

<span id="general_light_brush_logo" class="icon-light_brush_logo" title="Light Brush&trade;"></span>

<span class="general-option-btn">
<select id="general_file_menu" class="select-general-menu" autocomplete="off">
<option value="file" selected disabled class="hidden_obj">File</option>
<option value="new">New</option>
<option value="open">Open</option>
<option value="save" title="(Ctrl+S)">Save As...</option>
<option value="none" disabled></option>
<option value="import image">Import Image</option>
<option value="export selected" title="export selected content of layer or mask">Export Content</option>
<option value="none" disabled></option>
<option value="exit">Exit</option>
</select>
</span>

<span class="general-option-btn">
<select id="general_edit_menu" class="select-general-menu" autocomplete="off">
<option value="edit" selected disabled class="hidden_obj">Edit</option>
<option value="undo" title="(Ctrl+Z)">Undo</option>
<option value="redo" title="(Ctrl+Shift+Z)">Redo</option>
<!-- paste does not trigger programmatically 
Local non-clipboard operation only. 
To interact with clipboard user needs to use hotkeys to waive permissions -->
<option value="cut" title="(Ctrl+X)">Cut</option>
<option value="copy" title="(Ctrl+C)">Copy</option>
<option value="paste" title="(Ctrl+V)">Paste</option>
<option value="fsc horizontal" title="Flips selected content horizontally">Flip Horizontal</option>
<option value="fsc vertical" title="Flips selected content vertically">Flip Vertical</option>
<option value="bpfl">Brush preset from layer</option>
<option value="bpfb">Brush preset from bay</option>
<!-- <option value="transform" title="(Ctrl+T)">Transform</option> -->
</select>
</span>

<span class="general-option-btn">
<select id="general_image_menu" class="select-general-menu" autocomplete="off">
<option value="image" selected disabled class="hidden_obj">Image</option>
<option value="adjustments" title="(Ctrl+U)">Adjustments</option>
<option value="image size">Image Size</option>
<option value="canvas size">Canvas Size</option>
<option value="crop">Crop</option>
<option value="rc cw" title="rotate canvas 90 degrees/clockwise/right">Rotate Canvas Right</option>
<option value="rc ccw" title="rotate canvas -90 degrees/counter-clockwise/left">Rotate Canvas Left</option>
<option value="fc horizontal" title="(Ctrl+M)">Flip Canvas Horizontal</option>
<option value="fc vertical">Flip Canvas Vertical</option>
</select>
</span>

<span class=" general-option-btn">
<select id="general_select_menu" class="select-general-menu" autocomplete="off">
<option value="select" selected disabled class="hidden_obj">Select</option>
<option value="deselect" title="Clears selection. To toggle selection instead press (Ctrl+D)">Deselect</option>
<option value="select content" title="select content of selected layers (Ctrl+A)">Select Content</option>
<option value="select all" title="selects whole canvas">Select All</option>
<option value="toggle selection" title="(Ctrl+D)">Toggle Selection</option>
<option value="inverse">Inverse</option>
<option value="from layer add">From Layer + </option>
<option value="from layer subtract">From Layer - </option>
<option value="make opaque" title="removes feathering/transparency in selection by making it opaque">Make selection opaque</option>
<option value="from spree" title="Turns spree contents into a selection (Ctrl+B)">Spree to selection</option>
<option value="wrap" title="Modifies current selection to wrap layer view">Wrap</option>
</select>
</span>

<span class="general-option-btn">
<select id="general_filter_menu" class="select-general-menu" autocomplete="off">
<option value="filter" selected disabled class="hidden_obj">Filter</option>
<option value="invert colors"  title="(Ctrl+I)">Invert Colors</option>
<option value="bnw"  title="(Ctrl+Shift+U)">B&amp;W </option>
<option value="desaturate avg" title="(Ctrl+Shift+O)">Desaturate Avg.</option>
<option value="bnwalpha" title="Turns color to luminosity-weighed transparent black and white">Alpha B&amp;W </option>
</select>
</span>

<span class="general-option-btn">
<select id="general_other_menu" class="select-general-menu" autocomplete="off">
<option value="other" selected disabled class="hidden_obj">Other</option>
<option value="bpl">Brush Library</option>
<option value="rll">Palette Library</option>
</select>
</span>

<span class="general-option-btn">
<select id="general_help_menu" class="select-general-menu" autocomplete="off">
<option value="help" selected disabled class="hidden_obj">Help</option>
<option value="import settings">Import Settings</option>
<option value="export settings">Export Settings</option>
<option value="reset settings">Reset All Settings</option>
<option value="none" disabled></option>
<option value="tool options" title="play tool options demo">Tool Options</option>
<option value="hotkeys" title="List of actions and corresponding hotkeys">Hotkeys</option>
<option value="manual">Manual</option>
<option value="none" disabled></option>
<option value="about">About</option>
</select>
</span>

<span class="icon-fullscreen_toggle" id="fullscreen_toggle" title="Fullscreen toggle"></span>

<span class="general-option-btn" id="general_exit_btn" title="Close the program">Exit</span>

<span id="general_donate_btn">Donate</span>


</div><!-- general menu bar end -->

<!-- bay panel -->
<div id="bay_panel_bar">

<!-- tool options -->
<span id="tool_config_panel_container">
<input class="hidden-toggler" id="tool_config_menu_toggler" type="checkbox" autocomplete="off">
<label for="tool_config_menu_toggler" title="Options for current tool. (options will appear for each tool separately, when that tool is active. e.g. brush, fill, select etc.)">
<span class="icon-tool_options bay-panel-btn" id="tool_config_menu_btn">
<!-- <span>Tool Config</span> -->
</span>
</label>
<!-- tool config menu -->
<span id="tool_config_menu">

<span class="tool-config-menu-content" id="move_config_menu">
<span class="tool-config-cell tool-config-menu-name">Move</span>
<span class="tool-config-cell"><label>Position</label></span>
<span class="tool-config-cell text-align-center">
<!-- mt : move tool/move transform -->
<label>X:<input type="number" id="mt_area_pos_x" value="0" autocomplete="off"></label>
<label>Y:<input type="number" id="mt_area_pos_y" value="0" autocomplete="off"></label>
</span>

<span class="tool-config-cell text-align-center"><label>Angle &#176;</label></span>
<span class="tool-config-cell text-align-center">
<label><input type="number" id="mt_area_angle" value="0.00" step="1.00" autocomplete="off"></label>
<span class="button tool-config-cell-btn display-inline-block" id="mt_area_reset_angle" title="zero angle">reset</span>
</span>


<span class="tool-config-cell-spacer"></span>
<span class="tool-config-cell"><label>Dimensions</label></span>
<span class="tool-config-cell text-align-center">
<label>W:<input type="number" min="1" id="mt_area_w" value="1" autocomplete="off"></label>
<label>H:<input type="number" min="1" id="mt_area_h" value="1" autocomplete="off"></label>
<br>
<span class="button tool-config-cell-btn display-inline-block" id="mt_area_fit_dimensions" title="fit content to canvas">fit</span>
<span class="button tool-config-cell-btn display-inline-block" id="mt_area_pos_center_x" title="center horizontally">h</span>
<span class="button tool-config-cell-btn display-inline-block" id="mt_area_pos_center_y" title="center vertically">v</span>
<span class="button tool-config-cell-btn display-inline-block" id="mt_area_reset_dimensions" title="restore original size">restore</span>
</span>
</span>

<span class="tool-config-menu-content" id="selection_config_menu">
<span class="tool-config-cell tool-config-menu-name">Auto-Select </span>
<span class="tool-config-cell"><label title="Sample canvas view"><input type="checkbox" id="sm_all_layers" autocomplete="off"> All Layers</label></span>
<span class="tool-config-cell"><label title="Select matching pixels only if they are adjacent, rather than anywhere on a canvas"><input type="checkbox" id="sm_contiguous" autocomplete="off"> Contiguous</label></span>
<span class="tool-config-cell"><label title="Parameters that help auto-select to decide what to select">Tolerance</label></span>
<span class="tool-config-cell"><label title="Color variation range (0-255). Overall combined difference value across Red Green Blue channels.">Color: <input type="number" class="tool-config-cell-value" id="sm_rgb_margin" min="0" max="255" value="25" autocomplete="off"></label></span>
<span class="tool-config-cell"><label title="Lightness of color variation (0-255)">Tone: <input type="number" class="tool-config-cell-value" id="sm_tone_margin" min="0" max="255" value="35" autocomplete="off"></label></span>
</span>

<span class="tool-config-menu-content" id="select_area_config_menu">
<span class="tool-config-cell tool-config-menu-name">Select Area </span>
<span class="tool-config-cell"><label>Dimensions</label></span>
<span class="tool-config-cell text-align-center">
<label>W:<input type="number" min="1" id="sm_make_selection_area_w" value="100" autocomplete="off"></label>
<label>H:<input type="number" min="1" id="sm_make_selection_area_h" value="100" autocomplete="off"></label>
<br>
<span class="button tool-config-cell-btn display-inline-block" id="sm_make_selection_area_btn" title="creates a rectangular selection of set dimensions in the middle of a canvas">Make Selection</span>
</span>
<span class="tool-config-cell-spacer"></span>
<span class="tool-config-cell text-align-center"><label><input type="checkbox" autocomplete="off" id="sm_select_area_aspect_lock"> Aspect Lock</label></span>
<span class="tool-config-cell text-align-center">
<label>W:<input type="number" min="1" id="sm_select_area_aspect_w" value="1" autocomplete="off"></label>
<label>H:<input type="number" min="1" id="sm_select_area_aspect_h" value="1" autocomplete="off"></label>
</span>
</span>

<span class="tool-config-menu-content" id="lasso_config_menu">
<span class="tool-config-cell tool-config-menu-name">Lasso </span>
<span class="tool-config-cell text-align-center"><label title="Blanket fill (to spree) area selected with lasso tool"><input type="checkbox" id="fc_lasso_fill" autocomplete="off"> Color fill</label></span>
</span>

<span class="tool-config-menu-content" id="brush_config_menu">
<span class="tool-config-cell tool-config-menu-name">Brush </span>
<span class="tool-config-cell">
<label title="Level 0 - 7. Helps drawing curves. Works best with quicker strokes.">Smoothing:<input type="number" min="0" max="7" id="brush_smoothing_value" value="0" autocomplete="off"></label>
</span>
</span>

<span class="tool-config-menu-content" id="eraser_config_menu">
<span class="tool-config-cell tool-config-menu-name">Eraser </span>
<span class="tool-config-cell">
<label title="Level 0 - 7. Helps drawing curves. Works best with quicker strokes.">Smoothing:<input type="number" min="0" max="7" id="eraser_smoothing_value" value="0" autocomplete="off"></label>
</span>
</span>

<span class="tool-config-menu-content" id="fill_config_menu">
<span class="tool-config-cell tool-config-menu-name">Fill </span>
<span class="tool-config-cell"><label title="Reference canvas view"><input type="checkbox" id="fc_all_layers" autocomplete="off"> All Layers</label></span>
<span class="tool-config-cell"><label title="Reference top visible layer only"><input type="checkbox" id="fc_top_visible" autocomplete="off"> Top visible</label></span>
<span class="tool-config-cell"><label title="Color variation range (0-255). Per channel difference value.">Tolerance: <input type="number" class="tool-config-cell-value" id="fc_rgb_margin" value="25" min="0" max="255" autocomplete="off"></label></span>
<span class="tool-config-cell"><label title="Content opacity percentage to be counted as a barrier for fill (1-100%)">Opacity Barrier: <input type="number" class="tool-config-cell-value" id="fc_opacity_barrier" min="1" max="100" value="100" autocomplete="off"></label></span>
<span class="tool-config-cell"><label title="Fill directly to layer. Also replaces color while maintaining destination transparency"><input type="checkbox" id="fc_direct" autocomplete="off"> Direct</label></span>
<span class="tool-config-cell"><label title="Basic fill has no transparency or tolerance awareness"><input type="checkbox" id="fc_basic_fill" autocomplete="off"> Basic fill</label></span>
</span>

<span class="tool-config-menu-content" id="tool_config_empty_menu">
<span class="tool-config-cell tool-config-menu-name">empty </span>
</span>

</span><!-- tool config menu end -->
</span><!-- tool options end -->

<span class="button bay-panel-btn icon-brush_library" title="Brush Library" id="bay_brush_select">
</span>

<span class="bay-shell" id="bay_0">
<input type="radio" name="bay_erase_select_group" class="bay-erase-select" id="bay_0_erase" autocomplete="off">
<label>
<span>
<img class="bay-tip-icon" id="bay_0_icon">
<input type="radio" name="bay_draw_select_group" class="bay-draw-select" id="bay_0" autocomplete="off">
</span>
</label>
</span>

<span class="bay-shell" id="bay_1">
<input type="radio" name="bay_erase_select_group" class="bay-erase-select" id="bay_1_erase" autocomplete="off">
<label>
<span>
<img class="bay-tip-icon" id="bay_1_icon">
<input type="radio" name="bay_draw_select_group" class="bay-draw-select" id="bay_1" autocomplete="off">
</span>
</label>
</span>

<span class="bay-shell" id="bay_2">
<input type="radio" name="bay_erase_select_group" class="bay-erase-select" id="bay_2_erase" autocomplete="off">
<label>
<span>
<img class="bay-tip-icon" id="bay_2_icon">
<input type="radio" name="bay_draw_select_group" class="bay-draw-select" id="bay_2" autocomplete="off" checked>
</span>
</label>
</span>

<span class="bay-shell" id="bay_3">
<input type="radio" name="bay_erase_select_group" class="bay-erase-select" id="bay_3_erase" autocomplete="off">
<label>
<span>
<img class="bay-tip-icon" id="bay_3_icon">
<input type="radio" name="bay_draw_select_group" class="bay-draw-select" id="bay_3" autocomplete="off">
</span>
</label>
</span>

<span class="bay-shell" id="bay_4">
<input type="radio" name="bay_erase_select_group" class="bay-erase-select" id="bay_4_erase" autocomplete="off">
<label>
<span>
<img class="bay-tip-icon" id="bay_4_icon">
<input type="radio" name="bay_draw_select_group" class="bay-draw-select" id="bay_4" autocomplete="off">
</span>
</label>
</span>

<span class="bay-shell" id="bay_5">
<input type="radio" name="bay_erase_select_group" class="bay-erase-select" id="bay_5_erase" autocomplete="off" checked>
<label>
<span>
<img class="bay-tip-icon" id="bay_5_icon">
<input type="radio" name="bay_draw_select_group" class="bay-draw-select" id="bay_5" autocomplete="off">
</span>
</label>
</span>

<span class="bay-shell" id="bay_6">
<input type="radio" name="bay_erase_select_group" class="bay-erase-select" id="bay_6_erase" autocomplete="off">
<label>
<span>
<img class="bay-tip-icon" id="bay_6_icon">
<input type="radio" name="bay_draw_select_group" class="bay-draw-select" id="bay_6" autocomplete="off">
</span>
</label>
</span>

<span class="bay-shell" id="bay_7">
<input type="radio" name="bay_erase_select_group" class="bay-erase-select" id="bay_7_erase" autocomplete="off">
<label>
<span>
<img class="bay-tip-icon" id="bay_7_icon">
<input type="radio" name="bay_draw_select_group" class="bay-draw-select" id="bay_7" autocomplete="off">
</span>
</label>
</span>

<span id="bay_config_wrap">

<span class="bay-panel-btn">
<label title="Brush size automatically adjusts when zooming">
<span>zoom size</span>
<input type="checkbox" id="bay_zoom_size_active" autocomplete="off">
</label>
</span>

<span class="bay-config-cell" id="bay_config_size_cell">
Size:
<input class="bay-config-value" id="bay_size_value" type="number" value="100" min="1" autocomplete="off">
<input class="bay-config-slider" id="bay_size_slider" type="range" min="1" max="350">
</span>

<span class="bay-config-cell">
Opacity:
<input class="bay-config-value text-align-center" id="bay_opacity_value" type="number" value="100" min="1" max="100" autocomplete="off">
<input class="bay-config-slider" id="bay_opacity_slider" type="range" min="1" max="100">
</span>

<span class="bay-config-cell">
Flow:
<input class="bay-config-value text-align-center" id="bay_flow_value" type="number" value="100" min="1" max="100" autocomplete="off">
<input class="bay-config-slider" id="bay_flow_slider" type="range" min="1" max="100">
</span>

<span class="bay-config-cell">
Hardness:
<input class="bay-config-value text-align-center" id="bay_hardness_value" type="number" value="100" min="0" max="100" autocomplete="off">
<input class="bay-config-slider" id="bay_hardness_slider" type="range" min="0" max="100">
</span>

<span class="bay-config-cell" id="bay_config_size_link_cell">
<span>
<label for="bay_link_active" title="Enables a relative size link between bays, as a % of a target bay's size. Link implies both ways, and sizes stay relative upon bay selection change.">Size Link:</label>
<select class="drop-down-menu" id="bay_link_ref">
  <option value="0">Bay 1</option>
  <option value="1">Bay 2</option>
  <option value="2">Bay 3</option>
  <option value="3">Bay 4</option>
  <option value="4">Bay 5</option>
  <option value="5">Bay 6</option>
  <option value="6">Bay 7</option>
  <option value="7">Bay 8</option>
</select> 
</span>

<label title="Enables a relative size link between bays, as a % of a target bay's size. Link implies both ways, and sizes stay relative upon bay selection change.">
<input type="checkbox" id="bay_link_active">
</label>

<input class="bay-config-value text-align-center" id="bay_link_value" type="number" value="100" min="1" autocomplete="off">
</span>

<span class="bay-panel-btn">
<label title="Preserve color in this bay">
<span>keep color</span>
<input type="checkbox" id="bay_keep_color_active">
</label>
</span>

<span class="bay-panel-btn">
<label title="Puts brush into stamp mode. Sample area under brush by pressing (O). See Help->Manual->Brush Bays for more information.">
<span>stamp mode</span>
<input type="checkbox" id="bay_clone_mode_active">
</label>
</span>

<span class="bay-panel-btn">
<label title="Sets a lock to use the same brush across brush and eraser tools, including spree eraser modes for both">
<span>one brush</span>
<input type="checkbox" id="bay_single_brush_lock" autocomplete="off">
</label>
</span>

</span><!-- bay_config_wrap -->

<span class="button" id="undo_btn" title="Undo (Ctrl+Z)"></span>
<span class="button" id="redo_btn" title="Redo (Ctrl+Shift+Z)"></span>
</div><!-- bay panel end -->

</div><!-- dock 1 end -->


<!-- dock 2 -->
<div id="dock_2">

<span class="spree-bar-cell panel-name" title="read about the spree feature in Help->Manual->Spree">Spree</span>
<span class="spree-bar-cell">
<label title="Automatically solidify spree upon color change and some other actions.">
Auto: <input autocomplete="off" id="spree_auto" type="checkbox" checked>
</label>
</span>

<span id="spree_solid_1" class="button icon-solidify_spree_btn" title="Solidify spree (Shift+S)"></span>
<span id="spree_discard" class="button icon-discard_spree_btn" title="Discard spree"></span>

</div><!-- dock 2 end -->


<!-- dock 3 -->
<div id="dock_3">

<!-- nav tab -->
<div id="nav_tab_container">

<!-- nav tab bar -->
<div id="nav_tab_bar">

<label>
<input type="checkbox" class="tiny-preview-filter-toggler hidden-toggler" id="tiny_preview_mirror" autocomplete="off">
<span class="fm-cell-btn tiny-preview-btn" id="tiny_preview_mirror_btn"> mirror </span>
</label>

<label title="grayscale">
<input type="checkbox" class="tiny-preview-filter-toggler hidden-toggler" id="tiny_preview_bnw" autocomplete="off">
<span class="fm-cell-btn tiny-preview-btn" id="tiny_preview_bnw_btn"> g </span>
</label>

<label>
<input type="checkbox" class="tiny-preview-filter-toggler hidden-toggler" id="tiny_preview_hide" autocomplete="off" checked>
<span class="fm-cell-btn tiny-preview-btn icon-tiny_preview_btn" id="tiny_preview_hide_btn"></span>
</label>

</div><!-- nav tab bar end -->

<!-- nav tab content -->
<div id="nav_tab_content">
<div class="content-abs">

<span class="tiny-preview-container">
<span class="tiny-preview-canvas-align">
<canvas width="2560" height="1440" class="tiny-preview-canvas bg-checkerboard-small" id="tinyPreview"></canvas>
</span>
</span>

<span id="tiny_preview_hide_screen"></span>

</div>
</div><!-- nav tab content end -->
</div><!-- nav tab end -->


<!-- layers -->
<div id="layers_tab">

<span class="panel-name">Layers</span>

<!-- layer config -->
<span id="layer_config">

<span class="layers-tab-cell">

<span id="layer_blending_box">
 <select class="drop-down-menu" id="layer_blending">
  <option value="source-over">Normal</option>
  <option value="overlay">Overlay</option>
  <option value="soft-light">Soft Light</option>
  <option value="screen">Screen</option>
  <option value="multiply">Multiply</option>
  <option value="difference">Difference</option>
  <option value="exclusion">Exclusion</option>
  <option value="hard-light">Hard Light</option>
  <option value="lighten">Lighten</option>
  <option value="darken">Darken</option>
  <option value="luminosity">Luminosity</option>
  <option value="hue">Hue</option>
  <option value="color">Color</option>
  <option value="Saturation">Saturation</option>
  <option value="color-dodge">Color Dodge</option>
  <option value="color-burn">Color Burn</option>
  <option value="lighter">Lighter</option>
  <option value="xor">XOR</option>
</select> 
</span>

<span class="layers-tab-cell-section" id="layer_opacity_box">
<span>
Opacity:
<input id="layer_opacity_value" type="number" value="100" min="0" max="100" autocomplete="off"><br>
</span>
<span>
<input id="layer_opacity_slider" type="range" min="0" max="100">
</span>
</span>

</span>

<span class="layers-tab-cell">

<select class="drop-down-menu" id="layer_options" autocomplete="off">
  <option value="options" disabled selected class="hidden_obj">Options</option>
  <option value="duplicate"  title="(Ctrl+J)">Duplicate</option>
  <option value="clip">Clip</option>
  <option value="unclip">unClip</option>
  <option value="apply mask">Apply Mask</option>
  <option value="merge">Merge</option>
  <option value="merge create">Merge Create</option>
  <option value="ref" title="capture current view of layer to palette">Snap for Palette</option>
  <option value="flatten">Flatten</option>
</select> 


<span id="layer_options_btn_box">
<span class="button layer-options-btn icon-layers_eye" id="layer_options_visibility_btn" title="show/hide selected layers from view"></span>
<span class="button layer-options-btn icon-clear_btn" id="layer_options_cl_btn" title="Clear target layer or mask"></span>
</span>


</span>
</span><!-- layer config end -->


<div id="layers_section_container">
<ul id="layers_item_container" class="touch-scrollable">
<!-- Layers Example
<li class="layers-item layers-item-selected-multi">

<span class="layers-item-eye-container">
<label>
<input type="checkbox" class="layers-item-eye-toggler hidden-toggler" checked autocomplete="off">
<span class="layers-item-eye icon-layers_eye"></span>
</label>
</span>


<span class="layers-item-clipping-mask icon-clipping_mask_arrow"></span>

<span class="layer-preview">
<span class="layers-item-canvas-align">
<canvas width="300" height="200" class="layers-item-canvas bg-checkerboard-small"></canvas>
</span>
</span>

<span class="layers-item-mask">
<span class="layers-item-canvas-align">
<canvas width="300" height="200" class="layers-item-canvas bg-black"></canvas>
</span>
</span>

<span class="layers-item-name">Layer 2</span>
</li>

<li class="layers-item layers-item-selected">

<span class="layers-item-eye-container">
<label>
<input type="checkbox" class="layers-item-eye-toggler hidden-toggler" checked autocomplete="off">
<span class="layers-item-eye icon-layers_eye"></span>
</label>
</span>


<span class="layers-item-clipping-mask icon-clipping_mask_arrow"></span>

<span class="layer-preview layers-item-target-selected">
<span class="layers-item-canvas-align">
<canvas width="300" height="200" class="layers-item-canvas bg-checkerboard-small"></canvas>
</span>
</span>

<span class="layers-item-mask">
<span class="layers-item-canvas-align">
<canvas width="300" height="200" class="layers-item-canvas bg-black"></canvas>
</span>
</span>

<span class="layers-item-name">Layer 1</span>
</li>

<li class="layers-item">
<span class="layers-item-eye-container">
<label>
<input type="checkbox" class="layers-item-eye-toggler hidden-toggler" checked autocomplete="off">
<span class="layers-item-eye icon-layers_eye"></span>
</label>
</span>

<span class="layers-item-clipping-mask icon-clipping_mask_arrow"></span>

<span class="layer-preview">
<span class="layers-item-canvas-align">
<canvas width="300" height="200" class="layers-item-canvas bg-checkerboard-small"></canvas>
</span>
</span>

<span class="layers-item-mask">
<span class="layers-item-canvas-align">
<canvas width="300" height="200" class="layers-item-canvas bg-black"></canvas>
</span>
<span class="layers-item-mask-disabled"></span>
</span>

<span class="layers-item-name">Background</span>
</li>
Layers Example end-->
</ul>


<span id="layers_options_bar">
<!--<span class="button button-layers-options" id="add_folder">folder</span>-->
<span class="button layers-options-btn icon-new_layer_btn" id="add_layer" title="Create a layer"></span>
<span class="button layers-options-btn icon-add_layer_mask_btn" id="add_layers_item_mask" title="Mask"></span>
<span class="button layers-options-btn icon-trash_bin" id="delete_layers_item" title="Delete selected object"></span>
</span>

</div><!-- layers container end -->
</div><!-- layers end -->

</div><!-- dock 3 end -->


<!-- dock 4 -->
<div id="dock_4">
<span><!-- <span class="wrap-bottom"> -->
<input type="radio" autocomplete="off" name="toolset" class="tool-btn icon-move_tool" id="move_tool" title="Move Tool (V)">

<span class="tool-spacer"></span>

<input type="radio" autocomplete="off" name="toolset" class="tool-btn icon-auto_select_tool" id="auto_select_tool" title="Auto Select Tool (W)">
<input type="radio" autocomplete="off" name="toolset" class="tool-btn icon-select_tool" id="select_tool" title="Area Selection Tool (M)">
<input type="radio" autocomplete="off" name="toolset" class="tool-btn icon-lasso_tool" id="lasso_tool" title="Lasso Tool (L)">

<span class="tool-spacer"></span>
<input type="radio" autocomplete="off" name="toolset" class="tool-btn icon-brush_tool" id="brush_tool" title="Brush Tool (B)" checked>
<input type="radio" autocomplete="off" name="toolset" class="tool-btn icon-eraser_tool" id="eraser_tool" title="Eraser Tool (E)">

<span class="tool-spacer"></span>
<input type="radio" autocomplete="off" name="toolset" class="tool-btn icon-bucket_tool" id="bucket_tool" title="Fill Tool (G)">
<span id="color_id"></span>
<span class="tool-btn tk-tool-btn icon-cp_dropper_tool" id="cp_dropper_tool" data-toggle="0" title="Eyedropper Tool (hold D or Shift)"></span>
<span class="tool-btn tk-tool-btn icon-color_palette_tool" id="color_palette_tool" data-toggle="0" title="Color Palette (hold C)"><span class="content-abs"></span></span>

<span class="tool-spacer"></span>
<span class="tool-btn tk-tool-btn icon-blend_assist_tool" id="blend_assist_tool" data-toggle="0" title="Blend color with a brush (hold Z)"><span class="content-abs"></span></span>
<span class="tool-btn" id="spree_indicator" title="Spree Draw/Erase toggle (X)"></span>
<span class="tool-spacer"></span>

<span class="tool-btn tool-btn-mini button icon" id="zoom_fit" title="fit canvas in view (Ctrl+0)"><span class="content-abs">fit</span></span>
<span class="tool-btn tool-btn-mini button icon" id="zoom_scale_one" title="zoom 100% / actual pixels"><span class="content-abs">1:1</span></span>
<input type="text" id="zoom_value" autocomplete="off">
<span class="tool-btn tool-btn-mini button icon" id="zoom_toggle" title="toggle zoom and panning between most recent (R)"><span class="content-abs">t</span></span>
<span class="tool-spacer"></span>
<span class="tool-btn tk-tool-btn icon-hand_tool" id="hand_tool" data-toggle="0" title="Hand Tool - touch pinch-zoom, pan, mod keys (hold H or Space)"><span class="content-abs"></span></span>
<span class="tool-spacer"></span>
<span class="tool-btn button icon" id="undo_btn_tool" title="Undo (Ctrl+Z)"></span>
</span>
</div><!-- dock 4 end -->


<!-- dock 5 -->
<div id="dock_5">

<div id="canvasContainer">
<div id="canvas_view_margin">
<div id="canvas_view" class="bg-checkerboard-large general-fade-transition">
<canvas id="liveView" class="visibleCanvas crisp-render"></canvas>
<canvas id="dynamicManipulation" class="visibleCanvas crisp-render"></canvas>

<!-- <canvas id="ts_debug_view" class="visibleCanvas crisp-render"></canvas> -->
<div id="mt_transform_box">
<span id="mt_rotate_handle"></span>
<span id="mt_dpoint_1" class="mt-dpoint"></span>
<span id="mt_dpoint_2" class="mt-dpoint"></span>
<span id="mt_dpoint_2" class="mt-dpoint"></span>
<span id="mt_dpoint_3" class="mt-dpoint"></span>
<span id="mt_dpoint_4" class="mt-dpoint"></span>
<span id="mt_dpoint_5" class="mt-dpoint"></span>
<span id="mt_dpoint_6" class="mt-dpoint"></span>
<span id="mt_dpoint_7" class="mt-dpoint"></span>
<span id="mt_dpoint_8" class="mt-dpoint"></span>
</div><!-- mt_transform_box end -->

</div>
</div>

<div class="sticky-container">
<canvas id="selectionView" class="visibleCanvas crisp-render"></canvas>
<canvas id="selectionDynamicView" class="visibleCanvas crisp-render"></canvas>
<canvas id="dynamicUI" class="visibleCanvas crisp-render"></canvas>
</div>

<div class="sticky-container">
<div id="canvas_draw_screen"></div>
</div>

<!-- module action screens (ones that need separate screen above draw screen -->
<!-- screen layer 1 -->

<div id="stamp_sample_screen" class="sticky-screen"></div>

<div id="cp_dropper_screen" class="sticky-screen"></div>

<div id="brush_size_screen" class="sticky-screen">
<div id="quick_zoom_panel">
<span id="zoom_out_knob"><span id="zoom_out_knob_icon" class="icon-zoom_out_knob">-</span><span class="content-abs"></span></span>
<span id="zoom_in_knob"><span id="zoom_in_knob_icon" class="icon-zoom_in_knob">+</span><span class="content-abs"></span></span>
</div>
</div>

<canvas id="refLayer" class="visibleCanvas crisp-render sticky-screen"></canvas>

<div id="canvas_pan_screen" class="sticky-screen">
<div id="touch_key_panel"><!-- touch mod keys -->
<!--
<div class="tk-panel-row">
<span class="tk-panel-btn" id="tk_undo"></span><span class="tk-panel-btn" id="tk_redo"></span>
</div>
-->
<div class="tk-panel-row">
<span class="tk-panel-btn" id="tk_ctrl" data-toggle="0">Ctrl</span><span class="tk-panel-btn" id="tk_alt" data-toggle="0">Alt</span>
</div>
<div class="tk-panel-row">
<span class="tk-panel-btn" id="tk_shift" data-toggle="0">Shift</span>
</div>
</div><!-- touch mod keys end -->
</div><!-- pan screen end -->

<!-- screen layer 2 -->
<div id="mt_action_screen" class="sticky-screen"></div>
<div id="file_loading_screen" class="sticky-screen"><span id="file_loading_screen_text">Loading...</span></div>
<div id="canvas_loading_screen" class="sticky-screen"><span id="canvas_loading_screen_text">Loading...</span></div>
<!-- module action screens end -->

</div>


</div><!-- dock 5 end -->

</div><!-- app_grid end -->

<!-- docks screen lock -->
<div class="screen-lock" id="global_cf_menu_lock_screen"></div>
<!-- docks screen lock end -->

<!-- feature menus -->

<!-- adjustments / color filter menu -->

<div class="fm-general" id="color_filter_menu">
<div class="fm-cell-container">

<span class="fm-cell text-align-right">
<span class="button fm-cell-btn" id="cf_apply_btn">Apply</span>
<span class="button fm-cell-btn" id="cf_cancel_btn">Cancel</span>
</span>

<span class="fm-cell">
<span class="button fm-cell-btn" id="cf_reset_values_btn">Reset</span>
<label title="remember / carry forward adjustments settings">
<input type="checkbox" class="hidden-toggler" id="cf_mem">
<span class="fm-cell-btn cf-menu-btn float-right" id="cf_mem_btn" autocomplete="off">mem</span>
</label>
<span class="float-right fm-cell-btn"><label><input id="cf_preview" type="checkbox" autocomplete="off"> Preview</label></span>
</span>
<span class="fm-cell">
<span class="fm-cell-name float-left">Hue</span>
<input class="float-right" id="cf_hue_value" type="number" min="-180" max="180" value=0 autocomplete="off">
<input id="cf_hue_slider" type="range" min="-180" max="180" value=0 autocomplete="off">
<span><label><input id="cf_desat_hue" type="checkbox" autocomplete="off"> Colorize Grayscale</label></span>
</span>

<span class="fm-cell">
<span class="fm-cell-name float-left">Saturation</span>
<input class="float-right" id="cf_saturation_value" type="number" min="-100" max="100" value=0 autocomplete="off">
<input id="cf_saturation_slider" type="range" min="-100" max="100" value=0 autocomplete="off">
</span>

<span class="fm-cell">
<span class="fm-cell-name float-left">Brightness</span>
<input class="float-right" id="cf_brightness_value" type="number" min="-100" max="100" value=0 autocomplete="off">
<input id="cf_brightness_slider" type="range" min="-100" max="100" value=0 autocomplete="off">
</span>

<span class="fm-cell">
<span class="fm-cell-name float-left">Gamma</span>
<input class="float-right" id="cf_gamma_value" type="number" min="0.10" max="9.9" value=1 step="0.01" autocomplete="off">
<input id="cf_gamma_slider" type="range" min="-900" max="899" step="1" value=0 autocomplete="off">
</span>

<!--<span class="fm-cell-spacer"></span>-->

<span class="fm-cell">
<span class="fm-cell-name float-left">Light</span>
<input class="float-right" id="cf_softlight_value" type="number" min="-50" max="50" value=0 autocomplete="off">
<input id="cf_softlight_slider" type="range" min="-50" max="50" value=0 autocomplete="off">
<!--
<input class="float-right" id="cf_hardlight_value" type="number" min="-50" max="50" value=0 autocomplete="off">
<input id="cf_hardlight_slider" type="range" min="-50" max="50" value=0 autocomplete="off">
-->
</span>

<span class="fm-cell">
<span class="fm-cell-name float-left">Vibrance</span>
<input class="float-right" id="cf_vibrance_value" type="number" min="-50" max="50" value=0 autocomplete="off">
<input id="cf_vibrance_slider" type="range" min="-50" max="50" value=0 autocomplete="off">
</span>

<span class="fm-cell">
<span class="fm-cell-name float-left">Contrast</span>
<input class="float-right" id="cf_contrast_value" type="number" min="-50" max="50" value=0 autocomplete="off">
<input id="cf_contrast_slider" type="range" min="-50" max="50" value=0 autocomplete="off">
</span>


<!-- effect limits -->
<span class="fm-cell">
<span class="button fm-cell-btn" id="cf_reset_ranges_btn">Reset</span>
<span class="fm-cell-name float-right">Effect Area</span>
</span>


<span class="fm-cell">
<span class="fm-cell-name float-left">Hue</span>
<span class="text-align-right">
<input id="cf_hue_limit_lower_value" type="number" min="0" max="360" value=0 autocomplete="off">
<input id="cf_hue_limit_upper_value" type="number" min="0" max="360" value=360 autocomplete="off">
</span>
<span>
<input id="cf_hue_limit_lower_slider" type="range" min="0" max="360" value=0 autocomplete="off">
<input id="cf_hue_limit_upper_slider" type="range" min="0" max="360" value=360 autocomplete="off">
</span>
</span>

<span class="fm-cell">
<span class="fm-cell-name float-left">Saturation</span>
<span class="text-align-right">
<input id="cf_saturation_limit_lower_value" type="number" min="0" max="100" value=0 autocomplete="off">
<input id="cf_saturation_limit_upper_value" type="number" min="0" max="100" value=100 autocomplete="off">
</span>
<span>
<input id="cf_saturation_limit_lower_slider" type="range" min="0" max="100" value=0 autocomplete="off">
<input id="cf_saturation_limit_upper_slider" type="range" min="0" max="100" value=100 autocomplete="off">
</span>
</span>

<span class="fm-cell">
<span class="fm-cell-name float-left">Brightness</span>
<span class="text-align-right">
<input id="cf_brightness_limit_lower_value" type="number" min="0" max="100" value=0 autocomplete="off">
<input id="cf_brightness_limit_upper_value" type="number" min="0" max="100" value=100 autocomplete="off">
</span>
<span>
<input id="cf_brightness_limit_lower_slider" type="range" min="0" max="100" value=0 autocomplete="off">
<input id="cf_brightness_limit_upper_slider" type="range" min="0" max="100" value=100 autocomplete="off">
</span>
</span>

</div>
<span class="drag-bar" id="cf_drag_bar"><span class="drag-bar-name">Adjustments</span></span>
</div>
<!-- adjustments / color filter menu end -->

<!-- brush preset library -->
<div class="fm-general" id="brush_preset_lib">
<!-- menu section -->
<div class="fm-lib-section">
<!-- brush preset item -->
<ul id="brush_preset_container">

<!-- sample brush preset
<li>
<label>
<input type="radio" name="brush-preset-item-group" class="hidden-toggler brush-preset-item-btn">
<span class="brush-preset-item">
<img class="brush-preset-item-icon" src="resources/icons/pic.png">
<span class="brush-preset-item-name">Brush preset 1</span>
</span>
</label>
</li>
-->

<span class="fm-list-bottom-spacer"></span>
</ul><!-- brush preset item end-->

<!-- brush preset config container -->
<div id="brush_preset_config_container" class="touch-scrollable">
<div class="fm-cell-container text-align-right touch-scrollable">
<span class="fm-cell">
<span class="fm-cell-name float-left">Preset name:</span> <input id="brush_preset_config_name" type="text" autocomplete="off">
</span>

<span class="fm-cell">
<span class="fm-cell-name float-left">Size: </span><input id="brush_preset_size_value" type="number" min="1" value=1 autocomplete="off">
<input id="brush_preset_size_slider" type="range" min="1" max="350" value=1 autocomplete="off">
</span>

<span class="fm-cell">
<span class="fm-cell-name float-left">Opacity: </span><input id="brush_preset_opacity_value"  type="number" min="1" max="100" value=1 autocomplete="off">
<input id="brush_preset_opacity_slider" type="range" min="1" max="100" value=1 autocomplete="off">
</span>

<span class="fm-cell">
<span class="fm-cell-name float-left">Flow: </span><input id="brush_preset_flow_value"  type="number" min="1" max="100" value=1 autocomplete="off">
<input id="brush_preset_flow_slider" type="range" min="1" max="100" value=1 autocomplete="off">
</span>

<span class="fm-cell">
<label title="Defines hardness/feathering of a brush tip edge. Only for default brush tip."><span class="fm-cell-name float-left">Hardness: </span></label><input id="brush_preset_hardness_value"  type="number" min="0" max="100" value=0 autocomplete="off">
<input id="brush_preset_hardness_slider" type="range" min="0" max="100" value=0 autocomplete="off">
</span>

<span class="fm-cell">
<span class="fm-cell-name float-left">Spacing %: </span><input id="brush_preset_spacing_value"  type="number" min="1" value=1 autocomplete="off">
<input id="brush_preset_spacing_slider" type="range" min="1" max="100" value=1 autocomplete="off">
</span>

<span class="fm-cell text-align-left">
<span>Brush Tip</span>
<label title="Use a chosen image as a brush tip. Choose an image">Custom <input type="radio" class="radio-btn" id="brush_preset_brush_type_custom" name="bp_brush_type" value="custom" autocomplete="off"></label>
<label title="Use default round brush tip. This tip has adjustable hardness">Default <input type="radio" class="radio-btn" id="brush_preset_brush_type_default" name="bp_brush_type" value="default" autocomplete="off"></label>
<input type="file" id="brush_preset_custom_tip_file" accept=".png, .jpg, .jpeg, .gif, .bmp, .webp, .webm, .svg">
</span>

<span class="fm-cell">
<label>Direction: <input id="brush_preset_direction" type="checkbox" autocomplete="off"></label>
</span>

<span class="fm-cell">
<span><label>Pen pressure size: <input id="brush_preset_size_pressure" type="checkbox" autocomplete="off"></label></span>
<span><label title="Minimum brush size, when pen pressure size is enabled, as a percentage. Will retain 1px minimum if set to 0.">Min diameter %: <input id="brush_preset_size_pressure_min_d"  type="number" min="0" max="100" value=1 autocomplete="off"></label></span>
</span>


<span class="fm-cell">
<label>Pen pressure flow: <input id="brush_preset_flow_pressure" type="checkbox" autocomplete="off"></label>
</span>

<span class="fm-cell">
<label title="Adds a 3x3 pixel eyedropper to the center of brush tip. Averages color in sample area and adds it to a brush trail mix. Checked means blend by default. Hold (Z) key to toggle state on any brush when drawing">
Blend assist: <input id="brush_preset_blend_assist" type="checkbox" autocomplete="off"></label>
</span>

<span class="fm-list-bottom-spacer"></span>

<span class="fm-cell">
<label title="Adds random rotation to brush tip, within given angle (0 to 360), half the angle one side and half the other.">
Orientation angle &#176; Jitter: <input id="brush_preset_angle_jitter"  type="number" min="0" max="360" step=10 value=0 autocomplete="off">
</label>
</span>

<span class="fm-cell">
<label title="Chance to flip brush tip horizontally / x-axis">
Flip horizontal Jitter: <input id="brush_preset_flip_x_jitter" type="checkbox" autocomplete="off">
</label>
</span>

<span class="fm-cell">
<label title="Chance to flip brush tip vertically / y-axis">
Flip vertical Jitter: <input id="brush_preset_flip_y_jitter" type="checkbox" autocomplete="off">
</label>
</span>

<span class="fm-cell"><label title="Turns brush tip into a particle">Particle</label></span>

<span class="fm-cell">
<label title="Percentage of brush radius, as a scatter distance both axes (0 to 1000)">
Scatter distance: <input id="brush_preset_scatter_distance"  type="number" min="0" max="1000" step=10 value=0 autocomplete="off">
</label>
</span>

<span class="fm-cell">
<label title="Size jitter - smallest particle size, as a percentage of brush size (0 to 100)">
Min size %: <input id="brush_preset_scatter_size_jitter"  type="number" min="0" max="100" step=5 value=100 autocomplete="off">
</label>
</span>

<span class="fm-cell">
<label title="Scales tip width or height at random, down to a set minimal">
Roundness (Min scale %): <input id="brush_preset_roundness_jitter"  type="number" min="0" max="100" step=5 value=0 autocomplete="off">
</label>
</span>

<span class="fm-cell">
<label title="Particle count per each brush movement(according to spacing)">
Count: <input id="brush_preset_scatter_count"  type="number" min="1" max="16" value=1 autocomplete="off">
</label>

<label title="Variation in particle count at random, deducting jitter value from count">
Jitter: <input id="brush_preset_scatter_count_jitter"  type="number" min="0" max="16" value=0 autocomplete="off">
</label>
</span>

<span class="fm-list-bottom-spacer"></span>

</div>
</div><!-- brush preset config container end -->
</div><!-- menu section end -->

<!-- action panel -->
<div class="fm-lib-action-panel">
<span class="button fm-lib-a-p-btn" id="brush_preset_new_btn">+</span>
<span class="button fm-lib-a-p-btn" id="brush_preset_use_btn">use</span>

<span class="button fm-lib-a-p-btn" id="brush_preset_duplicate_btn">duplicate</span>
<span class="button fm-lib-a-p-btn" id="brush_preset_capture_bay_btn" title="bay capture / brush preset from bay">bay-c</span>
<span class="button fm-lib-a-p-btn" id="brush_preset_capture_layer_btn" title="layer capture / brush preset from layer">layer-c</span>

<span class="button fm-lib-a-p-btn" id="brush_preset_delete_btn"> delele </span>

<span class="button fm-lib-a-p-btn" id="brush_preset_import_btn">import</span>
<span class="button fm-lib-a-p-btn" id="brush_preset_export_btn">export</span>

<span class="button fm-lib-a-p-btn" id="brush_preset_close_btn">close</span>
</div><!-- action panel end -->

<span class="drag-bar" id="bpl_drag_bar"><span class="drag-bar-name">Brush Library</span></span>

</div><!-- brush preset library end -->


<!-- ref layer library -->
<div class="fm-general" id="ref_layer_lib">
<!-- menu section -->
<div class="fm-lib-section">
<!-- ref layer preset item -->
<ul id="ref_layer_preset_container">

<!-- sample ref layer preset
<li>
<label>
<input type="radio" name="ref-layer-preset-item-group" class="hidden-toggler ref-layer-preset-item-btn" autocomplete="off">
<span class="ref-layer-preset-item">
<span class="ref-layer-preset-item-name">Palette 1 test long name to wrapping to second line</span>
</span>
</label>
</li>
-->

</ul><!-- ref layer preset item end -->

<!-- ref layer preset config container -->
<div id="ref_layer_preset_config_container">
<div class="fm-cell-container">
<span class="fm-cell text-align-right">
<span class="fm-cell-name float-left">Preset name:</span> <input id="ref_layer_preset_config_name" type="text" autocomplete="off">
</span>

<span id="ref_layer_config_preview_container">
<canvas id="ref_layer_config_preview" class="crisp-render"></canvas>
</span>

<span class="fm-cell text-align-center">
<span class="fm-cell-name">Align:</span>
<label><input class="hidden-toggler ref-layer-config-align-btn" value="left" id="ref_layer_config_align_left" type="radio" name="ref-layer-config-align-group"><span class="fm-cell-btn ref-layer-config-align">left</span></label>
<label><input class="hidden-toggler ref-layer-config-align-btn" value="center" id="ref_layer_config_align_center" type="radio" name="ref-layer-config-align-group"><span class="fm-cell-btn ref-layer-config-align">center</span></label>
<label><input class="hidden-toggler ref-layer-config-align-btn" value="right" id="ref_layer_config_align_right" type="radio" name="ref-layer-config-align-group"><span class="fm-cell-btn ref-layer-config-align">right</span></label>
</span>

<span class="fm-cell text-align-center overflow-hidden">
<input type="file" id="ref_layer_preset_img_file" accept=".png, .jpg, .jpeg, .gif, .bmp, .webp, .webm, .svg">
</span>

<span class="fm-list-bottom-spacer"></span>

</div>
</div><!-- ref layer preset config container end -->
</div><!-- menu section end -->

<!-- action panel -->
<div class="fm-lib-action-panel">
<span class="button fm-lib-a-p-btn" id="ref_layer_preset_new_btn">+</span>
<span class="button fm-lib-a-p-btn" id="ref_layer_preset_use_btn" title="to access the palette layer - hold (C)">use</span>

<label title="Make preset favorite. Preset is moved to the first spot in the list and will be used by default.">
<span class="button fm-lib-a-p-btn" id="ref_layer_preset_fav_btn">fav</span>
</label>

<label title="Captures current view of the palette layer into a new preset">
<span class="button fm-lib-a-p-btn" id="ref_layer_preset_capture_btn">capture</span>
</label>

<span class="button fm-lib-a-p-btn" id="ref_layer_preset_delete_btn">delete</span>

<label title="Export the image">
<span class="button fm-lib-a-p-btn" id="ref_layer_preset_export_btn">export</span>
</label>

<span class="button fm-lib-a-p-btn" id="ref_layer_preset_close_btn">close</span>
</div><!-- action panel end -->

<span class="drag-bar" id="rlp_drag_bar"><span class="drag-bar-name">Palette Library</span></span>

</div><!-- ref layer library end -->


<!-- color picker -->
<div class="fm-general" id="color_picker_menu">
<div class="div-relative-wrap">

<div id="color_picker_field_container">
<div class="color-picker-field" id="cpf_hue_sb"></div>
<div class="color-picker-field" id="cpf_selector"><div id="cpf_selector_cursor"></div></div>
</div>

<div id="color_picker_hue_container">
<div class="cpf-hue-field" id="cpf_hue_gradient"></div>
<div class="cpf-hue-field" id="cpf_hue_selector"><div id="cpf_hue_selector_cursor"></div></div>
</div>

<div id="color_picker_sample_container">
<div id="cp_sample"></div>
</div>

<div id="color_picker_input_panel">
<span class="fm-cell text-align-right">
<span class="button fm-cell-btn" id="cp_apply">Apply</span>
<span class="button fm-cell-btn" id="cp_close">Close</span>
</span>

<span class="fm-cell">

<label title="Apply color upon selection">
<span class="text-align-right">
auto apply: <input id="cp_auto_apply" type="checkbox" checked>
</span>
</label>

<label title="When enabled eyedropper tool picks color from selected layer at maximum opacity rather than from what can be seen on canvas"> 
<span class="text-align-right">
dropper layer mode: <input id="cp_dropper_mode" type="checkbox">
</span>
</label>
</span>

<span class="fm-cell">
<span><span class="cp-input-label">H</span><input type="text" size="3" id="cp_hue_input">&#176;</span>
<span><span class="cp-input-label">S</span><input type="text" size="3" id="cp_saturation_input">%</span>
<span><span class="cp-input-label">B</span><input type="text" size="3" id="cp_brightness_input">%</span>
</span>
<span class="fm-cell">
<span><span class="cp-input-label">R</span><input type="text" size="3" id="cp_r_input"></span>
<span><span class="cp-input-label">G</span><input type="text" size="3" id="cp_g_input"></span>
<span><span class="cp-input-label">B</span><input type="text" size="3" id="cp_b_input"></span>
<span><span class="cp-input-label">#</span><input type="text" size="6" id="cp_hex_input"></span>
</span>
</div>

<span class="drag-bar" id="cp_drag_bar"></span>

</div>
</div><!-- color picker end -->


<!-- canvas size -->
<div class="fm-general" id="doc_canvas_size">
<div class="fm-lib-section">
<span class="fm-general-name">Canvas Size</span>

<span class="doc_cs_config0">
<span class="fm-cell-container">
<span class="fm-cell fm-cell-name text-align-center">Dimensions</span>
<span class="fm-cell">
Width: <input type="text" id="doc_cs_width"> px
</span>
<span class="fm-cell">
Height: <input type="text" id="doc_cs_height"> px
</span>


<span class="fm-cell">
<label title="Keeps dimensions proportional to the current document">
<input type="checkbox" id="doc_cs_aspect_lock"> Relative
</label>
</span>

</span>
</span>

<span class="doc_cs_config1">
<span class="fm-cell-container">
<span class="fm-cell fm-cell-name">Anchor</span>
<span class="fm-cell text-align-center">

<span id="doc_cs_anchor_btn_container">
<span class="content-abs">
<input type="radio" name="doc_cs_anchor_group" value="1" class="doc-cs-anchor-btn">
<input type="radio" name="doc_cs_anchor_group" value="2" class="doc-cs-anchor-btn">
<input type="radio" name="doc_cs_anchor_group" value="3" class="doc-cs-anchor-btn">
<input type="radio" name="doc_cs_anchor_group" value="4" class="doc-cs-anchor-btn">
<input type="radio" name="doc_cs_anchor_group" value="5" class="doc-cs-anchor-btn" checked>
<input type="radio" name="doc_cs_anchor_group" value="6" class="doc-cs-anchor-btn">
<input type="radio" name="doc_cs_anchor_group" value="7" class="doc-cs-anchor-btn">
<input type="radio" name="doc_cs_anchor_group" value="8" class="doc-cs-anchor-btn">
<input type="radio" name="doc_cs_anchor_group" value="9" class="doc-cs-anchor-btn">
</span>
</span>

</span>
</span>
</span>

</div>

<div class="fm-lib-action-panel">
<span class="button fm-lib-a-p-btn fm-lib-a-p-apply-btn" id="doc_cs_apply_btn">Apply</span>
<span class="button fm-lib-a-p-btn fm-lib-a-p-close-btn" id="doc_cs_close_btn">Close</span>
</div>

</div><!-- canvas size end -->

<!-- image size -->
<div class="fm-general" id="doc_image_size">
<div class="fm-lib-section">
<span class="fm-general-name">Image Size</span>

<span class="doc_imgs_config0">
<span class="fm-cell-container">
<span class="fm-cell fm-cell-name text-align-center">Dimensions</span>
<span class="fm-cell">
Width: <input type="text" id="doc_imgs_width"> px
</span>
<span class="fm-cell">
Height: <input type="text" id="doc_imgs_height"> px
</span>


<span class="fm-cell">
<label title="Keeps dimensions proportional to the current document">
<input type="checkbox" id="doc_imgs_aspect_lock" checked autocomplete="off"> Relative
</label>
</span>

</span>
</span>

<span class="doc_imgs_config1">
<span class="fm-cell-container">
<span class="fm-cell fm-cell-name">Options</span>
<span class="fm-cell">
<label title="Smoothes image while resizing">
<input type="checkbox" id="doc_imgs_antialias" checked autocomplete="off"> Anti-aliasing
</label>
</span>
</span>
</span>

</div>

<div class="fm-lib-action-panel">
<span class="button fm-lib-a-p-btn fm-lib-a-p-apply-btn" id="doc_imgs_apply_btn">Apply</span>
<span class="button fm-lib-a-p-btn fm-lib-a-p-close-btn" id="doc_imgs_close_btn">Close</span>
</div>

</div><!-- image size end -->

<!-- make new document -->
<div class="screen-lock general-fade-transition" id="global_doc_new_menu_lock_screen"></div>
<div class="fm-general" id="doc_new">
<div class="fm-lib-section">
<span class="fm-general-name text-align-center">Create new document</span>

<span class="fm-cell-container">
<span class="fm-cell text-align-center">
<span class="display-inline-block"><span class="fm-cell-field-name">Project name:</span><input type="text" id="doc_new_name" value="Untitled-1"></span>
</span>
</span>

<span class="doc_new_config0">
<span class="fm-cell-container">
<span class="fm-cell fm-cell-name">Dimensions</span>
<span class="fm-cell">
<label>Width:<input type="text" id="doc_new_width"></label>
</span>
<span class="fm-cell">
<label>Height:<input type="text" id="doc_new_height"></label>
</span>


<span class="fm-cell">
<span id="doc_new_units_container">
<label><input class="hidden-toggler doc-new-units-btn" value="px" id="doc_new_units_px" type="radio" name="doc_new_units" autocomplete="off" checked><span class="doc-new-units">px</span></label>
<label><input class="hidden-toggler doc-new-units-btn" value="cm" id="doc_new_units_cm" type="radio" name="doc_new_units" autocomplete="off"><span class="doc-new-units">cm</span></label>
<label><input class="hidden-toggler doc-new-units-btn" value="in" id="doc_new_units_in" type="radio" name="doc_new_units" autocomplete="off"><span class="doc-new-units">in</span></label>
</span>
</span>

<span class="fm-cell">
<label><input class="doc-new-orientation-btn" value="landscape" id="doc_new_orientation_landscape" type="radio" name="doc_new_orientation" autocomplete="off" checked></label>
<label><input class="doc-new-orientation-btn" value="portrait" id="doc_new_orientation_portrait" type="radio" name="doc_new_orientation" autocomplete="off"></label>
</span>

<span class="fm-cell">
PPI: <input type="text" id="doc_new_dpi" autocomplete="off" value="300">
</span>

</span>
</span>

<span class="doc_new_config1">
<span class="fm-cell fm-cell-name text-align-right"></span>
<div id="doc_new_presets" class="touch-scrollable">

<!-- recent presets field -->
<span id="doc_new_presets_recent">
<!-- example group and tile 
<span class="doc-new-presets-group">
<span class="doc-new-presets-group-name">Recent</span>

<label>
<input class="hidden-toggler doc-new-presets-tile-btn" value="1" type="radio" name="doc_new_presets_tile" autocomplete="off">
<span class="doc-new-presets-tile">
<span class="doc-new-presets-tile-description">
<span class="doc-new-presets-tile-name">1440p</span>
<span class="doc-new-presets-tile-dimensions">2560 x 1440</span>
<span class="doc-new-presets-tile-units">px @ 72 ppi</span>
</span>
</span>
</label>

</span>
-->
</span><!-- recent presets field end -->

<!-- general presets field -->
<span id="doc_new_presets_general">

</span><!-- general presets field end -->

</div><!-- presets area end -->
</span>

</div>

<div class="fm-lib-action-panel">
<span class="button fm-lib-a-p-btn" id="doc_new_create_btn">Create</span>
<span class="button fm-lib-a-p-btn" id="doc_new_open_btn">Open</span>
<span class="button fm-lib-a-p-btn fm-lib-a-p-close-btn" id="doc_new_close_btn">Close</span>
</div>

</div><!-- make new document end -->

<!-- save as file -->
<div class="fm-general" id="save_as_file_menu">
<div class="fm-lib-section">



<span class="text-align-center">
<span class="saf-menu-option-cell">
<span class="saf-menu-option-btn" id="saf_menu_option_png_btn" title="PNG">
<span class="file-format-icon"></span>
</span>
</span>

<span class="saf-menu-option-cell">
<span class="saf-menu-option-btn" id="saf_menu_option_jpg_btn" title="JPEG">
<span class="file-format-icon"></span>
</span>
<input id="saf_menu_option_jpg_quality_slider" type="range" min="0" max="1" step="0.1" title="JPEG Quality (0 to 10)" value="1">
</span>

<span class="saf-menu-option-cell">
<span class="saf-menu-option-btn" id="saf_menu_option_project_btn" title="Project">
<span class="file-format-icon"></span>
</span>
</span>
</span>

<span class="fm-cell text-align-right">
Document name:<input type="text" id="saf_menu_doc_name" autocomplete="off" value="Untitled-1">
</span>

</div>

<div class="fm-lib-action-panel">
<span class="button fm-lib-a-p-btn fm-lib-a-p-close-btn" id="saf_menu_close_btn">Close</span>
</div>

</div><!-- save as file end -->


<!-- manual menu -->
<div class="fm-general" id="manual_menu">
<div class="fm-lib-section">

<div id="manual_index">
<ul id="manual_index_link_container">

<!-- sample page link
<li class="manual-index-link" data-page_id="welcome" data-selected="0">
Welcome
</li> -->

<!-- sample spacer 
<span class="manual-index-spacer"></span> -->

<!-- sample category
<span class="manual-index-category"></span> -->

</ul>
</div>

<div id="manual_page_view">
<div id="manual_page_container"  class="general-fade-transition">

</div>
</div>

</div>

<div class="fm-lib-action-panel">
<span class="button fm-lib-a-p-btn fm-lib-a-p-close-btn" id="manual_menu_close_btn">Close</span>
</div>
<span class="drag-bar" id="manual_menu_drag_bar"><span class="drag-bar-name">Manual</span></span>
</div><!-- manual menu end -->


<!-- about -->
<div class="fm-general" id="about">
<div class="fm-lib-section">

<div id="about_content_container">
<section>
<h1 id="about_program_name">Light Brush<span class="about-trademark">&trade;</span></h1>
<h2 id="about_program_version">Version 1.1.3</h2>
<p>
<span class="about-color-3">by God's Grace, in His Name and Glory</span>
<span class="display-inline about-color-2">made by </span>Dmitriy Burmistrov
</p>

<p>
<br>
<strong class="about-color-2">Credits:</strong>
<div id="about_credits">
Special thanks to my mother  for being with me.     .<br>
<br>
</div>
</p>

<p>
<br>
<a href="https://www.light-brush.art" target="_blank">https://www.light-brush.art</a>
<br>
&copy; 2019, 2022
</p>
</section>
</div>

</div>

<div class="fm-lib-action-panel">
<span class="button fm-lib-a-p-btn fm-lib-a-p-close-btn" id="about_close_btn">Close</span>
</div>

</div><!-- about end -->


<!-- hotkeys list -->
<div class="fm-general" id="hk_list">
<div class="fm-lib-section">
<ul class="fm-cell-container" id="hk_list_item_container">

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Quick Menu <br>(zoom &amp; brush size)</span>
<span class="hkl-item-bind-description">hold <span class="hkl-item-bind-keytag">Q</span> and move cursor 
<br>left or right to adjust brush size. 
<br>Also press &quot;-&quot; and &quot;+&quot; buttons to zoom in and out</span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Blending</span>
<span class="hkl-item-bind-description">hold <span class="hkl-item-bind-keytag">Z</span> to toggle color blending</span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Color Palette</span>
<span class="hkl-item-bind-description">hold <span class="hkl-item-bind-keytag">C</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Copy</span>
<span class="hkl-item-bind-description">
<span class="hkl-item-bind-keytag">Ctrl</span> + <span class="hkl-item-bind-keytag">C</span>
</span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Cut</span>
<span class="hkl-item-bind-description">
<span class="hkl-item-bind-keytag">Ctrl</span> + <span class="hkl-item-bind-keytag">X</span>
</span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Paste</span>
<span class="hkl-item-bind-description">
<span class="hkl-item-bind-keytag">Ctrl</span> + <span class="hkl-item-bind-keytag">V</span>
</span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Delete selected area</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">Delete</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Undo</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">Ctrl</span> + <span class="hkl-item-bind-keytag">Z</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Redo</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">Ctrl</span> + <span class="hkl-item-bind-keytag">Shift</span> + <span class="hkl-item-bind-keytag">Z</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Save As</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">Ctrl</span> + <span class="hkl-item-bind-keytag">S</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Color Picker</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">F</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Spree Mode</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">X</span> to toggle</span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Solidify Spree</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">Shift</span> + <span class="hkl-item-bind-keytag">S</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Select Content</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">Ctrl</span> + <span class="hkl-item-bind-keytag">A</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Selection Toggle</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">Ctrl</span> + <span class="hkl-item-bind-keytag">D</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Selection from Spree</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">Ctrl</span> + <span class="hkl-item-bind-keytag">B</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Zoom Toggle</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">R</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Zoom Fit</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">Ctrl</span> + <span class="hkl-item-bind-keytag">0</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Hand / Touch</span>
<span class="hkl-item-bind-description">hold <span class="hkl-item-bind-keytag">H</span> or <span class="hkl-item-bind-keytag">Space</span></span>
</li>

<li class="fm-cell text-align-center">
Tools
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Move Tool</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">V</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Auto Select Tool</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">W</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Area Selection Tool</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">M</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Lasso Tool</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">L</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Brush Tool</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">B</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Eraser Tool</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">E</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Bay select</span>
<span class="hkl-item-bind-description">use <span class="hkl-item-bind-keytag"> 1, 2, ... 8 </span> keys</span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Fill Tool</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">G</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Eyedropper</span>
<span class="hkl-item-bind-description">hold <span class="hkl-item-bind-keytag">D</span> or <span class="hkl-item-bind-keytag">Shift</span><br>
note: in some tools the shift key may have other functions
</span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Stamp Brush Sample</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">O</span> while Brush Tool active &amp; hovering over the desired area</span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Tool Toggle</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">`</span> alternatively press the key of currently active tool</span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Nudge <br>(selection or content)</span>
<span class="hkl-item-bind-description"> use arrow keys <br>
<span class="hkl-item-bind-keytag">&#8592;</span>
<span class="hkl-item-bind-keytag">&#8593;</span>
<span class="hkl-item-bind-keytag">&#8594;</span>
<span class="hkl-item-bind-keytag">&#8595;</span>
</span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Brush size - / +</span>
<span class="hkl-item-bind-description">hold <span class="hkl-item-bind-keytag">[</span> / <span class="hkl-item-bind-keytag">]</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Modifiers</span>
<span class="hkl-item-bind-description">
Some tools use keys as modifiers to alter default behavior of a tool. 
<br>See User Manual for tool-specific modifier information.
<br>Typically modifier keys are 
<br><span class="hkl-item-bind-keytag">Ctrl</span>
<span class="hkl-item-bind-keytag">Shift</span>
<span class="hkl-item-bind-keytag">Alt</span></span>
</li>

<li class="fm-cell text-align-center">
&nbsp;
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Invert Colors</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">Ctrl</span> + <span class="hkl-item-bind-keytag">I</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Adjustments</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">Ctrl</span> + <span class="hkl-item-bind-keytag">U</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">B&amp;W</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">Ctrl</span> + <span class="hkl-item-bind-keytag">Shift</span> + <span class="hkl-item-bind-keytag">U</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Desaturate</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">Ctrl</span> + <span class="hkl-item-bind-keytag">Shift</span> + <span class="hkl-item-bind-keytag">O</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Duplicate Layer</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">Ctrl</span> + <span class="hkl-item-bind-keytag">J</span></span>
</li>

<li class="fm-cell hkl-item">
<span class="hkl-item-action">Flip Canvas Horizontally</span>
<span class="hkl-item-bind-description"><span class="hkl-item-bind-keytag">Ctrl</span> + <span class="hkl-item-bind-keytag">M</span></span>
</li>


<li class="fm-cell text-align-center">
note: Mac users may use<br> &#8984; instead of Ctrl<br> Option instead of Alt.
</li>

</ul><!-- hk_list_item_container end -->
</div>

<div class="fm-lib-action-panel">
<span class="button fm-lib-a-p-btn fm-lib-a-p-close-btn" id="hk_list_close_btn">Close</span>
</div>
<span class="drag-bar" id="hkl_drag_bar"><span class="drag-bar-name">Hotkeys</span></span>
</div><!-- hotkeys list end -->

<!-- feature menus end -->

<!-- dialog box -->
<div id="dialog_box" class="fm-general">
<div class="fm-cell-container">
<div id="dialog_box_text" class="fm-cell">
<!-- Save changes to the project "Untitled-1" before closing? -->
</div>
</div>

<div id="dialog_box_options" class="fm-cell-container">
<!-- button pool -->
<span class="button fm-lib-a-p-btn" data-option-value="blank">Blank</span>
<span class="button fm-lib-a-p-btn" data-option-value="blank">Blank</span>
<span class="button fm-lib-a-p-btn" data-option-value="blank">Blank</span>
<span class="button fm-lib-a-p-btn" data-option-value="blank">Blank</span>
<span class="button fm-lib-a-p-btn" data-option-value="blank">Blank</span>
<span class="button fm-lib-a-p-btn" data-option-value="blank">Blank</span>
<span class="button fm-lib-a-p-btn" data-option-value="blank">Blank</span>
<span class="button fm-lib-a-p-btn" data-option-value="blank">Blank</span>
<span class="button fm-lib-a-p-btn" data-option-value="blank">Blank</span>
<span class="button fm-lib-a-p-btn" data-option-value="blank">Blank</span>
</div>
<span class="fm-cell-spacer"></span>
<span class="drag-bar" id="dialog_box_drag_bar"></span>
</div><!-- dialog box end -->



<!-- global screens-->
<span class="global-screen" id="cp_bs_screen"></span>
<span class="global-screen" id="cp_hue_screen"></span>
<span class="global-screen" id="dragWindow_screen"></span>
<!-- global screens end-->

</div><!-- container end -->
















<script src="userConfigDefault.js" type="text/javascript"></script>
<script>
/* 
Light Brush - Digital Painting, Art Creation Application
Copyright (c) 2019 Dmitriy A. Burmistrov
*/

const PROGRAM_NAME = "Light Brush";
const PROGRAM_VERSION = [1,1,3,""];//program version format:
//^ [Major release, Update, Minor, Signifying string "a"/"b" for alpha or beta etc]
const PROJECT_FORMAT = "lbc";//Light Brush Canvas
var MANUAL_USER_EXIT = false;//manual program exit flag, e.g. File->Exit

const isChromium = !!window.chrome;//check to see if browser is chromium
//Clipboard handling binds
function retrieveImageFromClipboardAsBlob(pasteEvent, callback){
	if(pasteEvent.clipboardData == false){
        if(typeof(callback) == "function"){
            callback(undefined);
			return;
        }
    };

    var items = pasteEvent.clipboardData.items;

    if(items == undefined){
        if(typeof(callback) == "function"){
            callback(undefined);
			return;
        }
    };

    for (var i = 0; i < items.length; i++) {
        // Skip content if not image
        if (items[i].type.indexOf("image") == -1) continue;
        // Retrieve image on clipboard as blob
		var blob = items[i].getAsFile();

        if(typeof(callback) == "function"){
            callback(blob);
			return;
        }
    }
	
	if(typeof(callback) == "function"){
        callback(undefined);
		return;
    }
}


window.addEventListener("paste", function(e){
	if(document.activeElement.tagName == "INPUT")return;

	e.preventDefault();
	
    retrieveImageFromClipboardAsBlob(e, function(imageBlob){
        // If there's an image, display it in the canvas
        if(imageBlob){
			//need to use filereader to get to base64 content
            var imgReader = encodeClipboardImageAsURL(imageBlob);
			imgReader.onload = function(){
				
				// Create an image to render the blob on the canvas
				var img = move_module.clipboard.img;

				var data = imgReader.result;
				
				//console.log(data);
				img.onload = function(){
					if(current_tool != "move_tool"){
						changeTool("move_tool");
					}
					checkToolsetMode();
					move_module.parseClipboardDataPaste(data);
					move_module.pasteImage();
				};
				
				img.src = data;
			};
        }else{
			
			if(current_tool != "move_tool"){
				changeTool("move_tool");
			}
			checkToolsetMode();
			move_module.parseClipboardDataPaste(null);
			move_module.pasteImage();
		
		}
    });
	
}, false);


window.addEventListener("copy", function(e){
	//test for input element or selected text on page
	if(document.activeElement.tagName == "INPUT" ||
		document.getSelection().toString() != "" ||
		document.activeElement.tagName == "TEXTAREA"){
		return;
	}

	e.preventDefault();
	move_module.copyImage();

}, false);

window.addEventListener("cut", function(e){
	if(document.activeElement.tagName == "INPUT" ||
		document.getSelection().toString() != "" ||
		document.activeElement.tagName == "TEXTAREA"){
		return;
	}

	e.preventDefault();
	move_module.cutImage();
	
}, false);

//
//----------------------Technical Support 1



//ask for unlimitedStorage permissions here
//TODO



//keep track of keyIsDown and keyIsUp. Listener is with hotkeys
var keys = [];



//UI interactive elements
var UI = [];


function getIdElements(){
	var all_id_elements = document.querySelectorAll('[id]');
	var elem = null;
	var elem_id = null;
	for(var i=0;i<all_id_elements.length;i++){
		elem = all_id_elements[i];
		elem_id = elem.id;
		UI[elem_id] = elem;
	}
}
getIdElements();

//Technical Support binds

//remove normal UI zoom
UI.container.addEventListener("wheel", function(e){
	if(keys[17]){
	//if(e.ctrlKey || e.metaKey){
		e.preventDefault();
	}
});

//dealing with touch element capture / default browser behavior
UI.container.addEventListener("pointerdown", function(e){
	e.target.releasePointerCapture(e.pointerId);
},true);
//-----technical support DOM elements

UI.about_program_version.textContent = `Version ${PROGRAM_VERSION[0]}.${PROGRAM_VERSION[1]}.${PROGRAM_VERSION[2]}${PROGRAM_VERSION[3]}`;
UI.ts_download_btn = document.createElement('a');

UI.ts_brush_preset_import = document.createElement('input');
UI.ts_brush_preset_import.setAttribute('type','file');
UI.ts_brush_preset_import.setAttribute('autocomplete','off');
UI.ts_brush_preset_import.setAttribute('accept', '.bp, .txt');

UI.ts_import_image = document.createElement('input');
UI.ts_import_image.setAttribute('type','file');
UI.ts_import_image.setAttribute('autocomplete','off');
UI.ts_import_image.setAttribute('accept', '.png, .jpg, .jpeg, .gif, .bmp, .webp, .webm, .svg');

UI.ts_open_document = document.createElement('input');
UI.ts_open_document.setAttribute('type','file');
UI.ts_open_document.setAttribute('autocomplete','off');
UI.ts_open_document.setAttribute('accept', '.'+PROJECT_FORMAT+', .png, .jpg, .jpeg, .gif, .bmp, .webp, .webm, .svg');


UI.ts_import_settings = null;

/*
var ts_debug_view = UI.ts_debug_view;
ts_debug_view.width = 2560;
ts_debug_view.height = 1440;
var ts_debug_view_ctx = ts_debug_view.getContext("2d");
ts_debug_view_ctx.fillStyle = "red";
*/
//-----technical support DOM elements end

//------------------------------------------------------------



function toRadians(degrees){
	return degrees * Math.PI/180;
}
function toDegrees(radians){
	return radians * 180/Math.PI;
}

//User Config Keeper structures
var db_name = "LightBrushUserConfig";
var dbVersion = 1;


function openIndexedDB(){

	var indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB || window.shimIndexedDB;
	
	var openDB = indexedDB.open(db_name, dbVersion);
	
	openDB.onerror = function() {
		console.error("Database Error", openDB.error);
	};
	
	openDB.onversionchange = function() {
		openDB.close();
		alert("Database is outdated, please reload.")
	};

	return openDB;
}


function getIndexedDBTransaction(openDB, store_list, tx_mode){
	var db = {};
	db.result = openDB.result;
	db.tx = db.result.transaction(store_list, tx_mode);
	return db;
}

function asyncDBreq(req,raw){
	return new Promise((resolve,reject) => {
		req.onsuccess = e => {
			if(raw == true){
				resolve(req);
			}else{
				resolve(req.result);
			}
		}
		req.onerror = e => reject(req.error);
	});
}



const userConfigAttrList = {
	//lib preset lists
	//note: these lists are different from something like const brushPresetAttrList
	"brushPresetConfigData" : ["name","size","flow","opacity","hardness",
		"spacing","sizePressureEnabled","sizePressureMinDiameter","flowPressureEnabled",
		"directionEnabled","brush_type","blend_assist",
		"flip_x_jitter","flip_y_jitter","roundness_jitter","angle_jitter",
		"scatter_distance","scatter_size_jitter","scatter_count","scatter_count_jitter"],
	
	"brushPresetImgData" : ["custom_tip"],
	
	"refPresetConfigData" : ["name","ref_image_align"],
	
	"refPresetImgData" : ["ref_image"],
	
	//gen lists
	"bayBasic" : ["size","opacity","flow","hardness"],
	
	"bayConfig" : ["size_bay_link_ref","size_bay_link_value","size_bay_link_active",
		"activeBrushPresetId","keep_color","color"]
};

const lib_update_que = {
	"brushPresetConfigData" : {},
	"brushPresetImgData" : {},
	"refPresetConfigData" : {},
	"refPresetImgData" : {},
};
const gen_update_que = {
	"generalConfig" : {}
};


function configCollector(){};

configCollector.prototype = {
	
	//internal generic collect
	genericCollect : function(attr_list_name,collect_obj){
		var data = {};
		var attr_list = userConfigAttrList[attr_list_name];
		var attr_name;
		for(var i=0;i<attr_list.length;i++){
			attr_name = attr_list[i];
			if(collect_obj.hasOwnProperty(attr_name)){
				data[attr_name] = collect_obj[attr_name];
			}
		}
		return data;
	},
	
	//wrappers call generic and assign row index/name/id to data returned by generic
	//Lib collect
	"brushPresetConfigData" : function(preset_obj){
		const attr_list_name = "brushPresetConfigData";
		return this.genericCollect(attr_list_name, preset_obj);
	},
	
	"brushPresetImgData" : function(preset_obj){
		const attr_list_name = "brushPresetImgData";
		return this.genericCollect(attr_list_name, preset_obj);
	},
	
	"refPresetConfigData" : function(preset_obj){
		const attr_list_name = "refPresetConfigData";
		return this.genericCollect(attr_list_name, preset_obj);
	},
	
	"refPresetImgData" : function(preset_obj){
		const attr_list_name = "refPresetImgData";
		return this.genericCollect(attr_list_name, preset_obj);
	},
	//Lib collect END
	
	
	//Gen collect
	"bay_0_basic" : function(){
		const attr_list_name = "bayBasic";
		return this.genericCollect(attr_list_name,bay_keeper.bays[0]);
	},
	
	"bay_1_basic" : function(){
		const attr_list_name = "bayBasic";
		return this.genericCollect(attr_list_name,bay_keeper.bays[1]);
	},
	
	"bay_2_basic" : function(){
		const attr_list_name = "bayBasic";
		return this.genericCollect(attr_list_name,bay_keeper.bays[2]);
	},
	
	"bay_3_basic" : function(){
		const attr_list_name = "bayBasic";
		return this.genericCollect(attr_list_name,bay_keeper.bays[3]);
	},
	
	"bay_4_basic" : function(){
		const attr_list_name = "bayBasic";
		return this.genericCollect(attr_list_name,bay_keeper.bays[4]);
	},
	
	"bay_5_basic" : function(){
		const attr_list_name = "bayBasic";
		return this.genericCollect(attr_list_name,bay_keeper.bays[5]);
	},
	
	"bay_6_basic" : function(){
		const attr_list_name = "bayBasic";
		return this.genericCollect(attr_list_name,bay_keeper.bays[6]);
	},
	
	"bay_7_basic" : function(){
		const attr_list_name = "bayBasic";
		return this.genericCollect(attr_list_name,bay_keeper.bays[7]);
	},
	//
	
	"bay_0_config" : function(){
		const attr_list_name = "bayConfig";
		return this.genericCollect(attr_list_name,bay_keeper.bays[0]);
	},
	
	"bay_1_config" : function(){
		const attr_list_name = "bayConfig";
		return this.genericCollect(attr_list_name,bay_keeper.bays[1]);
	},
	
	"bay_2_config" : function(){
		const attr_list_name = "bayConfig";
		return this.genericCollect(attr_list_name,bay_keeper.bays[2]);
	},
	
	"bay_3_config" : function(){
		const attr_list_name = "bayConfig";
		return this.genericCollect(attr_list_name,bay_keeper.bays[3]);
	},
	
	"bay_4_config" : function(){
		const attr_list_name = "bayConfig";
		return this.genericCollect(attr_list_name,bay_keeper.bays[4]);
	},
	
	"bay_5_config" : function(){
		const attr_list_name = "bayConfig";
		return this.genericCollect(attr_list_name,bay_keeper.bays[5]);
	},
	
	"bay_6_config" : function(){
		const attr_list_name = "bayConfig";
		return this.genericCollect(attr_list_name,bay_keeper.bays[6]);
	},
	
	"bay_7_config" : function(){
		const attr_list_name = "bayConfig";
		return this.genericCollect(attr_list_name,bay_keeper.bays[7]);
	},
	//
	
	//custom attribute gatherers are standalone data collect functions
	"bay_selection" : function(){
		//{brush_tool spree erase and draw, eraser_tool spree erase and draw, one brush};//perhaps match in-code structure
		return {"brush_tool_0" : bay_keeper.bay_tool["brush_tool_0"],
				"brush_tool_1" : bay_keeper.bay_tool["brush_tool_1"],
				"eraser_tool_0" : bay_keeper.bay_tool["eraser_tool_0"],
				"eraser_tool_1" : bay_keeper.bay_tool["eraser_tool_1"],
				"single_brush_lock" : bay_keeper.single_brush_lock,
				"single_brush_bay" : bay_keeper.single_brush_bay};
	},
	
	"brushPresetOrder" : function(){
		return bp_keeper.getPresetIdOrder();
	},
	
	"refPresetOrder" : function(){
		return rlp_keeper.getPresetIdOrder();
	},
	/*
	"refPresetFav" : function(){
		return rlp_keeper.getPresetFav();
	},
	*/
	//tool options / config menu
	"ToolOptionsAutoSelect" : function(){
		var sm = selection_module;
		return {"all_layers" : sm.config.all_layers,
				"contiguous" : sm.config.contiguous,
				"rgb_margin" : sm.config.rgb_margin,
				"tone_margin" : sm.config.tone_margin};
	},
	
	"ToolOptionsBrushSmoothing" : function(){
		return {"smoothing_factor" : brushSpacing_tracker.smoothing_factor};
	},
	
	"ToolOptionsBucketTool" : function(){
		var fm = fill_module;
		return {"all_layers" : fm.config.all_layers,
				"top_visible" : fm.config.top_visible,
				"rgb_margin" : fm.config.rgb_margin,
				"opacity_barrier" : fm.config.opacity_barrier,
				"raw_opacity_barrier" : fm.config.raw_opacity_barrier,
				"direct" : fm.config.direct,
				"basic_fill" : fm.config.basic_fill};
	},
	
	//create new document previous presets
	"DocNewPrevPresets" : function(){
		return doc_config_keeper.prev_presets;
	},
	
	//misc 
	"misc_0" : function(){
		return {"cp_auto_apply" : color_picker.auto_apply,
				"spree_auto" : spree_auto,
				"tiny_preview_hide" : UI.tiny_preview_hide.checked,
				"saf_jpg_quality" : parseFloat(UI.saf_menu_option_jpg_quality_slider.value) };
	}
	
	
	//Gen collect END

}


var config_collector = new configCollector();

///////////////////////


///////////////////////

//manages db data requests
function DBKeeper(){
	return;
}

DBKeeper.prototype = {

	updateDBGen : function(){
		if(uc_keeper.db_available != true)return;
		
		var mod_table_list = ["generalConfig"];//for now
		var openDB = openIndexedDB();
		openDB.onsuccess = function(){
			
			var db = getIndexedDBTransaction(openDB, mod_table_list, "readwrite");
			var table = null;
			
			for(var table_name in gen_update_que){
				
				table = db.tx.objectStore(table_name);
				
				for(var row_name in gen_update_que[table_name]){
				
					var row_obj = {};
					row_obj.configName = row_name;
					row_obj.data = JSON.stringify( config_collector[row_name]() );
					
					table.put(row_obj);
					
				}
				
			}
			
			//reset update que
			for(var table_name in gen_update_que){
				gen_update_que[table_name] = {};
			}
			
			/*
			var req = db.tx.objectStore("generalConfig").getAll()
			req.onsuccess = function(e){
				console.log(req.result);
			}
			*/
			
		}
		//
		
	},
	
	updateDBLib : function(){
		if(uc_keeper.db_available != true)return;
		//check which tables were modified
		var mod_table_list = [];
		for(var table_name in lib_update_que){
			for(var preset_id in lib_update_que[table_name]){
				
				mod_table_list.push(table_name);
				
				break;
			}
		}
		//
		
		if(mod_table_list.length < 1)return;
		
		var openDB = openIndexedDB();
		openDB.onsuccess = function(){
			
			var db = getIndexedDBTransaction(openDB, mod_table_list, "readwrite");
			var table = null;
			
			for(var i in mod_table_list){
				
				table_name = mod_table_list[i];
				table = db.tx.objectStore(table_name);
				
				for(var preset_id in lib_update_que[table_name]){
				
					var action_type = lib_update_que[table_name][preset_id];
					if(action_type === 2){
					//delete preset
						
						table.delete(preset_id);
						
						//console.log("deleting preset id "+preset_id);
					}else{
					//update preset
						var row_obj = {};
						row_obj.id = preset_id;
						row_obj.data = JSON.stringify( config_collector[table_name](action_type) );
						
						table.put(row_obj);
						
						//console.log( row_obj );
					}
				}
			
			}
			
			//reset update que
			for(var i in mod_table_list){
				lib_update_que[ mod_table_list[i] ] = {};
			}
			
			/*
			var req = db.tx.objectStore("brushPresetConfigData").getAll()
			req.onsuccess = function(e){
				console.log(req.result);
			}
			*/
			
		}
		//
		
		
	
	},
	
	// async versions
	
	updateDBGen_async : async function(){
		if(uc_keeper.db_available != true)return;
		
		var mod_table_list = ["generalConfig"];//for now
		var openDB = await asyncDBreq(openIndexedDB(), true);
		var db = getIndexedDBTransaction(openDB, mod_table_list, "readwrite");
		var table = null;
		
		for(var table_name in gen_update_que){
			
			table = db.tx.objectStore(table_name);
			
			for(var row_name in gen_update_que[table_name]){
			
				var row_obj = {};
				row_obj.configName = row_name;
				row_obj.data = JSON.stringify( config_collector[row_name]() );
				
				await asyncDBreq( table.put(row_obj) );
				
				//console.log( row_obj );
			}
			
		}
		
		//reset update que
		for(var table_name in gen_update_que){
			gen_update_que[table_name] = {};
		}
		
		/*
		var req = db.tx.objectStore("generalConfig").getAll()
		req.onsuccess = function(e){
			console.log(req.result);
		}
		*/
		

		//
		
	},
	
	updateDBLib_async : async function(){
		if(uc_keeper.db_available != true)return;
		//check which tables were modified
		var mod_table_list = [];
		for(var table_name in lib_update_que){
			for(var preset_id in lib_update_que[table_name]){
				
				mod_table_list.push(table_name);
				
				break;
			}
		}
		//
		
		if(mod_table_list.length < 1)return;
		
		var openDB = await asyncDBreq(openIndexedDB(), true);	
		var db = getIndexedDBTransaction(openDB, mod_table_list, "readwrite");
		var table = null;
		
		for(var i in mod_table_list){
			
			table_name = mod_table_list[i];
			table = db.tx.objectStore(table_name);
			
			for(var preset_id in lib_update_que[table_name]){
			
				var action_type = lib_update_que[table_name][preset_id];
				if(action_type === 2){
				//delete preset
					
					await asyncDBreq( table.delete(preset_id) );
					
					//console.log("deleting preset id "+preset_id);
				}else{
				//update preset
					var row_obj = {};
					row_obj.id = preset_id;
					row_obj.data = JSON.stringify( config_collector[table_name](action_type) );
					
					await asyncDBreq( table.put(row_obj) );
					
					//console.log( row_obj );
				}
			}
		
		}
		
		//reset update que
		for(var i in mod_table_list){
			lib_update_que[ mod_table_list[i] ] = {};
		}
		
		/*
		var req = db.tx.objectStore("brushPresetConfigData").getAll()
		req.onsuccess = function(e){
			console.log(req.result);
		}
		*/
		
		
		//
	},
	
	
	//async versions end
	
	getAll : async function(local_copy_obj){
	//local_copy_obj - is where to store retrieved data
		var openDB = await asyncDBreq(openIndexedDB(), true);
		var db = openDB.result;
		var table_list = db.objectStoreNames;
		//console.log(table_list);
		var tx = db.transaction(table_list, "readonly");
		
		for(var i=0; i<table_list.length; i++){
			local_copy_obj[table_list[i]] = await asyncDBreq(tx.objectStore(table_list[i]).getAll());
		}
		
	},
	
	chromium_readBackDB_count : async function(){
	//helps to make sure things are actually stored in chrome
	//for example during program exit procedures
		var openDB = await asyncDBreq(openIndexedDB(), true);
		var db = openDB.result;
		var table_list = db.objectStoreNames;
		var tx = db.transaction(table_list, "readonly");
		for(var i=0; i<table_list.length; i++){
			await asyncDBreq(tx.objectStore(table_list[i]).count());
		}
	},
	
	deleteDB : async function(){
		await asyncDBreq( indexedDB.deleteDatabase(db_name) );
	}

}

var db_keeper = new DBKeeper();


//TODO remove delete
//let deleteRequest = indexedDB.deleteDatabase(db_name);

const userConfigList = ["BrushPresets","RefPresets","BayConfig"];

function userConfigKeeper(){
	var uck = this;

	uck.db_available = false;
	
	uck.config = {};
	
	uck.missing_table_name_list = [];//name list of tables missing in db, used on upgrade
	
	uck.genUpdateTimer = null;
	uck.genNotifyCount = 0;
	
	uck.IDBData = {};
}

userConfigKeeper.prototype = {
	
	resetConfig : function(name){
		this[name] = JSON.parse( userConfigDefault[name] );
		//optional
		this.putData(name,JSON.stringify(userConfigDefault[name]));
	},
	
	resetAll : async function(){
		clearTimeout(this.genUpdateTimer);
		await db_keeper.deleteDB();
		setTimeout(async function(){window.location.reload();return false;}, 50);
	},
	
	clearData : function(){
		for(var i=0;i<userConfigList.length;i++){
			window.localStorage.removeItem(userConfigList[i]);
		}
		indexedDB.deleteDatabase(db_name);
	},
	
	getConfig : function(name){
		return this.config[name];
	},
	//////////////////////////////////////////////

	
	populateMissingTable : async function(){
		var openDB = await asyncDBreq(openIndexedDB(), true);
		var db = openDB.result;
		var missing_table_name_list = this.missing_table_name_list;
		var tx = db.transaction(missing_table_name_list, "readwrite");
		var table_name = null;
		var table;
		var row_obj;
		var row_default;
		var config_default;
		for(var i=0; i<missing_table_name_list.length; i++){
			table_name = missing_table_name_list[i];
			table = tx.objectStore(table_name);
			config_default = userConfigDefault[table_name];
			
			for(var j=0; j<config_default.length; j++){
				row_default = config_default[j];
				row_obj = {};
				for(var col in row_default){
				//looping over columns in a row
					row_obj[col] = row_default[col];
				}
				await asyncDBreq( table.put(row_obj) );
			}
			
		}
		
		//console.log("done populating missing tables");
	},
	
	importDBConfig : async function(dbconfig){
		var openDB = await asyncDBreq(openIndexedDB(), true);
		var db = openDB.result;
		var table_name_list = [];
		var table_name = null;
		var table;
		var row_obj;
		var row_default;
		var config_default;
		//
		for(table_name in dbconfig){
			table_name_list.push(table_name);
		}
		
		var tx = db.transaction(table_name_list, "readwrite");
		
		//
		for(table_name in dbconfig){
			await asyncDBreq( tx.objectStore(table_name).clear() );
			//console.log("done clearing "+table_name);
		}
		
		//console.log("uploading new db config");
		for(table_name in dbconfig){
		
			table = tx.objectStore(table_name);
			config_default = dbconfig[table_name];
			
			for(var j=0; j<config_default.length; j++){
				row_default = config_default[j];
				row_obj = {};
				for(var col in row_default){
				//looping over columns in a row
					row_obj[col] = row_default[col];
				}
				await asyncDBreq( table.put(row_obj) );
			}
			
		}
		//console.log("done uploading db config");
		return tx;
	},
	
	getDBConfig : async function(dbconfig){
	//NOTE: use await uc_keeper.getDBConfig() to do a call
	//pulls all database config data (using DBKeeper)
	//to be passed to modules for load
		var uck = this;
		
		if(dbconfig == null){
		//pull from database
			var config_raw = {};//raw data from database
			await db_keeper.getAll(config_raw);
		}else{
		//use given db data
			var config_raw = dbconfig;
		}

		//parse db config into mapped form first
		var config_map = {};
		var table_name;
		var table;
		
		table_name = "brushPresetConfigData";
		table = config_raw[table_name];
		config_map[table_name] = {};
		for(let i=0; i < table.length; i++){
			config_map[table_name][ table[i]["id"] ] = table[i]["data"];
		}
		
		table_name = "brushPresetImgData";
		table = config_raw[table_name];
		config_map[table_name] = {};
		for(let i=0; i < table.length; i++){
			config_map[table_name][ table[i]["id"] ] = table[i]["data"];
		}
		
		table_name = "refPresetConfigData";
		table = config_raw[table_name];
		config_map[table_name] = {};
		for(let i=0; i < table.length; i++){
			config_map[table_name][ table[i]["id"] ] = table[i]["data"];
		}
		
		table_name = "refPresetImgData";
		table = config_raw[table_name];
		config_map[table_name] = {};
		for(let i=0; i < table.length; i++){
			config_map[table_name][ table[i]["id"] ] = table[i]["data"];
		}
		
		table_name = "generalConfig";
		table = config_raw[table_name];
		config_map[table_name] = {};
		for(let i=0; i < table.length; i++){
			config_map[table_name][ table[i]["configName"] ] = table[i]["data"];
		}

		//
		//parse db config data into module config form
		var config = {};//parsed module form
		var config_name;
		
		var preset;
		var preset_id;
		//
		//note: perhaps put some sorting here for keys
		config_name = "BrushPresets";
		//config[config_name] = [];
		config[config_name] = {};
		for(preset_id in config_map["brushPresetConfigData"]){
			preset = JSON.parse(config_map["brushPresetConfigData"][preset_id]);
			preset.id = parseInt(preset_id);
			
			preset.custom_tip = null;
			if(preset_id in config_map["brushPresetImgData"]){
				preset.custom_tip = JSON.parse(config_map["brushPresetImgData"][preset_id]).custom_tip;
			}
			//
			//config[config_name].push(preset);
			config[config_name][preset_id] = preset;
		}
		//
		
		config_name = "RefPresets";
		//config[config_name] = [];
		config[config_name] = {};
		for(preset_id in config_map["refPresetConfigData"]){
			preset = JSON.parse(config_map["refPresetConfigData"][preset_id]);
			preset.id = parseInt(preset_id);
			
			if(preset_id in config_map["refPresetImgData"]){
				preset.ref_image = JSON.parse(config_map["refPresetImgData"][preset_id]).ref_image;
			}
			//
			//config[config_name].push(preset);
			config[config_name][preset_id] = preset;
			
		}
		
		
		config_name = "BayConfig";
		config[config_name] = [];
		var table = config_map["generalConfig"];
		var bay_i = 0;
		var bay_config;
		var temp_data;
		while(bay_i < 8){
		
			bay_config = {};
			
			temp_data = JSON.parse(table["bay_"+bay_i+"_basic"]);
			for(let attr in temp_data){
				bay_config[attr] = temp_data[attr];
			}

			temp_data = JSON.parse(table["bay_"+bay_i+"_config"]);
			for(let attr in temp_data){
				bay_config[attr] = temp_data[attr];
			}
			
			config[config_name].push(bay_config);
			bay_i++;
		}
		
		config_name = "BaySelection";
		config[config_name] = JSON.parse(config_map["generalConfig"]["bay_selection"]);
		
		config_name = "BrushPresetOrder";
		config[config_name] = JSON.parse(config_map["generalConfig"]["brushPresetOrder"]);
		
		config_name = "RefPresetOrder";
		config[config_name] = JSON.parse(config_map["generalConfig"]["refPresetOrder"]);
		
		//config_name = "RefPresetFav";
		//config[config_name] = JSON.parse(config_map["generalConfig"]["refPresetFav"]);
		
		config_name = "ToolOptionsAutoSelect";
		config[config_name] = JSON.parse(config_map["generalConfig"][config_name]);
		
		config_name = "ToolOptionsBrushSmoothing";
		config[config_name] = JSON.parse(config_map["generalConfig"][config_name]);
		
		config_name = "ToolOptionsBucketTool";
		config[config_name] = JSON.parse(config_map["generalConfig"][config_name]);
		
		config_name = "DocNewPrevPresets";
		config[config_name] = JSON.parse(config_map["generalConfig"][config_name]);
		
		config_name = "misc_0";
		config[config_name] = JSON.parse(config_map["generalConfig"][config_name]);

		uck.config = config;
		//console.log(uck.dbConfigData);
	},
	
	notifyLibUpdateNeeded : function(table_name,preset_id,action_type){
	//action_type: preset obj - means update, 2 - means delete
		lib_update_que[table_name][preset_id] = action_type;
	},
	
	notifyGenUpdateNeeded : function(table_name,row_name){
	//console.log("gen");
		gen_update_que[table_name][row_name] = 1;
		
		clearTimeout(this.genUpdateTimer);
		
		var delay = 15000;
		
		this.genNotifyCount++;
		if(this.genNotifyCount > 19){
		//update immediately if many update notification calls were made
			delay = 0;
		}
		
		this.genUpdateTimer = setTimeout(function(){
			uc_keeper.genNotifyCount = 0;
			db_keeper.updateDBGen();
			//console.log("gen update stored");
		},delay);
	},
	
	resetUpdateQue : function(update_que){
	//generic update_que reset
		for(let key in update_que){
			update_que[key] = {};
		}
	},
	
	///////////////
	
	loadConfigMisc : function(){
	//loads all misc configs from uc_keeper.config
		var uck = this;
		
		color_picker.auto_apply = uck.config.misc_0.cp_auto_apply;
		UI.cp_auto_apply.checked = color_picker.auto_apply;
		
		spree_auto = uck.config.misc_0.spree_auto;
		UI.spree_auto.checked = spree_auto;
		
		if(!uck.config.misc_0.tiny_preview_hide){
			showUIElement(UI.tiny_preview_hide_screen);
		}
		UI.tiny_preview_hide.checked = uck.config.misc_0.tiny_preview_hide;
		
		UI.saf_menu_option_jpg_quality_slider.value = uck.config.misc_0.saf_jpg_quality;
	
	}

}

var uc_keeper = new userConfigKeeper();
//uc_keeper.clearData();

//Support functions - Timing
const sleepNow = (delay) => new Promise((resolve) => setTimeout(resolve,delay));
async function waitChange(obj, value, maxwait){
//obj : target obj as an anonymouse function return
//value : current value that should change
//maxwait : maximum time to wait [optional]
	if(maxwait == null){
		maxwait = 1000;
	}
	var waitTimer = 0;
	var interval = 10;
	
	while(waitTimer < maxwait){
		if(obj() == value){
			waitTimer += interval;
			await sleepNow(interval);
		}else{
			//console.log("breaking out");
			break;
		}
	}
	
}


function pollChange(target,current_value,timeout){
	return new Promise(function(resolve,reject){
		var polling_interval = 10;
		var maxwait = 4000;
		if(timeout != null){
			maxwait = timeout;
		}
		var time_elapsed = 0;
		
		var waiter = function(){
			//console.log(target(),current_value);
			setTimeout(function(){
			
				if(target() == current_value){
				
					time_elapsed += polling_interval;
					
					if(time_elapsed < maxwait){
						waiter();
					}else{
						reject("timeout");
					}
				
				}else{
					resolve("done");
				}
			
			},polling_interval);
		
		}//waiter end
		waiter();
	
	});
}
//example how to use:
/*
pollChange( function(){return obj}, currentObjValue).then((message) => { 
    console.log(message);
}).catch((message) => { 
    console.log(message);
});
*/

//making a flag out of a promise
function makePromiseFlag(){
	var resolve, reject;

	var promise = new Promise(function(_resolve, _reject){
	resolve = _resolve; 
	reject = _reject;
	});

	promise.resolve = resolve;
	promise.reject = reject;
	return promise;
}

//example use
/*
var b = makePromiseFlag();

b.then((message) => { 
    console.log(message);
}).catch((message) => { 
    console.log(message);
});
*/


//User Config Keeper structured END


//file opener maybe for settings along with all the custom brush tips
//and other user files, to by-pass CORS
function encodeImageFileAsURL(element) {
  var file = element.files[0];
  var reader = new FileReader();
  reader.readAsDataURL(file);
  return reader;
}

function encodeClipboardImageAsURL(file) {
  var reader = new FileReader();
  reader.readAsDataURL(file);
  return reader;
}


//default starting canvas size dimensions
//1440p
var drawingAreaWidth = 2560;
var drawingAreaHeight = 1440;
//4k
//var drawingAreaWidth = 3840;
//var drawingAreaHeight = 2160;
//chromium
//var drawingAreaWidth = 4000;
//var drawingAreaHeight = 4000;
//8k
//var drawingAreaWidth = 7680;
//var drawingAreaHeight = 4320;

var layer_counter = 0;//increment on every layer creation, then use for layer name

//set reference var for container
var c_view = document.getElementById("canvas_draw_screen");
var c_view_rect_x = c_view.getBoundingClientRect().x;
var c_view_rect_y = c_view.getBoundingClientRect().y;


//---Toolset vars 
// perhaps move this section all the way down so that functions can be bound after they are defined
var current_tool = "brush_tool";
var tool_agent = {
//caches functions-tool choice for tool use.
//(to avoid checking which tool function needs to be called every event)
//note: possibly expand this into a module and encapsulate other related vars
	_updateCurrent : function(){
		this.tool_mouse_down = tool_mouse_down[current_tool];
		this.tool_mouse_move = tool_mouse_move[current_tool];
		this.tool_mouse_up = tool_mouse_up[current_tool];
	},
	
	tool_mouse_down : null,
	tool_mouse_move : null,
	tool_mouse_up : null
};
//toolset_mode is used for bundling tools into groups if needed, 
//for example to solidifySpree at proper changeTool calls. like between brush and eraser
var toolset_mode = 1;
const toolset_mode_map = {
	"brush_tool":1,
	"eraser_tool":2,
	"bucket_tool":1,
	"move_tool":3
}
var tool_toggle = ["brush_tool","brush_tool"];//tool toggle feature
var tool_toggle_i = 0;//to do a switch between two indices of tool_toggle

//global brush color
var current_color = "black";

//0: drawing to spree 1: erasing from spree
var spree_mode = 0;
var spree_auto = UI.spree_auto.checked;
//currently active bay, to be set by bay keeper or bay itself upon select
var current_bay = false;

var bay_keeper;// = false;



//-----------------------------------Async mouse tracking and brush spacing tracking structures

function circularQue(length){
	var q = this;
	q.length = length;
	q.list = [];
	for(let i=0;i<q.length;i++){
		q.list.push(null);
	}
	q.start = 0;
	q.end = 0;
	return;
}

circularQue.prototype = {
	add : function(val){
		var q = this;
		//when full just replace start and shift
		//note: can also implement dynamic expanding if needed ~
		q.end = (q.end+1) % q.length;
		q.list[q.end] = val;
		if(q.end == q.start){
			q.start = (q.start+1) % q.length;
		}
		
	},
	
	next : function(){
		var q = this;
		if(q.start == q.end){
			return null;
		}
		q.start = (q.start+1) % q.length;
		return q.list[q.start];
	},
	
	back : function(){
		var q = this;
		if(q.end == q.start){
			return null;
		}
		q.end = (q.length + q.end-1) % q.length;
		return q.list[q.end];
	},
	
	getNext : function(){
	//return what is next, without switching
		var q = this;
		if(q.start == q.end){
			return null;
		}
		return q.list[ (q.start+1) % q.length ];
	},
	
	getPrevious : function(){
	//return what was previous, without switching
		var q = this;
		if(q.end == q.start){
			return null;
		}
		return q.list[ (q.length + q.end-1) % q.length ];
	},
	
	reset : function(){
		var q = this;
		q.list = [];
		for(var i=0;i<q.length;i++){
			q.list.push(null);
		}
		q.start = 0;
		q.end = 0;
	}
}
//init struct as mouse brush tip coordinates
var brushTip_coords = new circularQue(100000);
//--

function brushSpacingTracker(){
	var bst = this;
	bst.path = 0;
	bst.previous = [0,0,0,1];
	bst.phase = 0;
	bst.originPos = [0,0,0,1];//latest stored coordinate used as point_a in calculations
	
	bst.c_rect = null;
	
	//storing latest two events for processing needs
	bst.e_current = {};
	bst.e_current.x = 0;
	bst.e_current.y = 0;
	bst.e_current.pressure = 1;
	
	bst.e_previous = {};
	bst.e_previous.x = 0;
	bst.e_previous.y = 0;
	bst.e_previous.pressure = 1;
	
	bst.same_e = false;
	
	bst.smoothing_factor = 1;//smoothing 0.3-1
	
	
	//debug vars
	//bst.debug_p = 0.1;
}

brushSpacingTracker.prototype = {

	load : function(config){
		this.smoothing_factor = config.smoothing_factor;
	},

	process : [
		function(e,full_path){
		//phase 0
			var bst = brushSpacing_tracker;
			
			bst.previous = [e.x,e.y, 0, e.pressure];
			bst.originPos = [e.x,e.y, 0, e.pressure];
			if(current_brush.directionEnabled == false){
				brushTip_coords.add([e.x,e.y, 0, e.pressure]);
			}
			bst.phase++;
		},
		
		function(e,full_path){
		//phase 1
			var bst = brushSpacing_tracker;
			if(bst.same_e)return;
			
			var x = e.x;
			var y = e.y;
			var p = e.pressure;
			var dx = x - bst.previous[0];
			var dy = y - bst.previous[1];
			bst.path += Math.sqrt(dx*dx + dy*dy);
			
			var p_d = Math.atan2(-y + bst.previous[1], -x + bst.previous[0]) + Math.PI/2;
			
			
			bst.originPos[2] = p_d;
			
			if(current_brush.directionEnabled == true){
				brushTip_coords.add([bst.originPos[0],bst.originPos[1],bst.originPos[2],bst.originPos[3]]);
			}
			
			bst.previous[0] = x;
			bst.previous[1] = y;
			bst.previous[2] = p_d;
			bst.previous[3] = p;
			
			bst.phase++;
		},
		
		function(e,full_path){
		//phase 2
			var bst = brushSpacing_tracker;
			var x = e.x;
			var y = e.y;
			var p = e.pressure;
			var dx = x - bst.previous[0];
			var dy = y - bst.previous[1];
			
			var dhyp = Math.sqrt(dx*dx + dy*dy);
			
			var spacing = current_bay.step_spacing;//spacing in pixels
			if(current_brush.sizePressureEnabled){
				var sp_min_diameter = current_brush.sizePressureMinDiameter;
				
				var step = spacing*sp_min_diameter + (spacing - spacing*sp_min_diameter) * p;
			}else{
				var step = spacing;
			}
			if(step < 1)step = 1;
			
			bst.path+=dhyp;
			if(bst.path < step){
			//nothing to do

			}else if(full_path == true){
				
				traceArcPath(bst.originPos, [x,y,0,p],bst.path, full_path);
				
			}else if(bst.path/step < 2){
			//add single coordinate
			//console.log("single coord");
				var soh = dy/dhyp;
				var cah = dx/dhyp;
				
				var x_coord = bst.previous[0]+(cah*(step-(bst.path-dhyp)));
				var y_coord = bst.previous[1]+(soh*(step-(bst.path-dhyp)));

				var p_d = Math.atan2(-y + bst.originPos[1], -x + bst.originPos[0]) + Math.PI/2;
				
				brushTip_coords.add([x_coord,y_coord,p_d,p]);
				bst.originPos = [x_coord,y_coord,p_d,p];
				
				bst.path -= step;
				
			}else{
				
				traceArcPath(bst.originPos, [x,y,0,p],bst.path, full_path);

			}
			
			bst.previous[0] = x;
			bst.previous[1] = y;
			bst.previous[2] = p_d;
			bst.previous[3] = p;
			
		},
		
		function(e,full_path){
		//debug stop drawing
			return;
		}
	],
	
	reset : function(){
		var bst = this;
		bst.path = 0;
		bst.previous = [0,0,0,1];
		bst.phase = 0;
		bst.originPos = [0,0,0,1];
		bst.e_previous.pressure = 1;
		bst.e_current.pressure = 1;
		bst.same_e = false;
	},
	
	findRect : function(){
		this.c_rect = live_view.getBoundingClientRect();
	},
	
	storeEvent : function(e){
		var bst = this;
		//make coordinates relative to scroll position and zoom
		const c_rect = bst.c_rect;
		bst.e_current.x = Math.floor( (e.x-c_rect.x)/canvas_view.current_zoom);
		bst.e_current.y = Math.floor( (e.y-c_rect.y)/canvas_view.current_zoom);
		//console.log(bst.e_current.x, bst.e_current.y);
		bst.e_current.pressure = e.pressure;// pen pressure
		
		//testing pressure without pen
		/*
		var p=bst.e_previous.pressure+0.05;
		if(p>1){
			p=0.01;
			//console.log("resetting to 0.1");
		}
		bst.e_current.pressure = p;
		*/
		//bst.e_current.pressure = bst.debug_p;
	},
	
	setSmoothing : function(level){
		this.smoothing_factor = (10 - level)/10;
		UI.brush_smoothing_value.value = level;
		UI.eraser_smoothing_value.value = level;
		
		//
		uc_keeper.notifyGenUpdateNeeded("generalConfig","ToolOptionsBrushSmoothing");
	},
	
	updateUITrackerConfig : function(){
		var level = 10-this.smoothing_factor*10;
		UI.brush_smoothing_value.value = level;
		UI.eraser_smoothing_value.value = level;
	},

}

var brushSpacing_tracker = new brushSpacingTracker();
//brushSpacing_tracker.updateUITrackerConfig();
//trace arc helper
function traceArcPath(point_a,point_b,path,full){
//find center point m and radius r of a circle given two points a and b
//such that a and b are on an arc of a circle
// - anchors one of the points to be on the same x or y axis as the center point m
//depending on the angle between points in a corresponding quadrant
	var bst = brushSpacing_tracker;
	var btc = brushTip_coords;
	var forehand_factor = 0.7;
	var smoothing_factor = bst.smoothing_factor;
	
	var point_a_p = point_a[3];
	var point_b_p = point_b[3];
	var r = 1;
	//move point_a to be zero
	var a = [0,0];
	var b = [point_b[0] - point_a[0], point_b[1] - point_a[1]];
	
	var m = [0,0];
	var point_a_angle = -point_a[2];
	var coord = [ point_a[0], point_a[1], point_a[2], point_a[3] ];
	
	//rotate system
	var temp_x = b[0]*Math.cos(point_a_angle) - b[1]*Math.sin(point_a_angle);
	var temp_y = b[0]*Math.sin(point_a_angle) + b[1]*Math.cos(point_a_angle);
	
	var spacing = current_bay.step_spacing;
	if(spacing < 1){
		spacing = 1;
	}
	
	if(Math.abs(temp_x) < 2){//relative vertical 
	//(technically value should be 1, but 2 seem to work better)
	//same angle means straight line
	//console.log("straight line");
		
		var dhyp = Math.sqrt(b[0]*b[0] + b[1]*b[1]);
		var total_path = dhyp;//total path distance between points
		var path = dhyp;
		var soh = b[1] / dhyp;
		var cah = b[0] / dhyp;
		
		if(current_brush.sizePressureEnabled){
		//affecting step
			var dp,step_avg,num_steps,p_add_per_step,temp_p_buildup,step;
			
			var p_buildup = point_a_p;
			dp = point_b_p - p_buildup;
			
			var sp_min_diameter = current_brush.sizePressureMinDiameter;
			var elapsed_path = 0;
			
			step_avg = spacing * (p_buildup + (dp / 2));
		
			//get number of steps through a path based on average spacing
			num_steps = total_path / step_avg;
			
			//get how much p to add per step
			p_add_per_step = (dp) / num_steps;
			while(path > 0){
				
				temp_p_buildup = p_buildup + p_add_per_step;
			
				step = spacing*sp_min_diameter + (spacing - spacing*sp_min_diameter) * temp_p_buildup;
				if(step < 1){
					step=1;
					p_buildup += (dp/total_path);
				}else{
					p_buildup = temp_p_buildup;
				}
				if(step > path)break;
				elapsed_path += step;
				/////////////////
				coord = [];
				coord[0] = point_a[0]+(cah*elapsed_path);
				coord[1] = point_a[1]+(soh*elapsed_path);
				coord[2] = point_a[2];
				coord[3] = p_buildup;
				
				btc.add( coord );
				
				path -= step;
			}
			
		}else{
		//no affecting step
			var step_avg = spacing;
			
			//get number of steps through a path based on average spacing
			var num_steps = total_path / step_avg;
			
			//get how much p to add per step
			var p_add_per_step = (point_b_p-point_a_p) / num_steps;
			
			var p_buildup = point_a_p + p_add_per_step;
			
			var step = spacing;
			
			var elapsed_path = step;

			while(elapsed_path <= total_path){
				coord = [];
				coord[0] = point_a[0]+(cah*elapsed_path);
				coord[1] = point_a[1]+(soh*elapsed_path);
				coord[2] = point_a[2];
				coord[3] = p_buildup;
				
				btc.add( coord );

				p_buildup += p_add_per_step;
				elapsed_path += step;
				
			}
			var path = total_path-(elapsed_path-step);
		}
	
	//
		bst.originPos = [coord[0],coord[1],coord[2],coord[3]];
		bst.path = path;

		return;
	}


	b[0] = temp_x;
	b[1] = temp_y;

	
	
/* formula reference
	(b[1] - r)(b[1] - r)
	b[1]^2 - 2*b[1]*r + r^2
*/
/*
	if( Math.abs(a[0] - b[0]) > Math.abs(a[1] - b[1]) ){
		r = ( Math.pow(b[0]-a[0],2) + b[1]*b[1] ) / ( 2*b[1] ) ;
		m[0] = b[0];
		m[1] = b[1] - r;
	}else{
		r = ( Math.pow(b[1]-a[1],2) + b[0]*b[0] ) / ( 2*b[0] )
		m[0] = a[0] + r;
		m[1] = a[1];
	}
*/
	//calculate circle center point
	r = ( Math.pow(b[1]-a[1],2) + b[0]*b[0] ) / ( 2*b[0] );
	m[0] = a[0] + r;
	m[1] = a[1];
	
	//rotate circle center back
	temp_x = m[0]*Math.cos(-point_a_angle) - m[1]*Math.sin(-point_a_angle);
	temp_y = m[0]*Math.sin(-point_a_angle) + m[1]*Math.cos(-point_a_angle);
	m[0] = temp_x;
	m[1] = temp_y;
	
	
	//restore global coordinate
	m[0]+=point_a[0];
	m[1]+=point_a[1];
	r = Math.abs(r);
	

	//angle between two points
	var arc_angle = 2* Math.asin(0.5 * Math.sqrt(b[0]*b[0]+b[1]*b[1]) / r);
	//console.log(toDegrees(arc_angle));
	
	
	//deal with quadrants
	var quadrant = -1;
	if( (b[0] > 0 && b[1] < 0) || (b[0] < 0 && b[1] < 0) ){
		arc_angle = arc_angle+ 2*(Math.PI-arc_angle);
	}
	
	if( (b[0] < 0 && b[1] < 0) || (b[0] < 0 && b[1] >= 0) ){
		quadrant = 1;
	}
	
	
	var whole_arc_angle = arc_angle;
	if(full != true){
		arc_angle*=smoothing_factor;
		if(arc_angle >= Math.PI*forehand_factor){
			
			//console.log("changing direction");
			traceArcPath(point_a,bst.previous,path,true);
			bst.originPos[2] = Math.PI/2 + Math.atan2(-point_b[1] + bst.originPos[1], -point_b[0] + bst.originPos[0]);
			var dx = point_b[0]-bst.previous[0];
			var dy = point_b[1]-bst.previous[1];
			var dhyp = Math.sqrt(dx*dx+dy*dy);
			bst.path = path + dhyp - (path - bst.path);//dhyp;
			
			return;
		}
		
		arc_angle *=forehand_factor;
	}else if(full == true){
		if(b[1] < 0){
			return;
		}
	}
	
	
	
	
	
	
	
	
	
	//whole arc path length
	var total_path = whole_arc_angle*r;
	var arc_path = whole_arc_angle;
	var path = total_path;
	var temp_angle = 0;
	a[0] = point_a[0] - m[0];
	a[1] = point_a[1] - m[1];
	
	if(current_brush.sizePressureEnabled){
	//affecting step
		var dp,step_avg,num_steps,p_add_per_step,temp_p_buildup,step,deg_step;

		var elapsed_angle = 0;
		var p_buildup = point_a_p;
		dp = point_b_p - point_a_p;//delta/difference in pen pressure
		//draw steps
		
		var sp_min_diameter = current_brush.sizePressureMinDiameter;
		step_avg = spacing * (p_buildup + (dp / 2));
		
		//get number of steps through a path based on average spacing
		num_steps = total_path / step_avg;
		
		//get how much p to add per step
		p_add_per_step = dp / num_steps;
		while(path > 0){
			path = (whole_arc_angle-elapsed_angle)*r;
			
			temp_p_buildup = p_buildup + p_add_per_step;
			
			//step = spacing * temp_p_buildup;
			step = spacing*sp_min_diameter + (spacing - spacing*sp_min_diameter) * temp_p_buildup;
			if(step < 1){
				step=1;
				p_buildup += (dp / total_path);
			}else{
				p_buildup = temp_p_buildup;
			}
			
			//circle length per degree is 1/r
			//how many degrees per step
			deg_step = step/r;
			elapsed_angle += deg_step;
			if(deg_step > arc_angle-elapsed_angle)break;
			
			
			
			
			/////////////////////
			temp_x = m[0] + a[0]*Math.cos(quadrant*elapsed_angle) - a[1]*Math.sin(quadrant*elapsed_angle);
			temp_y = m[1] + a[0]*Math.sin(quadrant*elapsed_angle) + a[1]*Math.cos(quadrant*elapsed_angle);
			
			temp_angle = -point_a_angle + quadrant*elapsed_angle;
			
			
			coord = [temp_x,temp_y,temp_angle,p_buildup];
			btc.add( coord );
			
			//arc_path -= deg_step;
			
		}
		//path = (whole_arc_angle-(elapsed_angle - deg_step))*r;
			
	}else{
	//no affecting step
		var step_avg = spacing;
		
		//get number of steps through a path based on average spacing
		var num_steps = total_path / step_avg;

		//get how much p to add per step
		var p_add_per_step = (point_b_p - point_a_p) / num_steps;
		
		var p_buildup = point_a_p + p_add_per_step;
		
		var step = spacing;
		
		//circle length per degree is 1/r
		//how many degrees per step
		var deg_step = step/r;

		var elapsed_angle = deg_step;
		//draw steps

		while(elapsed_angle <= arc_angle){

			temp_x = m[0] + a[0]*Math.cos(quadrant*elapsed_angle) - a[1]*Math.sin(quadrant*elapsed_angle);
			temp_y = m[1] + a[0]*Math.sin(quadrant*elapsed_angle) + a[1]*Math.cos(quadrant*elapsed_angle);
			
			temp_angle = -point_a_angle + quadrant*elapsed_angle;
			
			
			coord = [temp_x,temp_y,temp_angle,p_buildup];
			btc.add( coord );
			
			
			p_buildup += p_add_per_step;
			elapsed_angle += deg_step;
			
			
		}
		path = (whole_arc_angle - (elapsed_angle-deg_step) ) * r;
	}

	bst.originPos = [coord[0],coord[1],coord[2],coord[3]];
	bst.path = path;//path_unclaimed;
	
}
//

//-----------------------------------Canvas Buffer structures

function canvasBuffer(c,w,h,composite,alpha){
	if(c != null){
		this.c = c;
	}else{
		this.c = document.createElement("canvas");
	}
	
	this.ctx = this.c.getContext("2d");
	
	//optional set size from init
	if(w != null && h != null){
		this.c.width = w;
		this.c.height = h;
	}else{
		this.c.width = 1;
		this.c.height = 1;
	}

	this.empty = true;
	
	if(composite != null){
		this.defaultCompositeOperation = composite;
		this.ctx.globalCompositeOperation = composite;
	}else{
		this.defaultCompositeOperation = "source-over";
	}
	
	if(alpha != null){
		this.defaultAlpha = alpha;
		this.ctx.globalAlpha = alpha;
	}else{
		this.defaultAlpha = 1;
	}
}

canvasBuffer.prototype = {
	
	put : function(c,sx,sy,sw,sh){
	//will size canvas to given area and put source area on canvas
		var cb = this;
		
		if(c == null){
			cb.clear();
			return;
		}
		
		//portion
		if(sx != null && sy != null && sw != null && sh != null){
			//size buffer and put a portion of inbound canvas
			if(cb.c.width != sw || cb.c.height != sh){
				cb.c.width = sw;
				cb.c.height = sh;
				cb.c.imageSmoothingEnabled = false;
			}else{
				cb.ctx.clearRect(0,0,cb.c.width,cb.c.height);
			}
			cb.ctx.drawImage(c, sx,sy, sw,sh, 0,0, cb.c.width, cb.c.height);
			
		}else{
		//full canvas
			if(cb.c.width != c.width || cb.c.height != c.height){
				cb.c.width = c.width;
				cb.c.height = c.height;
				cb.c.imageSmoothingEnabled = false;
			}else{
				cb.ctx.clearRect(0,0,cb.c.width,cb.c.height);
			}
			cb.ctx.drawImage(c,0,0);
			
		}
		
		cb.empty = false;
	},
	
	//draw into existing content
	stack : function(c,sx,sy,sw,sh){
		var cb = this;
		if(sx != null && sy != null && sw != null && sh != null){
			cb.ctx.drawImage(c, sx,sy, sw,sh, 0,0, cb.c.width, cb.c.height);
		}else{
			this.ctx.drawImage(c,0,0);
		}
	},
	
	setComposite(val){
		this.ctx.globalCompositeOperation = val;
	},
	
	resetComposite(){
		this.ctx.globalCompositeOperation = this.defaultCompositeOperation;
	},
	
	setAlpha(val){
		this.ctx.globalAlpha = val;
	},
	
	resetAlpha(){
		this.ctx.globalAlpha = this.defaultAlpha;
	},
	
	output : function(ctx,c,offsetX,offsetY,clear){
		var x = 0;
		var y = 0;
		if(offsetX != null && offsetY != null){
			x = offsetX;
			y = offsetY;
		}
		if(clear == false){
			
		}else{
			//clear output canvas by default
			if(c == null){
				//clears area with offset before drawing to it
				ctx.clearRect(x,y, this.c.width,this.c.height);
			}else{
				//clears whole target canvas
				ctx.clearRect(0,0, c.width,c.height);
			}
		}
		ctx.drawImage(this.c,x,y);
		
	},
	
	get : function(){
		return [this.c,this.ctx];
	},
	
	clear : function(){
		var cb = this;
		if(cb.empty)return;
		cb.ctx.clearRect(0,0,cb.c.width,cb.c.height);
		cb.empty = true;
	},
	
	//for manual usage of internals
	setSize : function(w,h){
		var cb = this;
		cb.c.width = w;
		cb.c.height = h;
		cb.clear();
	}
}

var chamber_buffer = [];//multi-purpose canvas buffers
//expected that they are available once a procedure is done
chamber_buffer.push(new canvasBuffer());
chamber_buffer.push(new canvasBuffer());
chamber_buffer.push(new canvasBuffer());
chamber_buffer.push(new canvasBuffer());
chamber_buffer.push(new canvasBuffer());
chamber_buffer.push(new canvasBuffer());
chamber_buffer.push(new canvasBuffer());
chamber_buffer.push(new canvasBuffer());
chamber_buffer.push(new canvasBuffer());
chamber_buffer.push(new canvasBuffer());



//-----------------------------------Canvas View object structures

function canvasView(){
	var cv = this;
	
	cv.container = document.getElementById("canvasContainer");
	//
	cv.isScrolling = null;
	cv.container.addEventListener("scroll", function(e){
		
		if(selection_module.selection_active == false)return;
		
		if(canvas_view.isScrolling == null){
			selection_module.clearSelectionView();
		}
		
		clearTimeout( canvas_view.isScrolling );

		// Set a timeout to run after scrolling ends
		canvas_view.isScrolling = setTimeout(function() {

			// Run the callback
			selection_module.makeSelectionOutline();
			canvas_view.isScrolling = null;
			
		}, 100);
	});
	
	cv.content_border = document.getElementById("canvas_view_margin");
	cv.content = document.getElementById("canvas_view");
	
	cv.content.style.width = drawingAreaWidth + "px";
	cv.content.style.height = drawingAreaHeight + "px";

	cv.content_border.style.paddingLeft = c_view.offsetWidth+"px";
	cv.content_border.style.paddingRight = c_view.offsetWidth+"px";
	cv.content_border.style.paddingTop = c_view.offsetHeight+"px";
	cv.content_border.style.paddingBottom = c_view.offsetHeight+"px";
	
	
	cv.pan_screen = UI.canvas_pan_screen;
	cv.pan_screen.style.display = "none";
	cv.pan_screen.style.cursor = "grab";
	cv.panX = 0;
	cv.panY = 0;
	cv.pan_active = false;//like mouse is down
	
	//cv.zoom_screen = UI.canvas_zoom_screen;
	cv.current_zoom = 1;
	cv.prev_zoom = [];
	cv.wheel_zoom_factor = 1.1;
	cv.quick_zoom_active = false;

	//cursor handling
	const init_cursor_size = 100;
	cv.cursor_posX = 0;
	cv.cursor_posY = 0;
	cv.cursor = document.createElement("canvas");
	cv.cursor_ctx = cv.cursor.getContext("2d");
	cv.cursor.width = init_cursor_size;
	cv.cursor.height = init_cursor_size;
	cv.cursor_size = init_cursor_size;
	cv.cursor_changed = true;
	cv.cursor_request_draw = false;
	
	//can lock position tracking from being updated
	//each lock request adds or removes 1 from lock counter
	cv.cursor_pos_lock = 0;
	
	cv.chamber_cursor = document.createElement("canvas");
	cv.chamber_cursor_ctx = cv.chamber_cursor.getContext("2d");
	cv.chamber_cursor.width = init_cursor_size;
	cv.chamber_cursor.height = init_cursor_size;
	
	if(current_tool == "brush_tool" || current_tool == "eraser_tool"){
		c_view.style.cursor = "none";
	}
	UI.brush_size_screen.style.display = "none";
	
}

canvasView.prototype = {

	openToolHand : function(){
		var cv = this;
		cv.pan_active = false;
		cv.pan_screen.style.cursor = "grab";
		cv.pan_screen.style.display="block";
		dynamic_ui_ctx.clearRect(0,0,dynamic_ui.width,dynamic_ui.height);
	},
	
	closeToolHand : function(){
		var cv = this;
		canvas_view.pan_active = false;
		canvas_view.pan_screen.style.display="none";
	},
	
	panStart : function(e){
		this.panX = e.x;
		this.panY = e.y;
		this.pan_screen.style.cursor = "grabbing";
	},
	panDo : function(e){
		var cv = this;
		cv.container.scrollLeft = cv.container.scrollLeft - e.x + cv.panX;
		cv.container.scrollTop = cv.container.scrollTop - e.y + cv.panY;
		cv.panX = e.x;
		cv.panY = e.y;
	},
	
	scroll : function(left,top){
		this.container.scrollLeft = left;
		this.container.scrollTop = top;
	},
	
	setZoom : function(zoom){
		var cv = this;
		var zoom_diff = cv.current_zoom/zoom;
		var old_zoom = cv.current_zoom;
		cv.current_zoom = zoom;
		
		UI.zoom_value.value = Math.round(zoom*10*10);
		
		live_view.style.width = (drawingAreaWidth*cv.current_zoom) + "px";
		live_view.style.height = (drawingAreaHeight*cv.current_zoom) + "px";
		
		dynamic_manipulation.style.width = (drawingAreaWidth*cv.current_zoom) + "px";
		dynamic_manipulation.style.height = (drawingAreaHeight*cv.current_zoom) + "px";
		
		cv.content.style.width = (drawingAreaWidth*cv.current_zoom) + "px";
		cv.content.style.height = (drawingAreaHeight*cv.current_zoom) + "px";
		//cv.content_border.style.width = (drawingAreaWidth*cv.current_zoom) + "px";
		//cv.content_border.style.height = (drawingAreaHeight*cv.current_zoom) + "px";
		
		//perform zoom size
		if(current_tool == "brush_tool" || current_tool == "eraser_tool"){
			if(current_bay.zoom_size){
				current_bay.setSize(current_bay.zoom_size_value / cv.current_zoom);
				updateUIBayValues();
			}
		}

	},
	
	setZoomDirect : function(zoom){
	//zoom by direct user input
		var cv = this;
		//zoom toggle store
		cv.prev_zoom[0] = cv.current_zoom;
		cv.prev_zoom[1] = cv.container.scrollLeft;
		cv.prev_zoom[2] = cv.container.scrollTop;
		
		cv.setZoom(zoom);
		//scroll to center
		cv.container.scrollLeft = c_view.offsetWidth - (c_view.offsetWidth - cv.content.offsetWidth)/2;
		cv.container.scrollTop = c_view.offsetHeight - (c_view.offsetHeight - cv.content.offsetHeight)/2;
	},
	
	zoomIn : function(factor){
		var cv = this;
		var zoom_factor = 1.0;
		if(factor != null){
			zoom_factor = factor;
		}else{
			zoom_factor = cv.wheel_zoom_factor;
		}
		
		var old_zoom = cv.current_zoom;
		cv.setZoom(cv.current_zoom*zoom_factor);
		//scroll toward mouse
		var c_rect = cv.content.getBoundingClientRect();
		cv.container.scrollLeft += Math.round((cv.cursor_posX-c_rect.x)*cv.current_zoom/old_zoom - (cv.cursor_posX-c_rect.x));
		cv.container.scrollTop += Math.round((cv.cursor_posY-c_rect.y)*cv.current_zoom/old_zoom - (cv.cursor_posY-c_rect.y));
	},
	
	zoomOut : function(factor){
		var cv = this;
		var zoom_factor = 1.0;
		if(factor != null){
			zoom_factor = factor;
		}else{
			zoom_factor = cv.wheel_zoom_factor;
		}
		
		var old_zoom = cv.current_zoom;
		
		//workaround:
		var zoom = cv.current_zoom/zoom_factor;
		var c_rect = cv.content.getBoundingClientRect();
		cv.container.scrollLeft += Math.round((cv.cursor_posX-c_rect.x)*zoom/old_zoom - (cv.cursor_posX-c_rect.x));
		cv.container.scrollTop += Math.round((cv.cursor_posY-c_rect.y)*zoom/old_zoom - (cv.cursor_posY-c_rect.y));
		cv.setZoom(zoom);
	},
	
	zoomFit : function(){
		var cv = this;
		
		var old_zoom = cv.current_zoom;
		cv.prev_zoom[0] = old_zoom;
		cv.prev_zoom[1] = cv.container.scrollLeft;
		cv.prev_zoom[2] = cv.container.scrollTop;
		
		//check for ratios to make zoomFit bound by width too
		if(c_view.offsetWidth / c_view.offsetHeight > drawingAreaWidth / drawingAreaHeight){
			cv.setZoom((c_view.offsetHeight-20) / drawingAreaHeight);
		}else{
			cv.setZoom((c_view.offsetWidth-20) / drawingAreaWidth);
		}
		//scroll to center
		cv.container.scrollLeft = c_view.offsetWidth - (c_view.offsetWidth - cv.content.offsetWidth)/2;
		cv.container.scrollTop = c_view.offsetHeight - (c_view.offsetHeight - cv.content.offsetHeight)/2;
	},
	
	zoomScaleOne : function(){
		var cv = this;
		
		var old_zoom = cv.current_zoom;
		cv.prev_zoom[0] = old_zoom;
		cv.prev_zoom[1] = cv.container.scrollLeft;
		cv.prev_zoom[2] = cv.container.scrollTop;
		
		//workaround:
		if(old_zoom > 1){
		//first scroll then zoom
			var c_rect = cv.content.getBoundingClientRect();
			cv.container.scrollLeft += (c_view.offsetWidth/2-c_rect.x)/old_zoom - (c_view.offsetWidth/2-c_rect.x);
			cv.container.scrollTop += (c_view.offsetHeight/2-c_rect.y)/old_zoom - (c_view.offsetHeight/2-c_rect.y);
			cv.setZoom(1);
		}else{
		//first zoom then scroll
			cv.setZoom(1);
			var c_rect = cv.content.getBoundingClientRect();
			cv.container.scrollLeft += (c_view.offsetWidth/2-c_rect.x)/old_zoom - (c_view.offsetWidth/2-c_rect.x);
			cv.container.scrollTop += (c_view.offsetHeight/2-c_rect.y)/old_zoom - (c_view.offsetHeight/2-c_rect.y);
		}
	},
	
	zoomToggle : function(){
		var cv = this;
		
		//
		var old_zoom = cv.current_zoom;
		var prev_left = cv.container.scrollLeft;
		var prev_top = cv.container.scrollTop;
		
		var prev_scroll_left = cv.prev_zoom[1];
		var prev_scroll_top = cv.prev_zoom[2];
		cv.setZoom(cv.prev_zoom[0]);
		cv.container.scrollLeft = prev_scroll_left;
		cv.container.scrollTop = prev_scroll_top;
		
		//
		cv.prev_zoom[0] = old_zoom;
		cv.prev_zoom[1] = prev_left;
		cv.prev_zoom[2] = prev_top;
		
	},
	
	makeCursor : function(cursor_type,b_size){
		var cv = this;
		
		var size = b_size*cv.current_zoom;
		
		if(cursor_type == "brush_tool" || cursor_type == "eraser_tool"){
			
			if(size < 10 || size > Math.min(dynamic_ui.width,dynamic_ui.height)*2){
				size = 21;
				
				cv.cursor.width = size;
				cv.cursor.height = size;
				cv.chamber_cursor.width = size;
				cv.chamber_cursor.height = size;
				
				
				cv.cursor_ctx.clearRect(0,0,cv.cursor.width,cv.cursor.height);
				
				cv.cursor_ctx.strokeStyle = "white";
				cv.cursor_ctx.lineWidth = "3";
				cv.cursor_ctx.beginPath();
				var mid_point = Math.round(size/2);
				cv.cursor_ctx.moveTo(0,mid_point);
				cv.cursor_ctx.lineTo(mid_point-4,mid_point);
				
				cv.cursor_ctx.moveTo(mid_point+3,mid_point);
				cv.cursor_ctx.lineTo(size,mid_point);
				
				cv.cursor_ctx.moveTo(mid_point,0);
				cv.cursor_ctx.lineTo(mid_point,mid_point-4);
				
				cv.cursor_ctx.moveTo(mid_point,mid_point+3);
				cv.cursor_ctx.lineTo(mid_point,size);
				
				cv.cursor_ctx.stroke();
				//
				cv.cursor_ctx.strokeStyle = "black";
				cv.cursor_ctx.lineWidth = "1";
				cv.cursor_ctx.beginPath();
				
				cv.cursor_ctx.moveTo(0,mid_point);
				cv.cursor_ctx.lineTo(mid_point-4,mid_point);
				
				cv.cursor_ctx.moveTo(mid_point+3,mid_point);
				cv.cursor_ctx.lineTo(size,mid_point);
				
				cv.cursor_ctx.moveTo(mid_point,0);
				cv.cursor_ctx.lineTo(mid_point,mid_point-4);
				
				cv.cursor_ctx.moveTo(mid_point,mid_point+3);
				cv.cursor_ctx.lineTo(mid_point,size);
				
				cv.cursor_ctx.stroke();
				
			}else{
				//expand circle a little
				size += 4;
				cv.cursor.width = size;
				cv.cursor.height = size;
				cv.chamber_cursor.width = size;
				cv.chamber_cursor.height = size;
				cv.cursor_ctx.clearRect(0,0,cv.cursor.width,cv.cursor.height);
			
				//ver 1 thick cursor
				//cv.cursor_ctx.lineWidth = "2";
				/* 
				cv.cursor_ctx.beginPath();
				cv.cursor_ctx.strokeStyle = "black";
				cv.cursor_ctx.arc(cv.cursor.width/2, cv.cursor.height/2,(size-2)/2, 0, 2 * Math.PI);
				cv.cursor_ctx.stroke();
				*/
				
				//ver 2 white circle
				/*
				cv.cursor_ctx.beginPath();
				cv.cursor_ctx.strokeStyle = "white";
				cv.cursor_ctx.arc(cv.cursor.width/2, cv.cursor.height/2,(size-4)/2, 0, 2 * Math.PI);
				cv.cursor_ctx.stroke();
				*/
				
				//ver 3 black with white outline
				//cv.cursor_ctx.translate(-0.5,-0.5);
				cv.cursor_ctx.lineWidth = "2";
				cv.cursor_ctx.strokeStyle = "black";
				cv.cursor_ctx.arc(cv.cursor.width/2, cv.cursor.height/2,(size-3)/2, 0, 2 * Math.PI);
				cv.cursor_ctx.stroke();
				
				//cv.cursor_ctx.translate(0.5,0.5);
				cv.cursor_ctx.lineWidth = "1";
				cv.cursor_ctx.strokeStyle = "white";
				cv.cursor_ctx.arc(cv.cursor.width/2, cv.cursor.height/2,(size-2)/2, 0, 2 * Math.PI);
				cv.cursor_ctx.stroke();
				
				
				
			}
		}
		cv.cursor_changed = true;
		cv.cursor_size = cv.cursor.width;
		return;
	},
	
	drawCursor : function(){
		if(current_tool != "brush_tool" && current_tool != "eraser_tool")return;
		const cv = this;
		var size = cv.cursor_size;
		var r = (size + (size%2))/2;

		//initial circle
		if(cv.cursor_changed == true){
			cv.chamber_cursor_ctx.clearRect(0,0,size,size);
			cv.chamber_cursor_ctx.drawImage(cv.cursor,0,0);
			cv.cursor_changed = false;
		}
		
		//update UI
		dynamic_ui_ctx.clearRect(0,0,dynamic_ui.width,dynamic_ui.height);
		dynamic_ui_ctx.drawImage(cv.chamber_cursor, cv.cursor_posX-r-dynamic_ui_rect_x, cv.cursor_posY-r-dynamic_ui_rect_y);
		
	},
	
	requestDrawCursor : function(){//cursor drawing optimization to fire once a frame
		if(current_tool != "brush_tool" && current_tool != "eraser_tool")return;
		const cv = this;
		if(cv.cursor_request_draw == false){
			cv.cursor_request_draw = true;
			requestAnimationFrame(function(){
				canvas_view.drawCursor();
				canvas_view.cursor_request_draw = false;
			});
		}
	},
	
	requestCursorPosLock : function(state){
	//for now the cursor_pos_lock is not in use
	//commented out in c_view and canvas_view.container binds
		var cv = this;
		if(state == true){
			cv.cursor_pos_lock++;
		}else{
			cv.cursor_pos_lock = Math.max(0, cv.cursor_pos_lock-1);
		}
	},
	
	resizeWindowView : function(){
		var cv = this;
		
		let c_view_rect = c_view.getBoundingClientRect();
		c_view_rect_x = c_view_rect.x;
		c_view_rect_y = c_view_rect.y;
		
		dynamic_ui.width = c_view.offsetWidth;
		dynamic_ui.height = c_view.offsetHeight;
		let dynamic_ui_rect = dynamic_ui.getBoundingClientRect();
		dynamic_ui_rect_x = dynamic_ui_rect.x;
		dynamic_ui_rect_y = dynamic_ui_rect.y;
		
		selection_module.selection_view.width = c_view.offsetWidth;
		selection_module.selection_view.height = c_view.offsetHeight;
		selection_module.selection_view_ctx.imageSmoothingEnabled = false;
		selection_module.selection_view_ctx.lineWidth = "1";
		selection_module.selection_view_ctx.strokeStyle = "red";
		
		selection_module.selection_view_mediator.width = c_view.offsetWidth;
		selection_module.selection_view_mediator.height = c_view.offsetHeight;
		selection_module.selection_view_mediator_ctx.imageSmoothingEnabled = false;
		
		selection_module.dynamic_view.width = c_view.offsetWidth;
		selection_module.dynamic_view.height = c_view.offsetHeight;
		selection_module.dynamic_view_ctx.imageSmoothingEnabled = false;
		selection_module.dynamic_view_ctx.fillStyle = "red";
		selection_module.dynamic_view_ctx.strokeStyle = "red";
		
		selection_module.resetCheckerboard(2);
	
		cv.content_border.style.paddingLeft = c_view.offsetWidth+"px";
		cv.content_border.style.paddingRight = c_view.offsetWidth+"px";
		cv.content_border.style.paddingTop = c_view.offsetHeight+"px";
		cv.content_border.style.paddingBottom = c_view.offsetHeight+"px";
	
		//
		cv.zoomFit();
		cv.makeCursor(current_tool,current_bay.size);
		//
		if(selection_module.selection_active == true){
			selection_module.makeSelectionOutline();
		}
	},
	
	canvasFadeIn : function(){
	//make things pretty
		var cv = this;
		cv.content.classList.toggle("general-fade-transition");
		cv.content.style.opacity = 0;
		void cv.content.clientWidth;
		cv.content.classList.toggle("general-fade-transition");
		cv.content.style.opacity = 1;
	}

}

var canvas_view = new canvasView();

//panning canvas
canvas_view.pan_screen.addEventListener("pointerdown", function(e){
	if(e.pointerType == "touch")return;
	this.setPointerCapture(e.pointerId);
	canvas_view.pan_active = true;
	canvas_view.panStart(e);
});
canvas_view.pan_screen.addEventListener("pointermove", function(e){
	if(e.pointerType == "touch")return;
	if(canvas_view.pan_active){
		canvas_view.panDo(e);
	}
});
canvas_view.pan_screen.addEventListener("pointerup", function(e){
	if(e.pointerType == "touch")return;
	canvas_view.pan_active = false;
	canvas_view.pan_screen.style.cursor = "grab";
});




//-----------------------------------Canvas View object structures END
//-----------------------------------Layer structures
//Folder struct - feature postponed or removed

//Layer struct
function layer(layer_name, layer_id){
	var l = this;
	
	if(layer_id != null){
		l.id = layer_id;
	}else{
		l.id = layer_counter;
	}
	
	l.name = layer_name;
	l.thisType = "layer";
	
	l.c = document.createElement("canvas");
	l.ctx = l.c.getContext("2d");
	l.c.width = drawingAreaWidth;
	l.c.height = drawingAreaHeight;
	l.ctx.clearRect(0,0,l.c.width,l.c.height);//addresses strange slowdowns when adding layers in bulk
	
	l.mask = null;
	l.mask_ctx = null;
	
	l.mask_enabled = false;
	
	l.target = "layer";
	
	l.visible = true;
	l.opacity = 1.0;
	
	l.clippingMask = null;
	l.clippingMask_ctx = null;
	l.clip = 0;//number of objects using this as a clipping mask
	
	
	l.blending = "source-over";//default blending
	//view representation of this layer / compilation of clipping mask, mask, layer, spree
	l.view = document.createElement("canvas");
	l.view_ctx = l.view.getContext("2d");
	l.view.width = l.c.width;
	l.view.height = l.c.height;
	l.view_ctx.clearRect(0,0,l.view.width,l.view.height);//addresses strange slowdowns when adding layers in bulk
	return 0;
}

layer.prototype = {
	setName : function(layer_name){
		var l = this;
		l.name = layer_name;
	},
	
	toggleVisibility : function(){
		var l = this;
		l.visible = !(l.visible);
	},
	
	setVisibility : function(val){
		this.visible = val;
	},
	
	setOpacity : function(opacity){
		var l = this;
		l.opacity = opacity/100;
	},
	
	setBlending : function(blending){
		var l = this;
		l.blending = blending;
	},
	
	copy : function(layer_obj,copy_id){
	//copies a given layer, including a clipping mask, view and target
	//(unlike duplicate general feature function)
		var l = this;
		
		//attributes
		if(copy_id != false){
			l.id = layer_obj.id;
		}
		l.name = layer_obj.name;
		l.visible = layer_obj.visible;
		l.opacity = layer_obj.opacity;
		l.blending = layer_obj.blending;
		l.target = layer_obj.target;
		
		//canvas
		l.c.width = layer_obj.c.width;
		l.c.height = layer_obj.c.height;
		l.ctx.clearRect(0,0, l.c.width,l.c.height);
		l.ctx.drawImage(layer_obj.c,0,0);
		
		//mask
		if(layer_obj.mask != null){
		//source layer has a mask
			if(l.mask == null){
			//destination layer has no mask, so create
				l.mask = document.createElement("canvas");
				l.mask_ctx = l.mask.getContext("2d");
			}
			l.mask.width = layer_obj.mask.width;
			l.mask.height = layer_obj.mask.height;
			l.mask_ctx.clearRect(0,0, l.mask.width,l.mask.height);
			l.mask_ctx.drawImage(layer_obj.mask,0,0);
			l.mask_enabled = layer_obj.mask_enabled;
		
		}else{
			l.mask = null;
			l.mask_ctx = null;
			l.mask_enabled = false;
		}
		
		//clipping mask
		if(layer_obj.clip > 0){
		//source layer is a clipping obj
			if(l.clippingMask == null){
			//destination layer is not a clipping obj, so create
				l.clippingMask = document.createElement("canvas");
				l.clippingMask_ctx = l.clippingMask.getContext("2d");
			}
			l.clippingMask.width = layer_obj.clippingMask.width;
			l.clippingMask.height = layer_obj.clippingMask.height;
			l.clippingMask_ctx.clearRect(0,0, l.clippingMask.width,l.clippingMask.height);
			l.clippingMask_ctx.drawImage(layer_obj.clippingMask,0,0);
			l.clip = layer_obj.clip;
		}else{
			l.clip = 0;
			l.clippingMask = null;
			l.clippingMask_ctx = null;
		}
		
		//view
		l.view.width = layer_obj.view.width;
		l.view.height = layer_obj.view.height;
		l.view_ctx.clearRect(0,0, l.view.width,l.view.height);
		l.view_ctx.drawImage(layer_obj.view,0,0);
		
	},
	
	updateView : function(){
		var l = this;
		
		l.view_ctx.clearRect(0,0,l.c.width,l.c.height);
		l.view_ctx.drawImage(l.c,0,0);
		
		//spree stacking
		if(selected_layer == this){
			if(toolset_mode == 2){
				l.view_ctx.globalCompositeOperation = "destination-out";
				l.view_ctx.drawImage(spree.view,0,0);
				l.view_ctx.globalCompositeOperation = "source-over";
			}else{
				l.view_ctx.drawImage(spree.view,0,0);
			}
			
		}
		
		if(l.mask_enabled == true && l.mask != null){
			l.view_ctx.globalCompositeOperation = "destination-in";
			l.view_ctx.drawImage(l.mask,0,0);
			l.view_ctx.globalCompositeOperation = "source-over";
		}
		
		//see if clipping mask needs to be updated as well
		if(this.clip > 0){
			this.updateClippingMask();
		}
		
	},
	
	addMask : function(empty_mask){
		var l = this;
		if(l.mask != null)return;
		l.mask = document.createElement("canvas");
		l.mask_ctx = l.mask.getContext("2d");
		l.mask.width = drawingAreaWidth;
		l.mask.height = drawingAreaHeight;
		
		l.mask_ctx.fillStyle="white";
		
		if(empty_mask == true){
			//no fill
		}else{
		//fill with opaque see all mask
			l.mask_ctx.fillRect(0,0,l.mask.width,l.mask.height);
		}
		
		l.mask_enabled = true;
	},
	
	clearMask : function(){
		this.mask_ctx.clearRect(0,0, this.mask.width,this.mask.height);
	},
	
	insertMask : function(source_layer){
		var l = this;
		//function to add a foreign mask to this layer
		l.mask = source_layer.mask;
		l.mask_ctx = source_layer.mask_ctx;
		l.mask_enabled = true;
		//restack view
		l.updateView();
	},
	
	removeMask : function(){
		var l = this;
		l.mask = null;
		l.mask_ctx = null;
		l.mask_enabled = false;
		//restack view
		l.updateView();
	},
	
	copyMask : function(source_layer){
		var l = this;
		//clear mask
		l.removeMask();
		l.addMask(true);
		//draw source mask
		l.mask_ctx.drawImage(source_layer.mask, 0,0);
		//restack view
		l.updateView();
	},
	
	toggleMask : function(){
		var l = this;
		l.mask_enabled = !(l.mask_enabled);
		//restack view
		l.updateView();
	},
	
	applyMask : function(){
		var l = this;
		l.ctx.clearRect(0,0,l.c.width,l.c.height);
		l.ctx.drawImage(l.view,0,0);
		this.removeMask();
	},
	
	addClippingMask : function(){
		var l = this;
		if(l.clippingMask == null){
			l.clippingMask = document.createElement("canvas");
			l.clippingMask_ctx = l.clippingMask.getContext("2d");
			l.clippingMask.width = l.view.width;
			l.clippingMask.height = l.view.height;
		}
		l.clippingMask_ctx.clearRect(0,0,l.clippingMask.width,l.clippingMask.height);
		l.clippingMask_ctx.drawImage(l.view,0,0);
		makeCanvasContentOpaque(l.clippingMask,l.clippingMask_ctx);
		l.setClip(1);
	},
	
	updateClippingMask : function(){
		var l = this;
		if(l.clippingMask.width != l.view.width || l.clippingMask.height != l.view.height){
			l.clippingMask.width = l.view.width;
			l.clippingMask.height = l.view.height;
		}
		l.clippingMask_ctx.clearRect(0,0,l.clippingMask.width,l.clippingMask.height);
		l.clippingMask_ctx.drawImage(l.view,0,0);
		makeCanvasContentOpaque(l.clippingMask,l.clippingMask_ctx);
	},
	
	setClip : function(n){
		this.clip = n;
	},
	
	getClip : function(){
		return this.clip;
	},
	
	setTarget : function(target){
	
		if(target == "mask" && this.mask == null)return;
		
		this.target = target;
	},
	
	clearTargetContent : function(){
		var l = this;
		
		if(l.target == "layer"){
			l.ctx.clearRect(0,0, l.c.width,l.c.height);
		}else if(l.target == "mask"){
			l.mask_ctx.clearRect(0,0, l.mask.width,l.mask.height);
		}
		l.updateView();
	},
	
	fill : function(color){
		let color_store = this.ctx.fillStyle;
		this.ctx.fillStyle = color;
		this.ctx.fillRect(0,0, this.c.width, this.c.height);
		this.ctx.fillStyle = color_store;
		
		this.updateView();
	},
	
	fillMask : function(color){
		if(this.mask == null)return;
		
		let color_store = this.mask_ctx.fillStyle;
		this.mask_ctx.fillStyle = color;
		this.mask_ctx.fillRect(0,0, this.mask.width,this.mask.height);
		this.mask_ctx.fillStyle = color_store;
		
		this.updateView();
	},
	
	//expected input 1 or -1 for each
	flipCanvas : function(scaleX,scaleY){
		var l = this;
		chamber_buffer[0].put(l.c);
		l.ctx.translate(-l.c.width * ((-1+scaleX)/2), -l.c.height * ((-1+scaleY)/2));
		l.ctx.scale(scaleX,scaleY);
		chamber_buffer[0].output(l.ctx);
		l.ctx.setTransform(1, 0, 0, 1, 0, 0);
		
		if(l.mask != null){
			chamber_buffer[0].put(l.mask);
			l.mask_ctx.translate(-l.mask.width * ((-1+scaleX)/2), -l.mask.height * ((-1+scaleY)/2));
			l.mask_ctx.scale(scaleX,scaleY);
			chamber_buffer[0].output(l.mask_ctx);
			l.mask_ctx.setTransform(1, 0, 0, 1, 0, 0);
		}
		
		l.updateView();
	},
	
	//new width, height, and quadrant for original to remain
	resizeCanvas : function(w,h,contentOffsetX,contentOffsetY){
		var l = this;
		chamber_buffer[0].put(l.c);
		l.c.width = w;
		l.c.height = h;
		chamber_buffer[0].output(l.ctx,l.c, contentOffsetX,contentOffsetY);
		
		if(l.mask != null){
			chamber_buffer[0].put(l.mask);
			l.mask.width = w;
			l.mask.height = h;
			chamber_buffer[0].output(l.mask_ctx,l.mask, contentOffsetX,contentOffsetY);
		}
		
		//clipping mask exists
		if(l.clip > 0){
			l.clippingMask.width = w;
			l.clippingMask.height = h;
		}
		
		l.view.width = w;
		l.view.height = h;
		
		l.updateView();
	},
	
	resizeImage : function(w,h,antialias){
		var l = this;
		
		chamber_buffer[0].put(l.c);
		l.c.width = w;
		l.c.height = h;
		l.ctx.clearRect(0,0, w,h);
		
		if(antialias == false){
			l.ctx.imageSmoothingEnabled = false;
			l.ctx.drawImage(chamber_buffer[0].c,0,0,w,h);
			l.ctx.imageSmoothingEnabled = true;
		}else{
		//smooth by default
			l.ctx.imageSmoothingQuality = "high";
			l.ctx.drawImage(chamber_buffer[0].c,0,0,w,h);
		}
		
		
		if(l.mask != null){
			chamber_buffer[0].put(l.mask);
			l.mask.width = w;
			l.mask.height = h;
			l.mask_ctx.clearRect(0,0, w,h);
			
			
			if(antialias == false){
				l.mask_ctx.imageSmoothingEnabled = false;
				l.mask_ctx.drawImage(chamber_buffer[0].c,0,0,w,h);
				l.mask_ctx.imageSmoothingEnabled = true;
			}else{
				l.mask_ctx.imageSmoothingQuality = "high";
				l.mask_ctx.drawImage(chamber_buffer[0].c,0,0,w,h);
			}
			
			
		}
		
		//clipping mask exists
		if(l.clip > 0){
			l.clippingMask.width = w;
			l.clippingMask.height = h;
		}
		
		l.view.width = w;
		l.view.height = h;
		
		l.updateView();
	},
	
	cropCanvas : function(x,y,w,h){
		var l = this;
		
		chamber_buffer[0].put(l.c, x,y, w,h);
		l.c.width = w;
		l.c.height = h;
		chamber_buffer[0].output(l.ctx);
		
		if(l.mask != null){
			chamber_buffer[0].put(l.mask, x,y, w,h);
			l.mask.width = w;
			l.mask.height = h;
			chamber_buffer[0].output(l.mask_ctx);
		}
		
		//clipping mask exists
		if(l.clip > 0){
			l.clippingMask.width = w;
			l.clippingMask.height = h;
		}
		
		l.view.width = w;
		l.view.height = h;
		
		l.updateView();
	},
	
	rotateCanvas90 : function(direction){
		var l = this;
		var w = l.view.width;
		var h = l.view.height;
		
		rotateCanvasObj90(l.c,l.ctx, direction);
		
		if(l.mask != null){
			rotateCanvasObj90(l.mask,l.mask_ctx, direction);
		}
		
		if(l.clip > 0){
			l.clippingMask.width = h;
			l.clippingMask.height = w;
		}
		
		l.view.width = h;
		l.view.height = w;
		
		l.updateView();
	}

}

//book keeper
/*single level array with layer and folder objects that can be inserted and removed at index
this is where user layers and folder are organized
*/
function bookKeeper(){
	var bk = this;
	//current project meta data
	bk.proj_meta = {};
	bk.proj_meta.name = "Untitled-1";
	bk.proj_meta.opid_stamp = 0;//for tracking project saves
	//
	
	bk.contents = [];
	
	//position index to be used by outside functions to loop through contents
	bk.pos = 0;
	bk.folder_pos = 0;//cross-function index of the last encountered folder
	
	bk.drag_layer_i = 0;
	
	//to support broken chrome pointer drag n drop events
	bk.drag_mouseIsDown = false;
	bk.drag_drop_active = false;
	bk.drag_obj_type = "layer";
	bk.drag_timeout = null;
	//
	
	bk.layer_width = drawingAreaWidth;
	bk.layer_height = drawingAreaHeight;
	
	bk.layer_id_index_map = {};//layer ids in layers order arrangement
	bk.layer_clip_map = [];//clipping mask arrangement
	bk.layer_id_mask_map = {};
	
	return 0;
}

bookKeeper.prototype = {
	
	add : function(obj){
		var bk = this;
		bk.contents.push(obj);
	},
	
	addAtIndex : function(obj,index){
		var bk = this;
		bk.contents.splice(index,0,obj);
	},
	
	removeAtIndex : function(index){
		var bk = this;
		if(bk.contents.length < 2)return;
		
		bk.contents.splice(index,1);

	},
	
	move : function(from_index,to_index){//index from, index to, 0 or 1 inside a folder or not
		var bk = this;
		if(from_index == to_index)return;
		
		var move_copy = bk.contents[from_index];
		bk.removeAtIndex(from_index);
		bk.addAtIndex(move_copy,to_index);
	},
	
	makeNewLayerList : function(){
	//re-lists contents into a new array
	//primarily used together with history module for undo/redo
		var bk = this;
		var layer_list = [];
		for(var i=0;i<bk.contents.length;i++){
			layer_list[i] = bk.contents[i];
		}
		bk.contents = layer_list;
	},
	
	updateIdIndexMap : function(){
	//creates new layer id index map
		var bk = this;
		bk.layer_id_index_map = {};
		for(var i=0;i<bk.contents.length;i++){
			bk.layer_id_index_map[bk.contents[i].id] = i;
		}
	},
	
	updateClipMap : function(){
	//creates new layer clip map	
		var bk = this;
		bk.layer_clip_map = [];
		for(var i=0;i<bk.contents.length;i++){
			bk.layer_clip_map[i] = bk.contents[i].clip;
		}
	},
	
	updateIdMaskMap : function(){
	//creates new layer id : mask map
		var bk = this;
		bk.layer_id_mask_map = {};
		for(var i=0;i<bk.contents.length;i++){
			if(bk.contents[i].mask == null){
				bk.layer_id_mask_map[ bk.contents[i].id ] = null;
			}else{
				bk.layer_id_mask_map[ bk.contents[i].id ] = [bk.contents[i].mask,
											  bk.contents[i].mask_ctx,
											  bk.contents[i].mask_enabled];
			}
		}
	},
	
	arrangeLayers : function(){
		var bk = this;
		var layer_list = [];
		//make a list of all layers
		for(var i=0;i<bk.contents.length;i++){
			layer_list[i] = bk.contents[i];
		}
		//arrange layers by layer_id_index_map
		for(i=0;i<layer_list.length;i++){
			if(bk.layer_id_index_map[ layer_list[i].id ] !== undefined){
				bk.contents[ bk.layer_id_index_map[ layer_list[i].id ] ] = layer_list[i];
			}
		}
	},
	
	arrangeClip : function(){
		var bk = this;
		for(var i=0;i<bk.layer_clip_map.length;i++){
			if(bk.contents[i].clip != bk.layer_clip_map[i]){
				if(bk.contents[i].clippingMask == null){
					bk.contents[i].addClippingMask();
				}
				bk.contents[i].setClip(bk.layer_clip_map[i]);
			}
		}
	},
	
	arrangeMasks : function(){
		var bk = this;
		for(var i=0;i<bk.contents.length;i++){
			if(bk.layer_id_mask_map[ bk.contents[i].id ] == null){
				
				if(bk.contents[i].mask != null){
				//null the existing mask
					bk.contents[i].mask = null;
					bk.contents[i].mask_ctx = null;
					bk.contents[i].mask_enabled = false;
					
					//non-existing mask target handling
					if(bk.contents[i].target == "mask")bk.contents[i].target = "layer";
					
					bk.contents[i].updateView();
				}
			}else{
				bk.contents[i].mask = bk.layer_id_mask_map[ bk.contents[i].id ][0];
				bk.contents[i].mask_ctx = bk.layer_id_mask_map[ bk.contents[i].id ][1];
				bk.contents[i].mask_enabled = bk.layer_id_mask_map[ bk.contents[i].id ][2];
				bk.contents[i].updateView();
			}
		}
	},
	
	getAtIndex : function(index){
		return this.contents[index];
	},
	
	flatten : function(){
		this.contents = [];
		var flat_layer = new layer("Flat Layer");
		this.add(flat_layer);
		flat_layer.ctx.drawImage(live_view,0,0);
		flat_layer.updateView();
	},
	
	removeMultiple : function(index_list){
		var bk = this;
		//recompose the whole bookKeeper contents
		var c_n = [];//contents new
		var j = 0;
		for(var i=0;i<bk.contents.length;i++){
			if(j<index_list.length && index_list[j] == i){
				j++;
			}else{
				c_n.push(bk.contents[i]);
			}
		}
		bk.contents = c_n;
	},
	
	toggleVisibilityMultiple : function(){
		var bk = this;
		var found_hidden = false;
		var toggle_val = false;
		//search for not visible layers
		for(var i=0;i<selected_layer_multi.length;i++){
			if(bk.contents[selected_layer_multi[i]].visible == false){
				found_hidden = true;
				break;
			}
		}
		
		//if found not visible layers all selected layers go visible
		if(found_hidden == true){
			toggle_val = true;
		}//otherwise hide all selected layers
		
		for(var i=0;i<selected_layer_multi.length;i++){
			bk.contents[selected_layer_multi[i]].setVisibility(toggle_val);
			
		}
	},
	
	flipCanvas : function(scaleX,scaleY){
		var bk = this;
		for(var i=0;i<bk.contents.length;i++){
			bk.contents[i].flipCanvas(scaleX,scaleY);
		}
	},
	
	resizeCanvas : function(w,h,contentOffsetX,contentOffsetY){
		var bk = this;
		for(var i=0;i<bk.contents.length;i++){
			bk.contents[i].resizeCanvas(w,h,contentOffsetX,contentOffsetY);
		}
		bk.layer_width = w;
		bk.layer_height = h;
	},
	
	resizeImage : function(w,h,antialias){
		var bk = this;
		for(var i=0;i<bk.contents.length;i++){
			bk.contents[i].resizeImage(w,h,antialias);
		}
	},
	
	cropCanvas : function(x,y,w,h){
		var bk = this;
		for(var i=0;i<bk.contents.length;i++){
			bk.contents[i].cropCanvas(x,y,w,h);
		}
	},
	
	rotateCanvas90 : function(direction){
		var bk = this;
		for(var i=0;i<bk.contents.length;i++){
			bk.contents[i].rotateCanvas90(direction);
		}
	},
	
	stampOPID : function(){
	//stamps latest history opid, 
	//counting this point to be the latest project save
		this.proj_meta.opid_stamp = history_keeper.getOPID();
	},
	
	getOPIDStamp : function(){
		return this.proj_meta.opid_stamp;
	}
	
}
//------------

function spreeLayer(){
	var s = this;
	s.c = document.createElement("canvas");
	s.ctx = s.c.getContext("2d");
	s.c.width = drawingAreaWidth;
	s.c.height = drawingAreaHeight;
	//s.ctx.clearRect(0,0,s.c.width,s.c.height);
	
	s.view = document.createElement("canvas");
	s.view_ctx = s.view.getContext("2d");
	s.view.width = s.c.width;
	s.view.height = s.c.height;
	//s.view_ctx.clearRect(0,0,s.view.width,s.view.height);
}

spreeLayer.prototype = {
	update : function(){
		var s = this;
		s.ctx.clearRect(0,0,s.c.width,s.c.height);
		s.ctx.drawImage(s.view,0,0);
	},
	
	clear : function(){
		var s = this;
		s.ctx.clearRect(0,0,s.c.width,s.c.height);
		s.view_ctx.clearRect(0,0,s.view.width,s.view.height);
	},
	
	//expected input 1 or -1 for each
	flipCanvas : function(scaleX,scaleY){
		var s = this;
		chamber_buffer[0].put(s.view);
		s.view_ctx.translate(-s.view.width * ((-1+scaleX)/2), -s.view.height * ((-1+scaleY)/2));
		s.view_ctx.scale(scaleX,scaleY);
		chamber_buffer[0].output(s.view_ctx);
		s.view_ctx.setTransform(1, 0, 0, 1, 0, 0);
		
		s.update();
	},
	
	setCanvasSize : function(w,h){
		var s = this;
		s.c.width = w;
		s.c.height = h;
		s.view.width = w;
		s.view.height = h;
	},
	
	//expected a solidifySpree call prior to this
	resizeCanvas : function(w,h){
		this.setCanvasSize(w,h);
	},
	
	//expected a solidifySpree call prior to this
	resizeImage : function(w,h){
		this.setCanvasSize(w,h);
	},
	
	//expected a solidifySpree call prior to this
	cropCanvas : function(x,y,w,h){
		this.setCanvasSize(w,h);
	},
	
	rotateCanvas90 : function(direction){
		var s = this;
		rotateCanvasObj90(s.c,s.ctx, direction);
		rotateCanvasObj90(s.view,s.view_ctx, direction);
	}
}

//-----------------------------------Layer structures END

//-----------------------------------History Structures


//
function historyLineSnapshot(num,name,obj,obj_attr){
	var hc = this;
	hc.storeType = "snapshot";
	hc.name = name;//name of this changes line, for example spree
	hc.states = [];
	
	hc.target = obj;
	hc.target_attr = obj_attr;
	
	hc.num_states = num;
	
	
	for(var i=0;i<num;i++){
		hc.states.push({
				"layers" : [],
				"selection" : new canvasBuffer(null,1,1)
			});
	}
	
	hc.swap_buffer = null;
	hc.swap_buffer_canvas = new canvasBuffer(null,1,1);
	
	hc.state_i = 0;
	hc.start = 0;
	hc.end = 0;
}

historyLineSnapshot.prototype = {
	add : function(){
		var hc = this;
		
		hc.state_i = (hc.state_i+1+hc.num_states) % hc.num_states;
		hc.end = hc.state_i;
		
		if(hc.start == hc.end){
			hc.start = (hc.end+1+hc.num_states) % hc.num_states;
		}
		
		
		var layers_snapshot = [];
		hc.states[hc.state_i].layers = [];
		for(var i=0;i<gf.contents.length;i++){
			let layer_copy = new layer("layer");
			
			layer_copy.copy(gf.contents[i]);
			layers_snapshot[i] = layer_copy;
			
		}
		
		hc.states[hc.state_i].selection.put(selection_module.selection);
		
		hc.states[hc.state_i].layers = gf.contents;
		gf.contents = layers_snapshot;
		selected_layer = gf.contents[selected_layer_i];
	},
	
	swap : function(){
		var hc = this;
		hc.swap_buffer = gf.contents;
		
		gf.contents = hc.states[hc.state_i].layers;
		hc.states[hc.state_i].layers = hc.swap_buffer;
		hc.swap_buffer = null;
		
		//size things properly
		gf.layer_width = gf.contents[0].c.width;
		gf.layer_height = gf.contents[0].c.height;
		
		//selection to buffer
		hc.swap_buffer_canvas.put(selection_module.selection);
		
		//size things properly
		if(drawingAreaWidth != gf.layer_width || drawingAreaHeight != gf.layer_height){
			
			drawingAreaWidth = gf.layer_width;
			drawingAreaHeight = gf.layer_height;
			spree.resizeCanvas(drawingAreaWidth,drawingAreaHeight);
			selection_module.resizeCanvas(drawingAreaWidth,drawingAreaHeight);

			live_view.width = drawingAreaWidth;
			live_view.height = drawingAreaHeight;
			live_view.style.width = drawingAreaWidth + "px";
			live_view.style.height = drawingAreaHeight + "px";
			
			brush_mediator_opacity.width = drawingAreaWidth;
			brush_mediator_opacity.height = drawingAreaHeight;
			
			brush_mediator_flow.width = drawingAreaWidth;
			brush_mediator_flow.height = drawingAreaHeight;
			
		}
		
		//selection
		hc.states[hc.state_i].selection.output(selection_module.selection_ctx);
		hc.states[hc.state_i].selection.put(hc.swap_buffer_canvas.c);
		
	},
	
	back : function(){
		var hc = this;
		if(hc.state_i == hc.start)return;
		
		hc.state_i = (hc.state_i-1+hc.num_states) % hc.num_states;
		
		return (hc.states[hc.state_i]);
	},
	
	next : function(){
		var hc = this;
		if(hc.state_i == hc.end)return;
		
		hc.state_i = (hc.state_i+1+hc.num_states) % hc.num_states;
		return (hc.states[hc.state_i]);
	},
	
	getCurrent : function(){
		return (this.states[this.state_i]);
	}
}

//
function historyLineCanvas(num,name,obj_c,obj_ctx){
	var hc = this;
	hc.storeType = "canvas";
	hc.name = name;//name of this changes line, for example spree
	hc.states = [];
	hc.area_rect = [];//area rectangle occupied by stored content [x,y,w,h]
	
	hc.target = obj_c;//function object that helps get proper information real-time
	hc.target_ctx = obj_ctx;
	
	//when active means to store only given area, otherwise store whole canvas
	//[do area, x1, y1, x2, y2]; note: x2 y2 are end points of the area
	//expected that it may be modified from outside
	hc.target_area = [false, drawingAreaWidth, drawingAreaHeight, 0, 0];
	
	hc.num_states = num;
	
	for(let i=0;i<num;++i){
		//hc.states.push(new canvasBuffer(null,drawingAreaWidth,drawingAreaHeight));
		hc.states.push(new canvasBuffer());
		hc.area_rect.push([false,0,0,0,0]);
	}
	
	hc.swap_buffer = new canvasBuffer(null,drawingAreaWidth,drawingAreaHeight);
	
	hc.state_i = 0;
	hc.start = 0;
	hc.end = 0;
	
}

historyLineCanvas.prototype = {
	add : function(){
		var hc = this;
		
		hc.state_i = (hc.state_i+1+hc.num_states) % hc.num_states;
		hc.end = hc.state_i;
		
		if(hc.start == hc.end){
			hc.start = (hc.end+1+hc.num_states) % hc.num_states;
		}
		
		if(hc.target_area[0] == true){//area rect
			let target_area = hc.target_area;
			let state_i = hc.state_i;
			let state = hc.states[state_i];
			let x = target_area[1];
			let y = target_area[2];
			let w = target_area[3] - x;
			let h = target_area[4] - y;
			/*
			state.clear();
			state.ctx.drawImage(hc.target(), x,y,w,h, x,y,w,h);
			state.empty = false;
			*/
			state.put(hc.target(), x,y,w,h);
			
			hc.area_rect[state_i] = [true,x,y,w,h];
			hc.resetTargetAreaRect();
		}else{
			hc.area_rect[hc.state_i][0] = false;
			
			hc.states[hc.state_i].put(hc.target());
		}
	},
	
	swap : function(){
		var hc = this;
		
		let area_rect = hc.area_rect[hc.state_i];
		if(area_rect[0] == true){
			hc.swap_buffer.put(hc.target(), area_rect[1],area_rect[2],area_rect[3],area_rect[4]);
			hc.states[hc.state_i].output(hc.target_ctx(),null, area_rect[1],area_rect[2]);
		}else{
			hc.swap_buffer.put(hc.target());
			hc.states[hc.state_i].output(hc.target_ctx(),hc.target());
		}
		hc.states[hc.state_i].put(hc.swap_buffer.c);
		
	},
	
	notifyTargetAreaRect : function(x,y, x_end, y_end){
		//does min max over multiple calls to calculate target rectangle area
		let target_area = this.target_area;
		
		if(x < target_area[1]){
			target_area[1] = x;
		}
		if(y < target_area[2]){
			target_area[2] = y;
		}
		if(x_end > target_area[3]){
			target_area[3] = x_end;
		}
		if(y_end > target_area[4]){
			target_area[4] = y_end;
		}
	},
	
	resetTargetAreaRect : function(){
		let target_area = this.target_area;
		target_area[0] = false;
		target_area[1] = drawingAreaWidth;
		target_area[2] = drawingAreaHeight;
		target_area[3] = 0;
		target_area[4] = 0;
	},
	
	/*
	updateCurrent : function(c){
		this.states[this.state_i].put(this.target());
	},
	*/
	
	back : function(){
		var hc = this;
		if(hc.state_i == hc.start)return;
		
		hc.state_i = (hc.state_i-1+hc.num_states) % hc.num_states;
		
		return (hc.states[hc.state_i]);
	},
	
	next : function(){
		var hc = this;
		if(hc.state_i == hc.end)return;
		
		hc.state_i = (hc.state_i+1+hc.num_states) % hc.num_states;
		
		return (hc.states[hc.state_i]);
	},
	
	getCurrent : function(){
		return (this.states[this.state_i]);
	}
}

//

function historyLineData(num,name,obj,obj_attr){
	var hc = this;
	hc.storeType = "data";
	hc.name = name;//name of this "changes line", for example spree
	hc.states = [];
	
	hc.target = obj;//function object that helps get proper information real-time
	hc.target_attr = obj_attr;
	
	hc.num_states = num;
	
	for(var i=0;i<num;i++){
		hc.states.push(null);
	}
	
	hc.swap_buffer = null;
	
	hc.state_i = 0;
	hc.start = 0;
	hc.end = 0;
}

historyLineData.prototype = {
	add : function(){
		var hc = this;
		
		hc.state_i = (hc.state_i+1+hc.num_states) % hc.num_states;
		hc.end = hc.state_i;
		
		if(hc.start == hc.end){
			hc.start = (hc.end+1+hc.num_states) % hc.num_states;
		}
		
		hc.states[hc.state_i] = hc.target()[hc.target_attr];
	},
	
	updateCurrent : function(){
		this.states[this.state_i] = this.target()[this.target_attr];
	},
	
	swap : function(){
		var hc = this;
		hc.swap_buffer = hc.target()[hc.target_attr];
		hc.target()[hc.target_attr] = hc.states[hc.state_i];
		hc.states[hc.state_i] = hc.swap_buffer;
		
	},
	
	back : function(){
		var hc = this;
		if(hc.state_i == hc.start)return;
		
		hc.state_i = (hc.state_i-1+hc.num_states) % hc.num_states;
		
		return (hc.states[hc.state_i]);
	},
	
	next : function(){
		var hc = this;
		if(hc.state_i == hc.end)return;
		
		hc.state_i = (hc.state_i+1+hc.num_states) % hc.num_states;
		return (hc.states[hc.state_i]);
	},
	
	getCurrent : function(){
		return (this.states[this.state_i]);
	}
}

//

function historyItem(){
	var h = this;
	h.type = "";
	h.tool_name = "";//name of operation or a tool
	h.toolset_mode = 1;
	h.layer_i = 0;//index of a layer that was affected
	h.data = null;
	
	//for user convenience, to go next state, for intermittent actions like layer selection
	h.bypass = false;
	h.occupied = false;
}

historyItem.prototype = {
	//spree etc are canvases, not the module objects
	//target is the selected layer object
	store : function(type,tool_name,toolset_mode,layer_i){
		var h = this;
		
		h.type = type;
		h.tool_name = tool_name;
		h.toolset_mode = toolset_mode;
		h.layer_i = layer_i;
		
		//console.log("storing");
	},
	
	get : function(val){
		return this[val];
	}
}

//keeper
//profiles for "custom" type state save. For easier calls
const historyProfileList = {
	//"label" : ["spree","layer","etc"]
	"placeholder" : []
}
/*
Basic overview of history implementation:
historyItem stores basic operation info 
historyLine stores and swaps target attributes
historyModule can have own implementations of store, undo, redo 
for each type of operation, and uses lines to manipulate attributes as needed
State is saved BEFORE action takes place, and swapped on undo/redo.
^live object is treated as a state.
*/
function historyModule(){
	var hm = this;
}

historyModule.prototype = {
	
	init : function(num_states){
		var hm = this;
		
		//
		hm.states = [];
		
		hm.lines = {};
		
		hm.state_i = 0;
		hm.start = 0;
		hm.end = 0;
		
		//counts state modifications, also applies to undo and redo
		//can be useful for example for moveModule target sampling
		hm.docVer = 0;
		
		//operation id, increments on every store, doesn't decrement
		//keeps track of history storable operations
		hm.opid = 0;
		//
		
		hm.num_states = Math.max(1,num_states);
		hm.states = [];
		for(var i=0;i<hm.num_states;i++){
			hm.states.push(new historyItem());
		}
		
		hm.lines.snapshot = new historyLineSnapshot(hm.num_states,"snapshot",function(){return gf},"contents");
		
		hm.lines.layerList = new historyLineData(hm.num_states, "layerList", function(){return gf},"contents");
		hm.lines.layerClipMap = new historyLineData(hm.num_states, "layerClipMap", function(){return gf},"layer_clip_map");
		hm.lines.layerIdIndexMap = new historyLineData(hm.num_states, "layerIdIndexMap", function(){return gf},"layer_id_index_map");
		hm.lines.layerIdMaskMap = new historyLineData(hm.num_states, "layerIdMaskMap", function(){return gf},"layer_id_mask_map");
		
		hm.lines.spree = new historyLineCanvas(hm.num_states,"spree",function(){return spree.c;},function(){return spree.ctx;});
		hm.lines.selection = new historyLineCanvas(hm.num_states,"selection",function(){return selection_module.selection;},function(){return selection_module.selection_ctx;});
		hm.lines.mask = new historyLineCanvas(hm.num_states,"mask",function(){return selected_layer.mask;},function(){return selected_layer.mask_ctx;});
		hm.lines.layer = new historyLineCanvas(hm.num_states,"layer",function(){return selected_layer.c;},function(){return selected_layer.ctx;});
		
		hm.lines.layerName = new historyLineData(hm.num_states,"layerName",function(){return selected_layer},"name");
		hm.lines.layerOpacity = new historyLineData(hm.num_states,"layerOpacity",function(){return selected_layer},"opacity");
		hm.lines.layerBlending = new historyLineData(hm.num_states,"layerBlending",function(){return selected_layer},"blending");
		
		hm.lines.moveTranslateX = new historyLineData(hm.num_states,"moveTranslateX", function(){return move_module;},"move_offsetX");
		hm.lines.moveTranslateY = new historyLineData(hm.num_states,"moveTranslateY", function(){return move_module;},"move_offsetY");
		hm.lines.moveTransformW = new historyLineData(hm.num_states,"moveTransformW", function(){return move_module.transform;},"w");
		hm.lines.moveTransformH = new historyLineData(hm.num_states,"moveTransformH", function(){return move_module.transform;},"h");
		hm.lines.moveTransformAngle = new historyLineData(hm.num_states,"moveTransformAngle", function(){return move_module.transform;},"angle");
		
		//NOTE: make initial snapshot for each line
		//^ or take a full snapshot state as the first open document fall-back
		//^ this will need to be done after whole program/gf initializes
		
	},
	
	opTrack : function(){
	//tracks operations from modules per request, for example nudge
	//these operations don't do store
		this.opid++;
	},
	
	store : function(type,tool_name,toolset_mode,layer_i,data){
		var hm = this;
		
		var current_state = hm.states[hm.state_i];
		
		//no two solidifySpree in a row
		if(current_state.type == "solidifySpree" && type == current_state.type){
			return;
		}
		
		if(current_state.occupied == true){
		
			//increment / make new state
			hm.state_i = (hm.state_i+1+hm.num_states) % hm.num_states;
			hm.end = hm.state_i;
			
			//bump start forward if reached limit of states
			if(hm.start == hm.end){
				hm.start = (hm.end+1+hm.num_states) % hm.num_states;
			}
			//console.log(hm.state_i);
			current_state = hm.states[hm.state_i];
			
			current_state.occupied = false;
			current_state.bypass = false;
		}
		
		switch(type){
			case "spree":
				hm.states[hm.state_i].data = data;
				hm.states[hm.state_i].store(type,tool_name,toolset_mode,layer_i);
				hm.lines.spree.add();
			break;
			//
			case "custom":
			//custom multi-line store, based on provided data[type,...]
				hm.states[hm.state_i].data = data;
				hm.states[hm.state_i].store(type,tool_name,toolset_mode,layer_i);
				for(var i=0;i<data.length;i++){
					hm.lines[data[i]].add();
				}
			break;
			//
			case "moveModule":
			//custom multi-line store, based on provided data[type,...]
			//similar to custom, moveModule can set lines to use
				hm.states[hm.state_i].data = data;
				hm.states[hm.state_i].store(type,tool_name,toolset_mode,layer_i);
				for(var i=0;i<data.length;i++){
					hm.lines[data[i]].add();
				}
			break;
			//
			case "solidifySpree":
				current_state.data = data;
				current_state.store(type,"solidifySpree",toolset_mode,layer_i);
				hm.lines.layer.add();
				hm.lines.spree.add();
				current_state.bypass = true;
			break;
			//
			case "layerMaskApply":
				hm.states[hm.state_i].data = data;
				hm.states[hm.state_i].store(type,tool_name,toolset_mode,layer_i);
				hm.lines.layerIdMaskMap.add();
				hm.lines.layer.add();
			break;
			//
			case "rotateCanvas90":
				hm.states[hm.state_i].data = data;
				hm.states[hm.state_i].store(type,tool_name,toolset_mode,layer_i);
			break;
			//
			case "flipCanvas":
				hm.states[hm.state_i].data = data;
				hm.states[hm.state_i].store(type,tool_name,toolset_mode,layer_i);
			break;
			//
			case "layerList":
				hm.states[hm.state_i].data = data;
				hm.states[hm.state_i].store(type,tool_name,toolset_mode,layer_i);
				hm.lines.layerList.add();
				hm.lines.layerClipMap.add();
			break;
			//
			case "arrangeLayers":
				hm.states[hm.state_i].data = data;
				hm.states[hm.state_i].store(type,tool_name,toolset_mode,layer_i);
				hm.lines.layerIdIndexMap.add();
				hm.lines.layerClipMap.add();
			break;
			//
			case "arrangeClip":
				hm.states[hm.state_i].data = data;
				hm.states[hm.state_i].store(type,tool_name,toolset_mode,layer_i);
				hm.lines.layerClipMap.add();
			break;
			//
			case "arrangeMasks":
				hm.states[hm.state_i].data = data;
				hm.states[hm.state_i].store(type,tool_name,toolset_mode,layer_i);
				hm.lines.layerIdMaskMap.add();
			break;
			//
			case "snapshot":
				hm.states[hm.state_i].data = data;
				hm.states[hm.state_i].store(type,tool_name,toolset_mode,layer_i);
				hm.lines.snapshot.add();
				hm.lines.layerClipMap.add();
				hm.lines.layerIdIndexMap.add();
				hm.lines.layerIdMaskMap.add();
			break;
			//
			default:
			//standard 
				hm.states[hm.state_i].data = data;
				hm.states[hm.state_i].store(type,tool_name,toolset_mode,layer_i);
				hm.lines[type].add();
			break;
		}
		
		current_state.occupied = true;
		
		hm.opid++;
		hm.docVer++;
	},

	undo : function(){
		var hm = this;
		if(hm.state_i == hm.start)return;
		var current_state = hm.states[hm.state_i];
		var back_state_i = (hm.state_i-1+hm.num_states) % hm.num_states;
		
		//recreate state using its toolset_mode
		toolset_mode = current_state.toolset_mode;
		
		
		
		
		if(current_state.occupied == true){
		
		//switch layer
		if(selected_layer_i != current_state.layer_i){
			selectLayer(current_state.layer_i);
		}
		//rollback current state by type
		switch(current_state.type){
			//
			case "spree":
			//this is the same as default, just to escalate order 
			//because spree is most common type
				if(hm.lines[current_state.type] != null){
					hm.lines[current_state.type].swap();
					hm.lines[current_state.type].back();
				}else{
					console.log("type "+current_state.type+" not found");
				}
			break;
			//
			case "selection":
				hm.lines.selection.swap();
				hm.lines.selection.back();
				selection_module.detectSelection();
				selection_module.makeSelectionOutline();
			break;
			//
			case "custom":
				var line_state = null;
				var data = current_state.data;
				for(var i=0;i<data.length;i++){
					if(hm.lines[data[i]] != null){
						hm.lines[data[i]].swap();
						hm.lines[data[i]].back();
						
						if(data[i] == "selection"){
							selection_module.detectSelection();
							selection_module.makeSelectionOutline();
						}
					}else{
						console.log("type custom "+data[i]+" not found");
					}
				}
			break;
			//
			case "moveModule":
				var line_state = null;
				var data = current_state.data;
				for(var i=0;i<data.length;i++){
					if(hm.lines[data[i]] != null){
						hm.lines[data[i]].swap();
						hm.lines[data[i]].back();
						
						if(data[i] == "selection"){
							selection_module.detectSelection();
							selection_module.makeSelectionOutline();
						}
					}else{
						console.log("type custom (moveModule) "+data[i]+" not found");
					}
				}
				move_module.updateUIConfigMenu();
				move_module.updateUITransformControls();
			break;
			//
			case "solidifySpree":
				hm.lines.layer.swap();
				hm.lines.layer.back();
				
				hm.lines.spree.swap();
				hm.lines.spree.back();
			break;
			//
			case "layerMaskApply":
				hm.lines.layerIdMaskMap.swap();
				hm.lines.layerIdMaskMap.back();
				
				hm.lines.layer.swap();
				hm.lines.layer.back();
				
				gf.arrangeMasks();
			break;
			//
			case "layerList":
			//needs separate handling because of layer selection
				hm.lines.layerList.swap();
				hm.lines.layerList.back();
				
				hm.lines.layerClipMap.swap();
				hm.lines.layerClipMap.back();
				
				gf.arrangeClip();
				
				selectLayer(current_state.layer_i);
			break;
			//
			case "arrangeLayers":
				hm.lines.layerClipMap.swap();
				hm.lines.layerClipMap.back();
				
				hm.lines.layerIdIndexMap.swap();
				hm.lines.layerIdIndexMap.back();
				
				gf.arrangeLayers();
				gf.arrangeClip();
				
				selectLayer(current_state.layer_i);
			break;
			//
			case "arrangeClip":
				hm.lines.layerClipMap.swap();
				hm.lines.layerClipMap.back();
				
				gf.arrangeClip();
			break;
			//
			case "arrangeMasks":
				hm.lines.layerIdMaskMap.swap();
				hm.lines.layerIdMaskMap.back();
				
				gf.arrangeMasks();
			break;
			//
			case "snapshot":
			
				if(hm.lines[current_state.type] != null){
					hm.lines[current_state.type].swap();
					hm.lines[current_state.type].back();
				}else{
					console.log("type "+current_state.type+" not found");
				}
				
				hm.lines.layerClipMap.swap();
				hm.lines.layerClipMap.back();
				
				hm.lines.layerIdIndexMap.swap();
				hm.lines.layerIdIndexMap.back();
				
				hm.lines.layerIdMaskMap.swap();
				hm.lines.layerIdMaskMap.back();
				//size everything properly
				
				//update tiny_preview size
				tiny_preview.width = drawingAreaWidth;
				tiny_preview.height = drawingAreaHeight;
				
				canvas_view.zoomFit();
				canvas_view.makeCursor(current_tool,current_bay.size);
				
				selectLayer(current_state.layer_i);
				selection_module.detectSelection();
				selection_module.makeSelectionOutline();
			break;
			//
			case "rotateCanvas90":
				rotateCanvas90(-current_state.data[0]);
				canvas_view.zoomFit();
				canvas_view.makeCursor(current_tool,current_bay.size);
			break;
			//
			case "flipCanvas":
				flipCanvas(current_state.data[0],current_state.data[1]);
			break;
			//
			default:
				if(hm.lines[current_state.type] != null){
					hm.lines[current_state.type].swap();
					hm.lines[current_state.type].back();
				}else{
					console.log("type "+current_state.type+" not found");
				}
			break;
		}
		}//occupied
		
		//////////////////////
		
		//state back
		hm.state_i = back_state_i;
		//console.log(hm.state_i);
		
		hm.docVer--;
		
		spree.view_ctx.clearRect(0,0,spree.view.width,spree.view.height);
		spree.view_ctx.drawImage(spree.c,0,0);
		
		selected_layer.updateView();
		stackLayersUI();
		stackLiveView();
		//restore toolset_mode
		//toolset_mode = toolset_mode_temp;
		
		if(current_tool == "move_tool"){
		//keeps move config menu updated on any history step
			move_module.updateUIConfigMenu();
			move_module.updateUITransformControls();
		}
		
		if(current_state.bypass == true){
			//do another undo
			hm.undo();
		}
	},
	
	redo : function(){
		var hm = this;
		if(hm.state_i == hm.end)return;
		
		hm.state_i = (hm.state_i+1+hm.num_states) % hm.num_states;
		//console.log(hm.state_i);
		var current_state = hm.states[hm.state_i];
		
		//recreate state using its toolset_mode
		toolset_mode = current_state.toolset_mode;
		
		if(current_state.occupied == true){
		//switch layer
		if(selected_layer_i != current_state.layer_i){
			selectLayer(current_state.layer_i);
		}
		
		/////
		switch(current_state.type){
			//
			case "spree":
			//this is the same as default, just to escalate order 
			//because spree is most common type
				if(hm.lines[current_state.type] != null){
					hm.lines[current_state.type].next();
					hm.lines[current_state.type].swap();
				}else{
					console.log("type "+current_state.type+" not found");
				}
			break;
			//
			case "selection":
				hm.lines.selection.next();
				hm.lines.selection.swap();
				selection_module.detectSelection();
				selection_module.makeSelectionOutline();
			break;
			//
			case "custom":
				var line_state = null;
				var data = current_state.data;
				for(var i=0;i<data.length;i++){
				//for(var i=data.length-1;i>=0;i--){
					if(hm.lines[data[i]] != null){
						hm.lines[data[i]].next();
						hm.lines[data[i]].swap();
						
						if(data[i] == "selection"){
							selection_module.detectSelection();
							selection_module.makeSelectionOutline();
						}
					}else{
						console.log("type custom "+data[i]+" not found");
					}
				}
			break;
			//
			case "moveModule":
				var line_state = null;
				var data = current_state.data;
				for(var i=0;i<data.length;i++){
				//for(var i=data.length-1;i>=0;i--){
					if(hm.lines[data[i]] != null){
						hm.lines[data[i]].next();
						hm.lines[data[i]].swap();
						
						if(data[i] == "selection"){
							selection_module.detectSelection();
							selection_module.makeSelectionOutline();
						}
					}else{
						console.log("type custom (moveModule) "+data[i]+" not found");
					}
				}
				move_module.updateUIConfigMenu();
				move_module.updateUITransformControls();
			break;
			//
			case "solidifySpree":
				hm.lines.layer.next();
				hm.lines.layer.swap();
			
				hm.lines.spree.next();
				hm.lines.spree.swap();
			break;
			//
			case "layerMaskApply":
				hm.lines.layerIdMaskMap.next();
				hm.lines.layerIdMaskMap.swap();
				
				hm.lines.layer.next();
				hm.lines.layer.swap();
				
				gf.arrangeMasks();
			break;
			//
			case "layerList":
			//needs separate handling because of layer selection and clipping mask
				hm.lines.layerList.next();
				hm.lines.layerList.swap();
				
				hm.lines.layerClipMap.next();
				hm.lines.layerClipMap.swap();
				
				gf.arrangeClip();
				
				selectLayer(current_state.layer_i);
			break;
			//
			case "arrangeLayers":
				hm.lines.layerClipMap.next();
				hm.lines.layerClipMap.swap();
				
				hm.lines.layerIdIndexMap.next();
				hm.lines.layerIdIndexMap.swap();
				
				gf.arrangeLayers();
				gf.arrangeClip();
				
				selectLayer(current_state.layer_i);
			break;
			//
			case "arrangeClip":
				hm.lines.layerClipMap.next();
				hm.lines.layerClipMap.swap();
				
				gf.arrangeClip();
			break;
			//
			case "arrangeMasks":
				hm.lines.layerIdMaskMap.next();
				hm.lines.layerIdMaskMap.swap();
				
				gf.arrangeMasks();
			break;
			//
			case "snapshot":
			
				if(hm.lines[current_state.type] != null){
					hm.lines[current_state.type].next();
					hm.lines[current_state.type].swap();
				}else{
					console.log("type "+current_state.type+" not found");
				}
				hm.lines.layerClipMap.next();
				hm.lines.layerClipMap.swap();
				
				hm.lines.layerIdIndexMap.next();
				hm.lines.layerIdIndexMap.swap();
				
				hm.lines.layerIdMaskMap.next();
				hm.lines.layerIdMaskMap.swap();
				//size everything properly
				
				//update tiny_preview size
				tiny_preview.width = drawingAreaWidth;
				tiny_preview.height = drawingAreaHeight;
				
				canvas_view.zoomFit();
				canvas_view.makeCursor(current_tool,current_bay.size);
				
				selectLayer(current_state.layer_i);
				selection_module.detectSelection();
				selection_module.makeSelectionOutline();
				
			break;
			//
			case "rotateCanvas90":
				rotateCanvas90(current_state.data[0]);
				canvas_view.zoomFit();
				canvas_view.makeCursor(current_tool,current_bay.size);
			break;
			//
			case "flipCanvas":
				flipCanvas(current_state.data[0],current_state.data[1]);
			break;
			//
			default:
				if(hm.lines[current_state.type] != null){
					hm.lines[current_state.type].next();
					hm.lines[current_state.type].swap();
				}else{
					console.log("type "+current_state.type+" not found");
				}
			break;
		}
		}//occupied
		/////
		
		hm.docVer++;
		
		//spree.update();
		spree.view_ctx.clearRect(0,0,spree.view.width,spree.view.height);
		spree.view_ctx.drawImage(spree.c,0,0);
		
		selected_layer.updateView();
		stackLayersUI();
		stackLiveView();
		//restore toolset_mode
		//toolset_mode = toolset_mode_temp;
		
		if(current_tool == "move_tool"){
		//keeps move config menu updated on any history step
			move_module.updateUIConfigMenu();
			move_module.updateUITransformControls();
		}
		
		if(current_state.bypass == true){
			//do another undo
			hm.redo();
		}
	},
	
	getDocVer : function(){
		return this.docVer;
	},
	
	getOPID : function(){
		return this.opid;
	},
	
	getCurrentStateName : function(){
		return this.states[this.state_i].tool_name;
	}
}

var history_keeper = new historyModule();



//-----------------------------------History structures END

//-----------------------------------Preset Structures


// brush tip sample maker
var brushTipSampleImgMaker = {
	init : function(){
		var bts = this;
		
		bts.sample_size = 100;
		bts.sample_r = bts.sample_size/2;
		
		bts.sample_c = document.createElement("canvas");
		bts.sample_ctx = bts.sample_c.getContext("2d");
		bts.sample_c.width = bts.sample_size;
		bts.sample_c.height = bts.sample_size;
		//bts.sample_ctx.clearRect(0,0,bts.sample_c.width,bts.sample_c.height);
		
		//bts.sample_ctx.fillStyle = "white";
	},
	
	filterPrintSize : function(object_size){
		//filters brush icon appearance size for better visual
		var print_size = this.sample_size;
		if(object_size < 50){
			print_size = 20 + Math.round(30 * object_size / 50);
		}else if(object_size < 80){
			print_size = object_size;
		}
		
		/*
		else if(object_size < 80){
			print_size = object_size;
		}else if(object_size < 120){
			print_size = 80 + Math.round(20 * (object_size-80) / 40);
		}
		*/
		return print_size;
	},
	
	makeSample : function(brush_type,hardness,custom_tip, brush_size){
		var bts = this;
		var sample_img = document.createElement("img");
		//
		//bts.sample_ctx.fillStyle = "white";
		
		var print_size = bts.filterPrintSize(brush_size);
		
		if(brush_type == "custom" && custom_tip != null){
		//custom tip
			var custom_tip_img = new Image();
			custom_tip_img.onload = function(){
				bts.sample_ctx.clearRect(0,0, bts.sample_c.width,bts.sample_c.height);
				//bts.sample_ctx.drawImage(custom_tip_img,0,0, bts.sample_c.width,bts.sample_c.height);
				bts.sample_ctx.drawImage(custom_tip_img, (bts.sample_c.width - print_size)/2,(bts.sample_c.height - print_size)/2, print_size,print_size);
				
				//color the sample
				bts.sample_ctx.globalCompositeOperation = "source-atop";
				bts.sample_ctx.fillStyle = "white";
				bts.sample_ctx.fillRect(0,0,bts.sample_c.width,bts.sample_c.height);
				bts.sample_ctx.globalCompositeOperation = "source-over";
				
				sample_img.src = bts.sample_c.toDataURL();
			}
			custom_tip_img.src = custom_tip;
			
		}else{
		//default tip
			bts.sample_ctx.clearRect(0,0, bts.sample_c.width,bts.sample_c.height);
			//var grd = bts.sample_ctx.createRadialGradient(bts.sample_r, bts.sample_r, 0, bts.sample_r,bts.sample_r,bts.sample_r);//prepare brush params: _ _ radius1 _ _ radius2 brush hardness
			var grd = bts.sample_ctx.createRadialGradient(bts.sample_r, bts.sample_r, 0, bts.sample_r,bts.sample_r,print_size/2);//prepare brush params: _ _ radius1 _ _ radius2 brush hardness
			grd.addColorStop(hardness, "white");
			grd.addColorStop(1, "rgba(255,255,255,0");
			bts.sample_ctx.fillStyle = grd;
			bts.sample_ctx.fillRect(0, 0, bts.sample_size, bts.sample_size);
			
			sample_img.src = bts.sample_c.toDataURL();
		}
		
		return sample_img;
	},
	
	updateBayIcon : function(bay_icon_img,bay){
		var bts = this;
		var sample_img = bay_icon_img;
		var brush_type = bay.brush.brush_type;
		var hardness = bay.brush.hardness;
		var bay_size = bay.size;
		//use custom_tip image directly from brush
		var custom_tip_img = bay.brush.custom_tip;
		//
		
		var print_size = bts.filterPrintSize(bay_size);
		
		if(brush_type == "custom"){
		//custom tip
			if(custom_tip_img.complete == true){
				bts.sample_ctx.clearRect(0,0, bts.sample_c.width,bts.sample_c.height);
				//bts.sample_ctx.drawImage(custom_tip_img,0,0, bts.sample_c.width,bts.sample_c.height);
				bts.sample_ctx.drawImage(custom_tip_img, (bts.sample_c.width - print_size)/2,(bts.sample_c.height - print_size)/2, print_size,print_size);	
				//color the sample
				bts.sample_ctx.globalCompositeOperation = "source-atop";
				bts.sample_ctx.fillStyle = "white";
				bts.sample_ctx.fillRect(0,0,bts.sample_c.width,bts.sample_c.height);
				bts.sample_ctx.globalCompositeOperation = "source-over";
				
				sample_img.src = bts.sample_c.toDataURL();
			}else{
				custom_tip_img.onload = function(){
					bts.sample_ctx.clearRect(0,0, bts.sample_c.width,bts.sample_c.height);
					//bts.sample_ctx.drawImage(custom_tip_img,0,0, bts.sample_c.width,bts.sample_c.height);
					bts.sample_ctx.drawImage(custom_tip_img, (bts.sample_c.width - print_size)/2,(bts.sample_c.height - print_size)/2, print_size,print_size);	
					//color the sample
					bts.sample_ctx.globalCompositeOperation = "source-atop";
					bts.sample_ctx.fillStyle = "white";
					bts.sample_ctx.fillRect(0,0,bts.sample_c.width,bts.sample_c.height);
					bts.sample_ctx.globalCompositeOperation = "source-over";
					
					sample_img.src = bts.sample_c.toDataURL();
				}
			}
			
		}else{
		//default tip
			bts.sample_ctx.clearRect(0,0, bts.sample_c.width,bts.sample_c.height);
			//var grd = bts.sample_ctx.createRadialGradient(bts.sample_r, bts.sample_r, 0, bts.sample_r, bts.sample_r, bts.sample_r);//prepare brush params: _ _ radius1 _ _ radius2 brush hardness
			var grd = bts.sample_ctx.createRadialGradient(bts.sample_r, bts.sample_r, 0, bts.sample_r, bts.sample_r, print_size/2);//prepare brush params: _ _ radius1 _ _ radius2 brush hardness
			grd.addColorStop(hardness, "white");
			grd.addColorStop(1, "rgba(255,255,255,0");
			bts.sample_ctx.fillStyle = grd;
			bts.sample_ctx.fillRect(0, 0, bts.sample_size, bts.sample_size);
			
			sample_img.src = bts.sample_c.toDataURL();
		}
	},
	
	updateBrushPresetIcon : function(preset_icon_img,preset){
	//note: use only after the preview images were loaded, 
	//this is only for updating existing preset previews
		var bts = this;
		var sample_img = preset_icon_img;
		
		//use preset image as a buffer for custom tip drawing
		//a shortcut to not create extra img element to hold custom_tip
		sample_img.src = preset.custom_tip;
		custom_tip_img = sample_img;
		
		var brush_type = preset.brush_type;
		var hardness = preset.hardness;
		var brush_size = preset.size;

		var print_size = bts.filterPrintSize(brush_size);
		
		if(brush_type == "custom"){
		//custom tip
			bts.sample_ctx.clearRect(0,0, bts.sample_c.width,bts.sample_c.height);
			//bts.sample_ctx.drawImage(custom_tip_img,0,0, bts.sample_c.width,bts.sample_c.height);
			bts.sample_ctx.drawImage(custom_tip_img, (bts.sample_c.width - print_size)/2,(bts.sample_c.height - print_size)/2, print_size,print_size);	
			//color the sample
			bts.sample_ctx.globalCompositeOperation = "source-atop";
			bts.sample_ctx.fillStyle = "white";
			bts.sample_ctx.fillRect(0,0,bts.sample_c.width,bts.sample_c.height);
			bts.sample_ctx.globalCompositeOperation = "source-over";
			
			sample_img.src = bts.sample_c.toDataURL();
		
		}else{
		//default tip
			bts.sample_ctx.clearRect(0,0, bts.sample_c.width,bts.sample_c.height);
			//var grd = bts.sample_ctx.createRadialGradient(bts.sample_r, bts.sample_r, 0, bts.sample_r, bts.sample_r, bts.sample_r);//prepare brush params: _ _ radius1 _ _ radius2 brush hardness
			var grd = bts.sample_ctx.createRadialGradient(bts.sample_r, bts.sample_r, 0, bts.sample_r, bts.sample_r, print_size/2);//prepare brush params: _ _ radius1 _ _ radius2 brush hardness
			grd.addColorStop(hardness, "white");
			grd.addColorStop(1, "rgba(255,255,255,0");
			bts.sample_ctx.fillStyle = grd;
			bts.sample_ctx.fillRect(0, 0, bts.sample_size, bts.sample_size);
			
			sample_img.src = bts.sample_c.toDataURL();
		}
	}
	
}

brushTipSampleImgMaker.init();

//brush preset structs / library
//brush preset
const brushPresetAttrList = ["id","name","size","flow","opacity","hardness",
"spacing","sizePressureEnabled","sizePressureMinDiameter","flowPressureEnabled",
"directionEnabled","brush_type","custom_tip","blend_assist",
"flip_x_jitter","flip_y_jitter","roundness_jitter","angle_jitter",
"scatter_distance","scatter_size_jitter","scatter_count","scatter_count_jitter"];

function brushPreset(preset_id){
	var bp = this;
	
	if(preset_id == null){
		bp.id = bp_keeper.preset_id_counter;
	}else{
		bp.id = preset_id;
	}
	
	bp.name = "Brush";
	
	bp.size = 100;
	
	bp.opacity = 1.0;
	bp.flow = 1.0;
	bp.hardness = 1.0;
	
	bp.spacing = 0.20;
	
	bp.sizePressureEnabled = false;
	bp.sizePressureMinDiameter = 0.01;
	
	bp.flowPressureEnabled = false;
	
	bp.directionEnabled = false;
	
	bp.brush_type = "default";//or custom
	bp.custom_tip = null;
	
	bp.blend_assist = false;
	
	bp.color = null;//not using for now
	
	bp.flip_x_jitter = false;
	bp.flip_y_jitter = false;
	bp.roundness_jitter = 1.0;
	
	bp.angle_jitter = 0;
	
	bp.scatter_distance = 0.0;
	bp.scatter_size_jitter = 1.0;
	bp.scatter_count = 1;
	bp.scatter_count_jitter = 0;
}

brushPreset.prototype = {
	
	//
	setAllAttributes : function(val){
		var bp = this;
		
		if(val.length != brushPresetAttrList.length){
			console.log("incomplete list of brush preset values");
			return;
		}
		for(var i=0;i<brushPresetAttrList.length;i++){
			bp[brushPresetAttrList[i]] = val[i];
		}
		
	},
	
	setAttribute : function(attr,val){
		this[attr] = val;
	},
	
	//makes a copy from a brush preset, for example from a JSON parsed data
	copy : function(bpreset){
		var bp = this;
		
		for(var i=0;i<brushPresetAttrList.length;i++){
			if(bpreset.hasOwnProperty(brushPresetAttrList[i])){
				bp[brushPresetAttrList[i]] = bpreset[brushPresetAttrList[i]];
			}
		}
		
	},
	
	getExportData : function(){
		return JSON.stringify(this).toString();
	}

}

//brush preset keeper / library, stores multiples of brushPreset
function brushPresetKeeper(){
	var bpk = this;
	bpk.configTitle = "BrushPresets";
	bpk.contents = [];
	bpk.embedded_preset_num = 1;
	bpk.selected_preset = null;
	bpk.selected_preset_i = 0;
	
	//for internal book keeping/database
	bpk.preset_id_counter = 0;
	
	//for custom tip image processing
	bpk.custom_tip_img = document.createElement("img");
	bpk.custom_tip_img.src = "";
	bpk.ctp_c = document.createElement("canvas");
	bpk.ctp_ctx = bpk.ctp_c.getContext("2d");
	
	bpk.ctp_buffer = new canvasBuffer();//for layer capture
	
	//brush tip preview image
	bpk.contents_preview_image = [];
}

brushPresetKeeper.prototype = {

	//loads config
	load : function(config,config_order){
		
		
		var preset_id;
		var missing_presets = [];
		var config_order_map = {};
		for(var i=0;i<config_order.length;i++){
			if(config[config_order[i]] == undefined){
				config_order.splice(i,1);
				i--;
			}else{
				preset_id = config_order[i];
				config_order_map[preset_id] = i;
			}
		}
		
		
		//check if there are missing presets (not mentioned in order list)
		var config_preset;
		for(var preset_id in config){
			if(config_order_map[preset_id] == undefined){
				missing_presets.push(config[preset_id]);
			}
		}
		
		
		//add presets in order
		for(var i=0;i<config_order.length;i++){
			config_preset = config[config_order[i]];
			this.makeBlankPreset();
			this.selected_preset.copy(config_preset);
			this.preset_id_counter = Math.max(this.preset_id_counter,config_preset.id);
			//brush icon
			this.setPresetPreviewImg(this.selected_preset_i);
		}
		
		//add no order/missing presets
		for(var i=0;i<missing_presets.length;i++){
			config_preset = missing_presets[i];
			this.makeBlankPreset();
			this.selected_preset.copy(config_preset);
			this.preset_id_counter = Math.max(this.preset_id_counter,config_preset.id);
			//brush icon
			this.setPresetPreviewImg(this.selected_preset_i);
		}
		
		this.selectPreset(0);
	},
	
	setPresetValue : function(preset_i,attr,val){
		this.contents[preset_i].setAttribute(attr,val);
	},
	
	setSelectedPresetValue : function(attr,val){
	//meant to support UI user actions in library
	//coupled with config db notifications
		this.selected_preset.setAttribute(attr,val);
		//notify user config keeper about a change
		uc_keeper.notifyLibUpdateNeeded("brushPresetConfigData",this.selected_preset.id,this.selected_preset);
	},
	
	setSelectedPresetCustomTip : function(tipImgURL){
	//user accessible function for uploading custom tip image
	//not for internal use
		var bpk = this;
		var custom_tip_url = null;
		bpk.custom_tip_img.src = tipImgURL;
		bpk.custom_tip_img.onload = function(){
			let tip_size = Math.max(bpk.custom_tip_img.width,bpk.custom_tip_img.height);
			
			bpk.ctp_c.width = tip_size;
			bpk.ctp_c.height = tip_size;
			bpk.ctp_ctx.clearRect(0,0, bpk.ctp_c.width,bpk.ctp_c.height);
			
			//center image
			let tip_x_offset = Math.round((bpk.ctp_c.width - bpk.custom_tip_img.width) /2);
			let tip_y_offset = Math.round((bpk.ctp_c.height - bpk.custom_tip_img.height) /2);
			bpk.ctp_ctx.drawImage(bpk.custom_tip_img, tip_x_offset,tip_y_offset);
			colorToAlphaBlack(bpk.ctp_c,bpk.ctp_ctx);
			bpk.setSelectedPresetValue("custom_tip",bpk.ctp_c.toDataURL());
			bpk.setSelectedPresetValue("brush_type","custom");
			bpk.selected_preset.size = tip_size;
			//update icons
			bpk.setPresetPreviewImg(bpk.selected_preset_i);
			bpk.updateUIPresetPreviewImg(bpk.selected_preset_i);
			bpk.updateUIPresetConfigValues();
		}
		
		//notify user config keeper about a change
		uc_keeper.notifyLibUpdateNeeded("brushPresetImgData",this.selected_preset.id,this.selected_preset);
	},
	
	

	selectPreset : function(preset_i){
		var bpk = this;
		bpk.selected_preset_i = preset_i;
		bpk.selected_preset = bpk.contents[preset_i];
	},
	
	getPreset : function(preset_i){
		return this.contents[preset_i];
	},
	
	//searches and returns first found preset with a given name
	getPresetByName : function(name){
		var result = null;
		for(var i=0;i<this.contents.length;i++){
			if(this.contents[i].name == name){
				result = this.contents[i];
				break;
			}
		}
		return result;
	},
	
	getPresetById : function(preset_id){
		var result = null;
		for(var i=0;i<this.contents.length;i++){
			if(this.contents[i].id == preset_id){
				result = this.contents[i];
				break;
			}
		}
		return result;
	},
	
	getPresetIdOrder : function(){
		var preset_id_list = [];
		for(let i=0;i<this.contents.length;i++){
			preset_id_list.push(this.contents[i].id);
		}
		return preset_id_list;
	},
	
	getDefaultPreset : function(){
		return this.contents[0];
	},
	
	makeBlankPreset : function(){
		var bpk = this;
		bpk.selected_preset = new brushPreset();
		bpk.contents.push(bpk.selected_preset);
		bpk.selected_preset_i = bpk.contents.length-1;
		bpk.selected_preset.name+=" "+bpk.contents.length;
		return bpk.selected_preset;
	},
	
	duplicatePreset : function(bpreset){
		var bpk = this;
		bpk.selected_preset = new brushPreset();
		bpk.selected_preset.copy(bpreset);
		
		bpk.preset_id_counter++;
		bpk.selected_preset.id = bpk.preset_id_counter;
		
		bpk.contents.push(bpk.selected_preset);
		bpk.selected_preset_i = bpk.contents.length-1;
		bpk.selected_preset.name+=" copy";
		
		//notify user config keeper about a change
		uc_keeper.notifyLibUpdateNeeded("brushPresetConfigData",this.selected_preset.id,this.selected_preset);
		if(bpk.selected_preset.brush_type == "custom"){
			uc_keeper.notifyLibUpdateNeeded("brushPresetImgData",this.selected_preset.id,this.selected_preset);
		}
		uc_keeper.notifyGenUpdateNeeded("generalConfig","brushPresetOrder");
	},
	
	deletePreset : function(preset_i){
		//returns deleted preset on success and null otherwise
		var bpk = this;
		//embedded presets
		if(preset_i < bpk.embedded_preset_num)return null;
		
		bpk.contents_preview_image.splice(preset_i,1);
		return bpk.contents.splice(preset_i,1)[0];
	},
	
	captureBay : function(){
		var bpk = this;
		
		bpk.preset_id_counter++;
		var cap = new brushPreset();
		
		cap.size = current_bay.size;
		
		cap.opacity = current_bay.opacity;
		cap.flow = current_bay.flow;
		
		cap.hardness = current_brush.hardness;
		
		cap.spacing = current_brush.spacing;
		
		cap.sizePressureEnabled = current_brush.sizePressureEnabled;
		cap.sizePressureMinDiameter = current_brush.sizePressureMinDiameter;
		
		cap.flowPressureEnabled = current_brush.flowPressureEnabled;
		
		cap.directionEnabled = current_brush.directionEnabled;
		
		cap.brush_type = current_brush.brush_type;
		if(cap.brush_type == 'custom'){
			cap.custom_tip = current_brush.custom_tip.src;
		}else{
			cap.custom_tip = null;
		}
		
		cap.blend_assist = current_brush.blend_assist;
		
		cap.flip_x_jitter = current_brush.flip_x_jitter;
		cap.flip_y_jitter = current_brush.flip_y_jitter;
		cap.roundness_jitter = current_brush.roundness_jitter;
		
		cap.angle_jitter = current_brush.angle_jitter;
		
		cap.scatter_distance = current_brush.scatter_distance;
		cap.scatter_size_jitter = current_brush.scatter_size_jitter;
		cap.scatter_count = current_brush.scatter_count;
		cap.scatter_count_jitter = current_brush.scatter_count_jitter;
		
		
		bpk.contents.push(cap);
		bpk.selected_preset = cap;
		bpk.selected_preset_i = bpk.contents.length-1;
		bpk.selected_preset.name+=" "+bpk.contents.length;
		
		//notify user config keeper about a change
		uc_keeper.notifyLibUpdateNeeded("brushPresetConfigData",this.selected_preset.id,this.selected_preset);
		if(bpk.selected_preset.brush_type == "custom"){
			uc_keeper.notifyLibUpdateNeeded("brushPresetImgData",this.selected_preset.id,this.selected_preset);
		}
		uc_keeper.notifyGenUpdateNeeded("generalConfig","brushPresetOrder");
	},
	
	captureLayer : function(){
		var bpk = this;
		
		bpk.preset_id_counter++;
		bpk.makeBlankPreset();
		
		bpk.ctp_buffer.put(selected_layer.view);
		//deal with selected area
		if(selection_module.selection_active == true){
			bpk.ctp_buffer.setComposite("destination-in");
			bpk.ctp_buffer.stack(selection_module.selection);
			bpk.ctp_buffer.resetComposite();
		}
		//convert to alpha
		colorToAlphaBlack(bpk.ctp_buffer.c, bpk.ctp_buffer.ctx);
		var contentBox = findContentBoundingBox(bpk.ctp_buffer.c, bpk.ctp_buffer.ctx);
		
		//check content exists
		if(contentBox[2] < 1 || contentBox[3] < 1){
			alert("Area seems to be empty");
			return;
		}
		
		var tip_size = Math.max(contentBox[2],contentBox[3]);
		
		//size canvas for a tip
		bpk.ctp_c.width = tip_size;
		bpk.ctp_c.height = tip_size;
		
		var offsetX = 0;
		var offsetY = 0;
		//center tip content
		if(contentBox[3] > contentBox[2]){
			//height > width
			offsetX = (contentBox[3]-contentBox[2])/2;
		}else{
			//width > height OR same
			offsetY = (contentBox[2]-contentBox[3])/2;
		}
		
		//position offsets
		offsetX = offsetX-contentBox[0];
		offsetY = offsetY-contentBox[1];
		bpk.ctp_buffer.output(bpk.ctp_ctx,bpk.ctp_c, offsetX,offsetY);
		
		//convert to image and set as custom tip
		bpk.selected_preset.custom_tip = bpk.ctp_c.toDataURL();
		bpk.selected_preset.brush_type = "custom";
		//set size same as captured sample
		bpk.selected_preset.size = tip_size;
		
		//not needed because makeBlankPreset does this
		//notify user config keeper about a change
		uc_keeper.notifyLibUpdateNeeded("brushPresetConfigData",this.selected_preset.id,this.selected_preset);
		uc_keeper.notifyLibUpdateNeeded("brushPresetImgData",this.selected_preset.id,this.selected_preset);
		uc_keeper.notifyGenUpdateNeeded("generalConfig","brushPresetOrder");
	},
	
	importPreset : function(element){
		var bpk = this;
		var f = element.files[0];
		if(!f)return;
		var preset = bpk.makeBlankPreset();
		
		var reader = new FileReader();
		reader.onload = function(e){
			preset.copy(JSON.parse(e.target.result));
			
			bpk.preset_id_counter++;
			preset.id = bpk.preset_id_counter;
			
			bpk.setPresetPreviewImg(bpk.selected_preset_i);
			bpk.stackBrushPresetsUI();
			bpk.updateUIPresetConfigValues();
			
			//notify user config keeper about a change
			uc_keeper.notifyLibUpdateNeeded("brushPresetConfigData",bpk.selected_preset.id,bpk.selected_preset);
			if(bpk.selected_preset.brush_type == "custom"){
				uc_keeper.notifyLibUpdateNeeded("brushPresetImgData",bpk.selected_preset.id,bpk.selected_preset);
			}
			uc_keeper.notifyGenUpdateNeeded("generalConfig","brushPresetOrder");
			
		}
		reader.readAsText(f);
		
		
	},
	
	exportPreset : function(preset_index){
		var bpk = this;
		var preset_i = 0;
		if(preset_index == null){
			preset_i = bpk.selected_preset_i;
		}else{
			preset_i = preset_index;
		}
		var preset = bpk.getPreset(preset_i);
		
		generateDownload(preset.name+".bp","data:text/plain;charset=UTF-8,"+preset.getExportData());
		
	},
	
	setPresetPreviewImg : function(preset_i){
		var bpk = this;
		bpk.contents_preview_image[preset_i] = 
		brushTipSampleImgMaker.makeSample(bpk.contents[preset_i].brush_type,
												  bpk.contents[preset_i].hardness,
												  bpk.contents[preset_i].custom_tip,
												  bpk.contents[preset_i].size);
	},
	
	updateUIPresetPreviewImg : function(index){
		var bpk = this;
		var preset_i = bpk.selected_preset_i;
		if(index != null){
			preset_i = index;
		}
		var m = null;
		for(var i=0;i<UI.brush_preset_container.children.length;i++){
			if(parseInt(UI.brush_preset_container.children[i].dataset.preset_i) == preset_i){
				m = UI.brush_preset_container.children[i].getElementsByTagName('img')[0];
			}
		}
		if(m != null){
			bpk.contents_preview_image[preset_i].className = "brush-preset-item-icon";
			m.parentElement.replaceChild(bpk.contents_preview_image[preset_i],m);
		}else{
			alert("Error: Brush preset preview image not found on update");
		}
	},
	
	updateUIPresetName : function(index){
		var bpk = this;
		var preset_i = bpk.selected_preset_i;
		if(index != null){
			preset_i = index;
		}
		var m = null;
		for(var i=0;i<UI.brush_preset_container.children.length;i++){
			if(parseInt(UI.brush_preset_container.children[i].dataset.preset_i) == preset_i){
				m = UI.brush_preset_container.children[i].getElementsByClassName('brush-preset-item-name')[0];
			}
		}
		if(m != null){
			m.textContent = bpk.selected_preset.name;
		}else{
			console.log("Error: Brush preset name not found on update");
		}
	},
	
	updateUIPresetConfigValues : function(){
		var bpk = this;
		
		UI.brush_preset_config_name.value = bpk.selected_preset.name;
		
		UI.brush_preset_size_value.value = bpk.selected_preset.size;
		UI.brush_preset_size_slider.value = baySizeUIVtoS(bpk.selected_preset.size);
		
		UI.brush_preset_opacity_value.value = Math.round(bpk.selected_preset.opacity*10*10);
		UI.brush_preset_opacity_slider.value = UI.brush_preset_opacity_value.value;
		
		UI.brush_preset_flow_value.value = Math.round(bpk.selected_preset.flow*10*10);
		UI.brush_preset_flow_slider.value = UI.brush_preset_flow_value.value;
		
		UI.brush_preset_hardness_value.value = Math.round(bpk.selected_preset.hardness*10*10);
		UI.brush_preset_hardness_slider.value = UI.brush_preset_hardness_value.value;
		
		UI.brush_preset_spacing_value.value = Math.round(bpk.selected_preset.spacing*10*10);
		UI.brush_preset_spacing_slider.value = UI.brush_preset_spacing_value.value;
		
		UI.brush_preset_direction.checked = bpk.selected_preset.directionEnabled;
		UI.brush_preset_size_pressure.checked = bpk.selected_preset.sizePressureEnabled;
		UI.brush_preset_size_pressure_min_d.value = Math.round(bpk.selected_preset.sizePressureMinDiameter*10*10);
		UI.brush_preset_flow_pressure.checked = bpk.selected_preset.flowPressureEnabled;
	
		UI.brush_preset_custom_tip_file.value = "";
		UI.brush_preset_brush_type_default.checked = false;
		UI.brush_preset_brush_type_custom.checked = false;
		UI["brush_preset_brush_type_"+bpk.selected_preset.brush_type].checked = true;
		
		UI.brush_preset_blend_assist.checked = bpk.selected_preset.blend_assist;
		
		UI.brush_preset_flip_x_jitter.checked = bpk.selected_preset.flip_x_jitter;
		UI.brush_preset_flip_y_jitter.checked = bpk.selected_preset.flip_y_jitter;
		UI.brush_preset_roundness_jitter.value = Math.round(bpk.selected_preset.roundness_jitter*10*10);
		
		UI.brush_preset_angle_jitter.value = bpk.selected_preset.angle_jitter;
		
		UI.brush_preset_scatter_distance.value = Math.round(bpk.selected_preset.scatter_distance*10*10);
		UI.brush_preset_scatter_size_jitter.value = Math.round(bpk.selected_preset.scatter_size_jitter*10*10);
		UI.brush_preset_scatter_count.value = bpk.selected_preset.scatter_count;
		UI.brush_preset_scatter_count_jitter.value = bpk.selected_preset.scatter_count_jitter;
		
	},
	
	makeUIBrushPresetItem : function(preset_i){
		var bpk = this;
		var elem = document.createElement('li');
		elem.dataset.preset_i = preset_i;
		
		elem.addEventListener("click",function(e){
			e.stopPropagation();
			bp_keeper.selectPreset(parseInt(this.dataset.preset_i));
			bp_keeper.updateUIPresetConfigValues();
			selectRadioGroupBtn("brush-preset-item-group",bpk.selected_preset_i);
		});
		
		var elem_label = document.createElement('label');
		
		var m = document.createElement('input');
		m.setAttribute("type","radio");
		m.setAttribute("name","brush-preset-item-group");
		m.className = "hidden-toggler brush-preset-item-btn";
		elem_label.appendChild(m);
		
		var elem_content = document.createElement('span');
		elem_content.className = "brush-preset-item";
		elem_label.appendChild(elem_content);
		
		//adding brush preset icon
		m = bpk.contents_preview_image[preset_i];
		m.className = "brush-preset-item-icon";
		elem_content.appendChild(m);
		
		m = document.createElement('span');
		m.className = "brush-preset-item-name";
		m.textContent = bpk.contents[preset_i].name;
		elem_content.appendChild(m);
		
		
		elem.appendChild(elem_label);
		return elem;
		/* scheme
		<li>
		<label>
		<input type="radio" name="brush-preset-item-group" class="hidden-toggler brush-preset-item-btn" autocomplete="off">
		<span class="brush-preset-item">
		<img class="brush-preset-item-icon" src="resources/icons/pic.png">
		<span class="brush-preset-item-name">Brush preset 1</span>
		</span>
		</label>
		</li>
		*/
	},
	
	stackBrushPresetsUI : function(){
		var bpk = this;
		
		var bpresets_ui = document.createDocumentFragment();
		var bps = [];//string
		for(var i=0;i<bpk.contents.length;i++){
			bpresets_ui.appendChild(bpk.makeUIBrushPresetItem(i));
		}
		
		UI.brush_preset_container.innerHTML = "";
		UI.brush_preset_container.appendChild(bpresets_ui);
		//UI selection
		selectRadioGroupBtn("brush-preset-item-group",bpk.selected_preset_i);
	}
	
	
	
}

var bp_keeper = new brushPresetKeeper();


//Ref preset library structs

const refLayerPresetAttrList = ["id","name","ref_image","ref_image_align"];

function refLayerPreset(preset_id){
// Palette
	var rlp = this;
	
	if(preset_id == null){
		rlp.id = rlp_keeper.preset_id_counter;
	}else{
		rlp.id = preset_id;
	}
	
	rlp.name = "Palette";
	rlp.ref_image = null;
	rlp.ref_image_align = "center";
}

refLayerPreset.prototype = {
	//
	setAllAttributes : function(val){
		var rlp = this;
		
		if(val.length != refLayerPresetAttrList.length){
			console.log("incomplete list of ref preset values");
			return;
		}
		for(var i=0;i<refLayerPresetAttrList.length;i++){
			rlp[refLayerPresetAttrList[i]] = val[i];
		}
		
	},
	
	setAttribute : function(attr,val){
		this[attr] = val;
	},
	
	//makes a copy from a ref preset, for example from a JSON parsed data
	copy : function(rlpreset){
		var rlp = this;
		
		for(var i=0;i<refLayerPresetAttrList.length;i++){
			if(rlpreset.hasOwnProperty(refLayerPresetAttrList[i])){
				rlp[refLayerPresetAttrList[i]] = rlpreset[refLayerPresetAttrList[i]];
			}
		}
		
	}
}


function refLayerPresetKeeper(){
// Palette Library
// UI name was changed from reference layer library to palette library
	var rlpk = this;
	
	rlpk.configTitle = "RefPresets";
	
	rlpk.contents = [];
	rlpk.embedded_preset_num = 1;
	rlpk.selected_preset = null;
	rlpk.selected_preset_i = 0;
	rlpk.contents_preview_image = [];
	
	//for internal book keeping/database
	rlpk.preset_id_counter = 0;
	
	rlpk.preview = UI.ref_layer_config_preview;
	rlpk.preview.width = rlpk.preview.offsetWidth;
	rlpk.preview.height = rlpk.preview.offsetHeight;
	rlpk.preview_ctx = rlpk.preview.getContext("2d");

	//usage for example for storing and restoring modified reference layer
	rlpk.ref_mediator = document.createElement("canvas");
	rlpk.ref_mediator_ctx = rlpk.ref_mediator.getContext("2d"); 
	rlpk.ref_layer_mod_count = 0;
	rlpk.ref_layer_mod_current = 0;
}

refLayerPresetKeeper.prototype = {
	//loads config
	load : async function(config,config_order){
		
		var preset_id;
		var missing_presets = [];
		var config_order_map = {};
		//check for presets that are in order list but do not exist
		for(var i=0;i<config_order.length;i++){
			if(config[config_order[i]] == undefined){
				config_order.splice(i,1);
				i--;
			}else{
				preset_id = config_order[i];
				config_order_map[preset_id] = i;
			}
		}
		
		
		//check if there are missing presets (not mentioned in order list)
		var config_preset;
		for(var preset_id in config){
			if(config_order_map[preset_id] == undefined){
				missing_presets.push(config[preset_id]);
			}
		}
		
		//add presets in order
		for(var i=0;i<config_order.length;i++){
			config_preset = config[config_order[i]];
			this.makeBlankPreset();
			this.selected_preset.copy(config_preset);
			this.preset_id_counter = Math.max(this.preset_id_counter,config_preset.id);
			this.makePreviewImage(this.selected_preset_i,false);
		}
		
		//add no order/missing presets
		for(var i=0;i<missing_presets.length;i++){
			config_preset = missing_presets[i];
			this.makeBlankPreset();
			this.selected_preset.copy(config_preset);
			this.preset_id_counter = Math.max(this.preset_id_counter,config_preset.id);
			this.makePreviewImage(this.selected_preset_i,false);
		}
		
		this.selectPreset(0);
	},
	
	setPresetValue : function(preset_i,attr,val){
	//internal use
		this.contents[preset_i].setAttribute(attr,val);
	},
	
	setSelectedPresetValue : function(attr,val){
		this.selected_preset.setAttribute(attr,val);
		
		//notify user config keeper about a change
		uc_keeper.notifyLibUpdateNeeded("refPresetConfigData",this.selected_preset.id,this.selected_preset);
	},
	
	setSelectedPresetImage : function(val){
		var rlpk = this;
		rlpk.selected_preset.setAttribute("ref_image",val);
		rlpk.makePreviewImage(rlpk.selected_preset_i,true);
		
		uc_keeper.notifyLibUpdateNeeded("refPresetImgData",rlpk.selected_preset.id,rlpk.selected_preset);
	},
	
	selectPreset : function(preset_i){
		var rlpk = this;
		rlpk.selected_preset_i = preset_i;
		rlpk.selected_preset = rlpk.contents[preset_i];
	},
	
	getPreset : function(preset_i){
		return this.contents[preset_i];
	},
	
	getPresetById : function(preset_id){
		var result = null;
		for(var i=0;i<this.contents.length;i++){
			if(this.contents[i].id == preset_id){
				result = this.contents[i];
				break;
			}
		}
		return result;
	},
	
	getPresetIdOrder : function(){
		var preset_id_list = [];
		for(let i=0;i<this.contents.length;i++){
			preset_id_list.push(this.contents[i].id);
		}
		return preset_id_list;
	},
	
	makeBlankPreset : function(){
		var rlpk = this;
		rlpk.selected_preset = new refLayerPreset();
		rlpk.contents.push(rlpk.selected_preset);
		rlpk.selected_preset_i = rlpk.contents.length-1;
		rlpk.selected_preset.name+=" "+rlpk.contents.length;
		
		rlpk.contents_preview_image.push(new Image());
		
	},
	
	deletePreset : function(preset_i){
		//returns deleted preset
		var rlpk = this;
		//embedded presets
		if(preset_i < rlpk.embedded_preset_num)return null;
		
		rlpk.contents_preview_image.splice(preset_i,1);
		return rlpk.contents.splice(preset_i,1)[0];
	},
	
	makeCapturePreset : function(){
		var rlpk = this;
		//captures current reference layer into a preset
		//console.log("capturing current ref layer into a preset");
		rlpk.preset_id_counter++;
		rlpk.makeBlankPreset();
		var preset_i = rlpk.contents.length-1;
		rlpk.selectPreset(preset_i);
		rlpk.contents[preset_i].ref_image = ref_layer.toDataURL();
		rlpk.makePreviewImage(preset_i,true);
	},
	
	exportPresetImage : function(){
		var rlpk = this;
		if(rlpk.selected_preset.ref_image == null)return;
		//console.log("exporting ref preset image");
		
		generateDownload(rlpk.selected_preset.name+".png", rlpk.selected_preset.ref_image);
	},
	
	setPresetFav : function(preset_i){
		//make preset favorite by shifting its position to 0
		var rlpk = this;

		var index = preset_i;
		if(preset_i == null){
			index = rlpk.selected_preset_i;
		}
		rlpk.contents.splice(0,0,rlpk.contents.splice(index,1)[0]);
		rlpk.contents_preview_image.splice(0,0,rlpk.contents_preview_image.splice(index,1)[0]);
	},
	
	getPresetFav : function(){
		//for now while using index 0 as fav preset
		return this.contents[0].id;
	},
	
	makePreviewImage : function(preset_i,show){
		
		var rlpk = this;
		var previewImage = this.contents_preview_image[preset_i];
		
		if(this.contents[preset_i].ref_image == null)return;
		
		if(show == true){
			previewImage.onload = function(){
				rlpk.updatePreview();
			}
		}
		previewImage.src = this.contents[preset_i].ref_image;
	},
	
	updatePreview : function(){
		var rlpk = this;
		var previewImage = rlpk.contents_preview_image[rlpk.selected_preset_i];
		var wh_scale = 1;
		wh_scale = Math.min(rlpk.preview.width / previewImage.width, rlpk.preview.height / previewImage.height);
		
		var draw_w = Math.round(previewImage.width*wh_scale);
		var draw_h = Math.round(previewImage.height*wh_scale);
		var draw_x = Math.round(rlpk.preview.width/2-draw_w/2);
		var draw_y = Math.round(rlpk.preview.height/2-draw_h/2); 
		
		rlpk.preview_ctx.clearRect(0,0,rlpk.preview.width,rlpk.preview.height);
		rlpk.preview_ctx.drawImage(previewImage,draw_x,draw_y,draw_w,draw_h);
	},
	
	updateUIPresetConfigValues : function(){
		var rlpk = this;
		
		UI.ref_layer_preset_config_name.value = rlpk.selected_preset.name;
		
		rlpk.updatePreview();
		
		UI.ref_layer_config_align_left.checked = false;
		UI.ref_layer_config_align_center.checked = false;
		UI.ref_layer_config_align_right.checked = false;
		
		UI.ref_layer_preset_img_file.value = "";
		
		UI["ref_layer_config_align_"+rlpk.selected_preset.ref_image_align].checked = true;
		
	},
	
	makeUIRefLayerPresetItem : function(preset_i){
		var rlpk = this;
		var elem = document.createElement('li');
		elem.dataset.preset_i = preset_i;
		elem.addEventListener("click",function(e){
			e.stopPropagation();
			rlp_keeper.selectPreset(parseInt(this.dataset.preset_i));
			rlp_keeper.updateUIPresetConfigValues();
			selectRadioGroupBtn("ref-layer-preset-item-group",rlpk.selected_preset_i);
		});
		var elem_label = document.createElement('label');
		
		var m = document.createElement('input');
		m.setAttribute('type','radio');
		m.setAttribute('name','ref-layer-preset-item-group');
		m.className = "hidden-toggler ref-layer-preset-item-btn";
		elem_label.appendChild(m);
		
		var elem_content = document.createElement('span');
		elem_content.className = 'ref-layer-preset-item';
		elem_label.appendChild(elem_content);
		
		m = document.createElement('span');
		m.className = 'ref-layer-preset-item-name';
		m.textContent = rlpk.contents[preset_i].name;
		elem_content.appendChild(m);
		
		elem.appendChild(elem_label);
		return elem;
		/* scheme 
		<li>
		<label>
		<input type="radio" name="ref-layer-preset-item-group" class="hidden-toggler ref-layer-preset-item-btn" autocomplete="off">
		<span class="ref-layer-preset-item">
		<span class="ref-layer-preset-item-name">Palette 1 test big name to wrapping to second line</span>
		</span>
		</label>
		</li>
		*/
	},
	
	stackRefLayerPresetsUI : function(){
		var rlpk = this;
		var rlpresets_ui = document.createDocumentFragment();
		var rlps = [];//string
		for(var i=0;i<rlpk.contents.length;i++){
			rlpresets_ui.appendChild(rlpk.makeUIRefLayerPresetItem(i));
		}
		
		UI.ref_layer_preset_container.innerHTML = "";
		UI.ref_layer_preset_container.appendChild(rlpresets_ui);
		//UI selection
		selectRadioGroupBtn("ref-layer-preset-item-group",rlpk.selected_preset_i);
	},
	
	usePreset : function(preset_i){
		var rlpk = this;
		
		var ref_image = rlpk.contents_preview_image[preset_i];
		var wh_scale = 1;
		var draw_w = 1;
		var draw_h = 1;
		var draw_x = 0;
		//image is larger than ref layer area. Fit image
		if(ref_image.width > ref_layer.width || ref_image.height > ref_layer.height){
			//scale fit image
			wh_scale = Math.min(ref_layer.width / ref_image.width, ref_layer.height / ref_image.height);
			
			draw_w = Math.round(ref_image.width*wh_scale);
			draw_h = Math.round(ref_image.height*wh_scale);
			
		}else{
		//actual pixels
			draw_w = ref_image.width;
			draw_h = ref_image.height;
		}
		
		//align
		switch(rlpk.contents[preset_i].ref_image_align){
			case "left":
				draw_x = 0;
			break;
			//
			case "center":
				draw_x = Math.round( ((ref_layer.width - draw_w)/2) );
			break;
			//
			case "right":
				draw_x = ref_layer.width - draw_w;
			break;
		}
		
		ref_layer_ctx.clearRect(0,0,ref_layer.width,ref_layer.height);
		ref_layer_ctx.drawImage(ref_image,draw_x,0,draw_w,draw_h);
		
		//reset modifications counter
		rlpk.ref_layer_mod_count = 0;
		rlpk.ref_layer_mod_current = 0;
	},
	
	addSelectedLayerToRef : function(){
		var rlpk = this;
		var c_rect = live_view.getBoundingClientRect();
		var c_rect_ref = c_view.getBoundingClientRect();
		var to_chamberX =  -(c_rect.x - c_rect_ref.x);// canvas_view.current_zoom;
		var to_chamberY =  -(c_rect.y - c_rect_ref.y);// canvas_view.current_zoom;
		
		//small optimization to not try cutting large out of bounds chunks when zoomed far out
		if(selected_layer.view.width*canvas_view.current_zoom < ref_layer.width && selected_layer.view.height*canvas_view.current_zoom < ref_layer.height){
			//draw whole canvas with shrinked size
			var sx = 0;
			var sy = 0;
			var sw = selected_layer.view.width;//selected_layer.view.width;// / canvas_view.current_zoom;
			var sh = selected_layer.view.height;//selected_layer.view.height// / canvas_view.current_zoom;
			var dx = -to_chamberX;
			var dy = -to_chamberY;
			var dw = selected_layer.view.width * canvas_view.current_zoom;
			var dh = selected_layer.view.height * canvas_view.current_zoom;
		}else{
			//cut chunk out of canvas
			var sx = to_chamberX / canvas_view.current_zoom;
			var sy = to_chamberY / canvas_view.current_zoom;
			var sw = ref_layer.width / canvas_view.current_zoom;
			var sh = ref_layer.height / canvas_view.current_zoom;
			var dx = 0;
			var dy = 0;
			var dw = ref_layer.width;
			var dh = ref_layer.height;
		}
		//void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
		ref_layer_ctx.drawImage(selected_layer.view, sx,sy, sw,sh, dx,dy, dw,dh);
		
		rlpk.ref_layer_mod_count++;
	},
	
	storeRefLayer : function(){
		var rlpk = this;
		var contentBox = findContentBoundingBox(ref_layer,ref_layer_ctx);
		rlpk.ref_mediator.width = contentBox[2];
		rlpk.ref_mediator.height = contentBox[3];
		rlpk.ref_mediator_ctx.clearRect(0,0, rlpk.ref_mediator.width,rlpk.ref_mediator.height);
		//void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
		rlpk.ref_mediator_ctx.drawImage(ref_layer, contentBox[0],contentBox[1], contentBox[2],contentBox[3],0,0, rlpk.ref_mediator.width,rlpk.ref_mediator.height);
		
		rlpk.ref_layer_mod_current = rlpk.ref_layer_mod_count;
	},
	
	//similar to userPreset
	restoreRefLayer : function(){
		var rlpk = this;
		
		var ref_image = rlpk.ref_mediator;
		var preset_i = rlpk.selected_preset_i;
		var wh_scale = 1;
		var draw_w = 1;
		var draw_h = 1;
		var draw_x = 0;
		//image is larger than ref layer area. Fit image
		if(ref_image.width > ref_layer.width || ref_image.height > ref_layer.height){

			
		//may need to re-check
			if((ref_image.width - ref_layer.width) / ref_layer.width > (ref_image.height - ref_layer.height) / ref_layer.height){
				wh_scale = ref_layer.width / ref_image.width;
			}else{
				wh_scale = ref_layer.height / ref_image.height;
			}
			
			draw_w = Math.round(ref_image.width*wh_scale);
			draw_h = Math.round(ref_image.height*wh_scale);
			
		}else{
		//actual pixels
			draw_w = ref_image.width;
			draw_h = ref_image.height;
		}
		
		//align
		switch(rlpk.contents[preset_i].ref_image_align){
			case "left":
				draw_x = 0;
			break;
			//
			case "center":
				draw_x = Math.round( ((ref_layer.width - draw_w)/2) );
			break;
			//
			case "right":
				draw_x = ref_layer.width - draw_w;
			break;
		}
		
		ref_layer_ctx.clearRect(0,0,ref_layer.width,ref_layer.height);
		ref_layer_ctx.drawImage(ref_image,draw_x,0,draw_w,draw_h);
	},
	
	resizeWindowView : function(){
		var rlpk = this;
		ref_layer.style.display="block";
		
		if(rlpk.ref_layer_mod_count == 0){
		//ref layer was not modified
			ref_layer.width = ref_layer.offsetWidth;
			ref_layer.height = ref_layer.offsetHeight;
			ref_layer_ctx.imageSmoothingEnabled = false;
			rlpk.usePreset(rlpk.selected_preset_i);
		}else if(rlpk.ref_layer_mod_current < rlpk.ref_layer_mod_count) {
		//ref layer was modified, and need to store latest modification
			rlpk.storeRefLayer();
			ref_layer.width = ref_layer.offsetWidth;
			ref_layer.height = ref_layer.offsetHeight;
			ref_layer_ctx.imageSmoothingEnabled = false;
			rlpk.restoreRefLayer();
		}else{
		//ref layer was modified but mediator contains latest version
			ref_layer.width = ref_layer.offsetWidth;
			ref_layer.height = ref_layer.offsetHeight;
			ref_layer_ctx.imageSmoothingEnabled = false;
			rlpk.restoreRefLayer();
		}
		ref_layer.style.display="none";
	}


}

var rlp_keeper = new refLayerPresetKeeper();
//
var ref_layer = document.getElementById("refLayer");
ref_layer.width = ref_layer.offsetWidth;
ref_layer.height = ref_layer.offsetHeight;
var ref_layer_ctx = ref_layer.getContext("2d");
ref_layer_ctx.imageSmoothingEnabled = false;
//



//-----------------------------------Preset Structures END

//-----------------------------------Move Module structures

function moveModule(){
	var m = this;
	
	m.session_docVer = 0;
	m.opid = 0;
	
	m.layer_i = -1;
	m.target = "any";
	
	m.current_action = {};
	m.current_action.name = "move";//action type name
	m.current_action.data = null;//support data for action, like direction etc.
	
	m.move_src_type = "canvas";//to be set in prepareBuffers 
	//canvas, img - whether moving existing content or inbound img
	
	//for tracking of modes activated by modifier keys before action starts
	//this way when hk.getToolModState is requested during action - 
	//can compare to m.mode_pre_action and see if mode was activated during action
	m.mode_pre_action = null;//[false,false,false];//for now 3 modes/mod keys
	//to store current active modes, defined as a property for simpler
	//passthrough between action functions
	//requested with hk.getToolModState in actionDo
	m.mode = null;//[false,false,false];
	
	m.move_area_layer = new canvasBuffer();
	m.move_area_mask = new canvasBuffer();
	
	m.layer_buffer = new canvasBuffer();
	m.mask_buffer = new canvasBuffer();
	
	m.move_area_selection = new canvasBuffer();
	
	m.move_area_import = new canvasBuffer();
	
	//tracks center of the object
	//it is a shared point between content and mediator
	//render position calculations are made through center
	m.move_offsetX = 0;//the origin of the move start for that object
	m.move_offsetY = 0;
	
	m.mouseIsDown = false;
	
	m.drag_active = false;
	m.drag_originX = 0;//the origin of the current drag action
	m.drag_originY = 0;
	
	m.store_components = ["layer","mask","selection"];
	
	m.transform = {};
	m.transform.w = drawingAreaWidth;
	m.transform.h = drawingAreaHeight;
	m.transform.angle = 0;
	//for purpose of flipping horizontally and vertically
	m.transform.scaleX = 1;
	m.transform.scaleY = 1;
	m.boundingBox = [0,0, drawingAreaWidth,drawingAreaHeight];
	
	//for storing live transformation data
	m.transform.live = {};
	m.transform.live.w = 0;
	m.transform.live.h = 0;
	m.transform.live.angle = 0;
	m.transform.live.angle_dir_prev = 0;//directional angle, previous
	//active transform directional point
	//note: former versions used anchor approach, with anchor instead of dpoint
	m.transform.live.dpoint = [1,1];
	
	//mediators to hold transformed objects to then render
	m.mediator = {};
	m.mediator.size = 1;
	
	m.mediator.layer = document.createElement("canvas");
	m.mediator.layer_ctx = m.mediator.layer.getContext("2d");
	m.mediator.layer.width = 1;
	m.mediator.layer.height = 1;
	
	m.mediator.mask = document.createElement("canvas");
	m.mediator.mask_ctx = m.mediator.mask.getContext("2d");
	m.mediator.mask.width = 1;
	m.mediator.mask.height = 1;
	
	m.mediator.selection = document.createElement("canvas");
	m.mediator.selection_ctx = m.mediator.selection.getContext("2d");
	m.mediator.selection.width = 1;
	m.mediator.selection.height = 1;
	m.mediator.selection.imageSmoothingEnabled = false;
	
	//to support getting contentBox
	//note: calculating contentBox is sometimes inaccurate by 1px.
	//so using a footprint canvas instead
	m.mediator.footprint = document.createElement("canvas");
	m.mediator.footprint_ctx = m.mediator.footprint.getContext("2d");
	m.mediator.footprint.width = 1;
	m.mediator.footprint.height = 1;
	m.mediator.footprint.imageSmoothingEnabled = false;
	
	//for showing transformations live, during mouse down etc.
	m.mediator.live_transform = document.createElement("canvas");
	m.mediator.live_transform_ctx = m.mediator.live_transform.getContext("2d");
	m.mediator.live_transform.width = drawingAreaWidth;
	m.mediator.live_transform.height = drawingAreaHeight;
	
	
	//NOTE: switched to content center point positioning
	//instead of content edge top-left point
	//m.mediator.contentBox and m.mediator.contentCenter unused as a result
	//content bounding box relative to mediator, position of center
	//[x,y, w,h]
	m.mediator.contentBox = [0,0,0,0];
	//center point position relative to content
	m.mediator.contentCenter = [0,0];//to avoid unnecessary recalculation
	
	//center point relative to mediator
	m.mediator.center = 0;
	//
	
	//for things like clipboard mediation and export selected content etc.
	m.selected_content_buffer = new canvasBuffer();
	
	//clipboard handling stores
	m.clipboard = {};
	m.clipboard.occupied = false;
	m.clipboard.data = null;//stores base64 URI, or perhaps some blob form, depending on implementation
	m.clipboard.img = new Image();
	//init buffer as black square
	m.clipboard.buffer = new canvasBuffer(null,100,100);
	
	m.config = {};
	m.config.mask_link = true;
	
}

moveModule.prototype = {

	//support for gathering content to perform a move
	prepareBuffers : function(img){
		var m = this;
		//flag variable to use to indicate that buffer canvases need to be
		//updated with new corresponding content
		var require_update = false;
		
		//STEP 1
		//check docVer to see if other functions/modules modified document
		const current_docVer = history_keeper.docVer;
		const current_opid = history_keeper.opid;
		/*
		require_update = (current_docVer <= m.session_docVer)
						|| (m.docVer < current_docVer);
		*/			
		require_update = m.opid < current_opid || current_docVer <= m.session_docVer;
		//STEP 2
		//check if layer needs to be changed then change it
		//(only if there been no active selection)
		//TODO
		/* no feature for now
		if(m.config.find_content == true && m.selection_active == false){
			//seeking layer with non-empty pixels and switching to it
		}
		*/
		//STEP 3
		//check if layer is not the same or target has changed
		require_update = require_update || m.layer_i != selected_layer_i || m.target != selected_layer.target;
		m.target = selected_layer.target;
		m.layer_i = selected_layer_i;
		//STEP 4
		//a. call history store. b. update this module docVer 
		//TODO a.
		
		//STEP 5
		//update canvas buffers if needed
		if(require_update == true || img != null){
		
			
			if(img != null){
				m.move_src_type = "img";
			//deal with given image
				var wh_scale = 1;
				var draw_w = 1;
				var draw_h = 1;
				var draw_x = 0;
				var draw_y = 0;
				
				//image is larger than ref layer area. Fit image
				if(img.width > selected_layer.c.width || img.height > selected_layer.c.height){
				//scale fit image
					wh_scale = Math.min(selected_layer.c.width / img.width, selected_layer.c.height / img.height);
					
					draw_w = Math.round(img.width*wh_scale);
					draw_h = Math.round(img.height*wh_scale);
					
				}else{
				//actual pixels
					draw_w = img.width;
					draw_h = img.height;
				}
				//center image
				draw_x = Math.round((selected_layer.c.width - draw_w)/2);
				draw_y = Math.round((selected_layer.c.height - draw_h)/2);
				
				//make selection of same dimensions as image
				selection_module.selection_active = true;
				m.selection_active = true;
				//manually set this buffer because of fillRect
				m.move_area_selection.c.width = img.width;
				m.move_area_selection.c.height = img.height;
				m.move_area_selection.ctx.fillRect(0,0, img.width,img.height);
				
				if(m.target == "layer"){
					m.layer_buffer.put(selected_layer.c);
					//store full width and height of image
					m.move_area_layer.put(img);
				}else if(m.target == "mask"){
					m.mask_buffer.put(selected_layer.mask);
					//store full width and height of image
					m.move_area_mask.put(img);
					colorToAlphaWhite(m.move_area_mask.c,m.move_area_mask.ctx);
				}
				
				m.move_offsetX = Math.floor(draw_x + draw_w/2);
				m.move_offsetY = Math.floor(draw_y + draw_h/2);
				m.transform.w = draw_w;
				m.transform.h = draw_h;
				m.transform.angle = 0;
				
				m.boundingBox[0] = 0;
				m.boundingBox[1] = 0;
				m.boundingBox[2] = img.width;
				m.boundingBox[3] = img.height;
				
				require_update = true;
				
			}else{
			//no img processing
				m.move_src_type = "canvas";
				m.selection_active = selection_module.selection_active;
				m.defineBoundingBox();
				m.target = selected_layer.target;
				//load up buffers
				if(m.selection_active == true){
					
					if(m.target == "layer"){
						m.move_area_layer.put(selected_layer.c, 
								m.boundingBox[0],m.boundingBox[1],m.boundingBox[2],m.boundingBox[3]);
						m.layer_buffer.put(selected_layer.c);
						
						//apply selection
						m.move_area_layer.ctx.globalCompositeOperation = "destination-in";
						m.move_area_layer.ctx.drawImage(selection_module.selection, -m.boundingBox[0],-m.boundingBox[1]);
						m.move_area_layer.ctx.globalCompositeOperation = "source-over";
						
						m.layer_buffer.ctx.globalCompositeOperation = "destination-out";
						m.layer_buffer.ctx.drawImage(selection_module.selection,0,0);
						m.layer_buffer.ctx.globalCompositeOperation = "source-over";
						
					}
					
					if(m.config.mask_link == true && selected_layer.mask_enabled == true){
						m.move_area_mask.put(selected_layer.mask,
								m.boundingBox[0],m.boundingBox[1],m.boundingBox[2],m.boundingBox[3]);
						m.mask_buffer.put(selected_layer.mask);
						
						//apply selection
						m.move_area_mask.ctx.globalCompositeOperation = "destination-in";
						m.move_area_mask.ctx.drawImage(selection_module.selection, -m.boundingBox[0],-m.boundingBox[1]);
						m.move_area_mask.ctx.globalCompositeOperation = "source-over";
						
						m.mask_buffer.ctx.globalCompositeOperation = "destination-out";
						m.mask_buffer.ctx.drawImage(selection_module.selection,0,0);
						m.mask_buffer.ctx.globalCompositeOperation = "source-over";
						
					}
					
					/* legacy, layer separate from mask when selection active
					}else if(m.target == "mask"){
						m.move_area_mask.put(selected_layer.mask,
								m.boundingBox[0],m.boundingBox[1],m.boundingBox[2],m.boundingBox[3]);
						m.mask_buffer.put(selected_layer.mask);
						
						//apply selection
						m.move_area_mask.ctx.globalCompositeOperation = "destination-in";
						m.move_area_mask.ctx.drawImage(selection_module.selection, -m.boundingBox[0],-m.boundingBox[1]);
						m.move_area_mask.ctx.globalCompositeOperation = "source-over";
						
						m.mask_buffer.ctx.globalCompositeOperation = "destination-out";
						m.mask_buffer.ctx.drawImage(selection_module.selection,0,0);
						m.mask_buffer.ctx.globalCompositeOperation = "source-over";
						
					}
					*/
					
					m.move_area_selection.put(selection_module.selection,
							m.boundingBox[0],m.boundingBox[1],m.boundingBox[2],m.boundingBox[3]);
					//m.move_area_selection_outline.put(selection_module.selection_view);
					
				}else{
					
					if(m.target == "layer"){
						m.move_area_layer.put(selected_layer.c);
						
						if(m.config.mask_link == true && selected_layer.mask_enabled == true){
							m.move_area_mask.put(selected_layer.mask);
						}
					}else if(m.target == "mask"){
						m.move_area_mask.put(selected_layer.mask);
					}
					
					
				}
			}//no img end
			//

			//setup mediators
			m.fitMediators();
			m.drawMediators();
			//m.defineMediatorContentBox();
			
			//history logistics
			m.store_components = [];
			m.store_components.push("layer");
			if(selected_layer.mask != null)m.store_components.push("mask");
			if(m.selection_active == true)m.store_components.push("selection");
			m.store_components.push("moveTranslateX");
			m.store_components.push("moveTranslateY");
			m.store_components.push("moveTransformW");
			m.store_components.push("moveTransformH");
			m.store_components.push("moveTransformAngle");
			//
			m.session_docVer = current_docVer;
		}
		return require_update;
	},
	
	defineBoundingBox : function(){
		var m = this;
		if(selection_module.selection_active == true){
		//note the difference between 
		//local m.selection_active and selection_module.selection_active 
			m.boundingBox = selection_module.getBoundingBox();
		}else{
			m.boundingBox = [0,0, drawingAreaWidth,drawingAreaHeight];
		}
		m.move_offsetX = Math.floor(m.boundingBox[0] + m.boundingBox[2]/2);
		m.move_offsetY = Math.floor(m.boundingBox[1] + m.boundingBox[3]/2);
		m.transform.w = m.boundingBox[2];
		m.transform.h = m.boundingBox[3];
		m.transform.angle = 0;
		
	},
	
	defineMediatorContentBox : function(){
		var m = this;
		m.mediator.contentBox = findContentBoundingBox(m.mediator.footprint,m.mediator.footprint_ctx);
		//
		m.mediator.contentCenter = [
			m.mediator.center-m.mediator.contentBox[0],
			m.mediator.center-m.mediator.contentBox[1]
			];
		return;
	},
	
	
	fitMediators : function(){
	//Resizes mediators and determines necessary values
	//such as contentBox etc.
	//somewhat similar to prepareMediators, but this can be called 
	//anytime sigfinicant modifications were done to content
	//like content dimensions changed and require new mediator size
		var m = this;
		var mediator_size = Math.ceil( Math.sqrt(m.transform.w*m.transform.w + m.transform.h*m.transform.h) );
		//+1 leeway pixel from each side and make mediator size even
		mediator_size += 2 + mediator_size%2;
		if(mediator_size == m.mediator.size)return;
		m.mediator.size = mediator_size;
		m.mediator.layer.width = mediator_size;
		m.mediator.layer.height = mediator_size;
		
		m.mediator.mask.width = mediator_size;
		m.mediator.mask.height = mediator_size;
		
		m.mediator.selection.width = mediator_size;
		m.mediator.selection.height = mediator_size;
		
		m.mediator.footprint.width = mediator_size;
		m.mediator.footprint.height = mediator_size;
		
		m.mediator.center = Math.floor(mediator_size/2);
		
	},
	
	drawMediators : function(){
	//this is where content transformations happen
	//transformed version is stored into a mediator
	//check/make size of mediators
	//draw with transforms - width, height, rotation angle, reflect x and y
	//note: perhaps change function purpose to apply transformations
		var m = this;
		
		m.mediator.layer_ctx.clearRect(0,0, m.mediator.layer.width,m.mediator.layer.height);
		m.mediator.mask_ctx.clearRect(0,0, m.mediator.mask.width,m.mediator.mask.height);
		m.mediator.selection_ctx.clearRect(0,0, m.mediator.selection.width,m.mediator.selection.height);
		m.mediator.footprint_ctx.clearRect(0,0, m.mediator.footprint.width,m.mediator.footprint.height);
		
		var draw_x = 0;
		var draw_y = 0;
		//rotate
		if(m.transform.angle == 0){
			draw_x = m.mediator.center - Math.floor(m.transform.w/2);
			draw_y = m.mediator.center - Math.floor(m.transform.h/2);
		}else{
			m.mediator.layer_ctx.translate(m.mediator.center, m.mediator.center);
			m.mediator.layer_ctx.rotate(m.transform.angle);
			
			m.mediator.mask_ctx.translate(m.mediator.center, m.mediator.center);
			m.mediator.mask_ctx.rotate(m.transform.angle);
			
			m.mediator.selection_ctx.translate(m.mediator.center, m.mediator.center);
			m.mediator.selection_ctx.rotate(m.transform.angle);
			
			m.mediator.footprint_ctx.translate(m.mediator.center, m.mediator.center);
			m.mediator.footprint_ctx.rotate(m.transform.angle);
			
			draw_x -= Math.floor(m.transform.w/2);
			draw_y -= Math.floor(m.transform.h/2);
		}
		
			//layer
		m.mediator.layer_ctx.drawImage(m.move_area_layer.c,
			0,0,
			m.move_area_layer.c.width, m.move_area_layer.c.height,
			draw_x,
			draw_y,
			m.transform.w, m.transform.h);

			//mask
		m.mediator.mask_ctx.drawImage(m.move_area_mask.c,
			0,0,
			m.move_area_mask.c.width, m.move_area_mask.c.height,
			draw_x,
			draw_y,
			m.transform.w, m.transform.h);

			//selection
		m.mediator.selection_ctx.drawImage(m.move_area_selection.c,
			0,0,
			m.move_area_selection.c.width, m.move_area_selection.c.height,
			draw_x,
			draw_y,
			m.transform.w, m.transform.h);
			
			//footprint
		if(m.selection_active == true){
		//base footprint on selection
			m.mediator.footprint_ctx.drawImage(m.move_area_selection.c,
				0,0,
				m.move_area_selection.c.width, m.move_area_selection.c.height,
				draw_x,
				draw_y,
				m.transform.w, m.transform.h);
		}else{
		//base footprint on a rectangle
			m.mediator.footprint_ctx.fillRect(draw_x,draw_y, m.transform.w,m.transform.h);
		}
		//
		
		//restore
		if(m.transform.angle != 0){
			m.mediator.layer_ctx.rotate(-m.transform.angle);
			m.mediator.layer_ctx.translate(-m.mediator.center, -m.mediator.center);
			
			m.mediator.mask_ctx.rotate(-m.transform.angle);
			m.mediator.mask_ctx.translate(-m.mediator.center, -m.mediator.center);
			
			m.mediator.selection_ctx.rotate(-m.transform.angle);
			m.mediator.selection_ctx.translate(-m.mediator.center, -m.mediator.center);
			
			m.mediator.footprint_ctx.rotate(-m.transform.angle);
			m.mediator.footprint_ctx.translate(-m.mediator.center, -m.mediator.center);
			
		}
		
	},
	
	moveContent : function(x,y){
	//moves target content using given absolute CENTER x,y values
	//also happens to be main render function for content that is being moved
	//renders from mediators
		var m = this;
		
		var c_x,c_y;
		if(x != null){
			c_x = x;
		}else{
			c_x = m.move_offsetX;
		}
		
		if(y != null){
			c_y = y;
		}else{
			c_y = m.move_offsetY;
		}
		//
		
		c_x -= m.mediator.center;
		c_y -= m.mediator.center;
		
		//console.log(m.target);
		if(m.selection_active == true){
			
			//layer 
			if(m.target == "layer"){
			
				m.layer_buffer.output(selected_layer.ctx);
				
				selected_layer.ctx.drawImage(m.mediator.layer, c_x,c_y);
			}
			
			//mask, only touch it if target is mask or moving canvas content
			if((m.target == "mask" || m.move_src_type == "canvas") && m.config.mask_link == true && selected_layer.mask_enabled == true){
			
				m.mask_buffer.output(selected_layer.mask_ctx);
				
				//stomping footprint of selected area
				selected_layer.mask_ctx.globalCompositeOperation = "destination-out";
				selected_layer.mask_ctx.drawImage(m.mediator.footprint, c_x,c_y);
				selected_layer.mask_ctx.globalCompositeOperation = "source-over";
				
				
				selected_layer.mask_ctx.drawImage(m.mediator.mask, c_x,c_y);
			}
			
		}else{
			if(m.target == "layer"){
				selected_layer.ctx.clearRect(0,0, selected_layer.c.width,selected_layer.c.height);
				selected_layer.ctx.drawImage(m.mediator.layer, c_x,c_y);
				
				if(m.config.mask_link == true && selected_layer.mask_enabled == true){
					selected_layer.mask_ctx.clearRect(0,0, selected_layer.mask.width,selected_layer.mask.height);
					selected_layer.mask_ctx.drawImage(m.mediator.mask, c_x,c_y);
				}
			}else if(m.target == "mask"){
				selected_layer.mask_ctx.clearRect(0,0, selected_layer.mask.width,selected_layer.mask.height);
				selected_layer.mask_ctx.drawImage(m.mediator.mask, c_x,c_y);
			}
		}
	},
	
	moveSelection : function(){
		var m = this;
		if(m.selection_active == true){
			//move the actual selection to place and make new outline
			selection_module.selection_ctx.clearRect(0,0, selection_module.selection.width,selection_module.selection.height);
			selection_module.selection_ctx.drawImage(m.mediator.selection, m.move_offsetX-m.mediator.center,m.move_offsetY-m.mediator.center);
			selection_module.detectSelection();
			selection_module.makeSelectionOutline();
		}
	},
	
	//// pointer action managing
	
	actionStart : function(e,action_type,data){
		var m = this;
		var type;
		if(action_type == null){
			type = "move";
		}else{
			type = action_type;
		}
		m.current_action.name = type;
		if(data != null){
			m.current_action.data = data;
		}
		
		hideUIElement(UI.mt_transform_box);
		
		if(m.prepareBuffers() == true){
			history_keeper.store("moveModule",current_tool,toolset_mode,selected_layer_i,m.store_components);
			m.opid = history_keeper.opid;
		}
		//
		//note: it's okay to do a shared array here
		//because m.mode will get a new separate in actionDo
		//also for now there are no modifications to these arrays
		let mod_state = hk.getToolModState(current_tool);
		m.mode = mod_state;
		m.mode_pre_action = mod_state;
		//
		switch(type){
			case "move":
				m.moveStart(e);
			break;
			//
			case "size":
				m.liveTransformStart(e,type);
			break;
			//
			case "rotate":
				m.liveTransformStart(e,type);
			break;
			//
			default:
				m.moveStart(e);
		}
		//
		
	},
	
	actionDo : function(e){
		var m = this;
		var type = m.current_action.name;
		var data = m.current_action.data;
		
		m.mode = hk.getToolModState(current_tool);
		
		switch(type){
			case "move":
				m.moveDo(e);
			break;
			//
			case "size":
				m.liveTransformDo(e,type,data);
			break;
			//
			case "rotate":
				m.liveTransformDo(e,type,data);
			break;
			//
			default:
				m.moveDo(e);
		}
		//

	},
	
	actionEnd : function(e){
		var m = this;
		var type = m.current_action.name;
		var data = m.current_action.data;
		switch(type){
			case "move":
				m.moveEnd(e);
			break;
			//
			case "size":
				m.liveTransformEnd(e,type);
			break;
			//
			case "rotate":
				m.liveTransformEnd(e,type);
			break;
			//
			default:
				m.moveEnd(e);
		}
		//
		m.updateUITransformControls();
		showUIElement(UI.mt_transform_box);
	},
	
	//// moving 
	moveStart : function(e){
		if(selection_module.selection_active == true)selection_module.clearSelectionView();
	
		var m = this;
		
		var c_rect = live_view.getBoundingClientRect();
		//note: floor seems to work more precise
		var x = Math.floor((e.x-c_rect.x)/canvas_view.current_zoom);
		var y = Math.floor((e.y-c_rect.y)/canvas_view.current_zoom);
		
		m.drag_active = true;
		m.drag_originX = x;
		m.drag_originY = y;
		
	},
	
	moveDo : function(e){
		var m = this;
		
		var c_rect = live_view.getBoundingClientRect();
		//note: floor seems to work more precise
		var x = Math.floor((e.x-c_rect.x)/canvas_view.current_zoom);
		var y = Math.floor((e.y-c_rect.y)/canvas_view.current_zoom);
		
		var c_x = m.move_offsetX + x-m.drag_originX;
		var c_y = m.move_offsetY + y-m.drag_originY;
		
		m.moveContent(c_x,c_y);
		
		m.updateUIConfigMenu(c_x,c_y);
		
		selected_layer.updateView();
		stackLiveView();
	},
	
	moveEnd : function(e){
		var m = this;
		
		var c_rect = live_view.getBoundingClientRect();
		//note: floor seems to work more precise
		var x = Math.floor((e.x-c_rect.x)/canvas_view.current_zoom);
		var y = Math.floor((e.y-c_rect.y)/canvas_view.current_zoom);
		
		m.move_offsetX += x-m.drag_originX;
		m.move_offsetY += y-m.drag_originY;
		
		m.moveSelection();
		m.drag_active = false;
	},
	
	//nudges content in direction with a multiplier
	nudgeDo : function(d,mult){
		var m = this;
		var dx = 0;
		var dy = 0;
		
		checkToolsetMode();
		if(m.prepareBuffers() == true){
			history_keeper.store("moveModule",current_tool,toolset_mode,selected_layer_i,m.store_components);
			m.opid = history_keeper.opid;
		}
		
		switch(d){
			//LEFT
			case 1:
				dx =-1;
			break;
			//
			//UP
			case 2:
				dy = -1;
			break;
			//
			//RIGHT
			case 3:
				dx = 1;
			break;
			//
			//DOWN
			case 4:
				dy = 1;
			break;
			//
		}
		if(mult != null){
			dx = dx*mult;
			dy = dy*mult;
		}
		
		m.move_offsetX += dx;
		m.move_offsetY += dy;
		
		m.moveContent();
		
		m.updateUIConfigMenu();
		m.updateUITransformControls();
		
		selected_layer.updateView();
		stackLiveView();
	},
	
	nudgeEnd : function(){
		var m = this;
		m.moveSelection();
	},
	
	setTranslate : function(x,y){
		var m = this;
		
		checkToolsetMode();
		if(m.prepareBuffers() == true){
			history_keeper.store("moveModule",current_tool,toolset_mode,selected_layer_i,m.store_components);
			m.opid = history_keeper.opid;
		}
		
		m.move_offsetX = x;
		m.move_offsetY = y;

		m.moveContent();
		
		m.moveSelection();
		
		m.updateUIConfigMenu();
		
		selected_layer.updateView();
		stackLiveView();
	},
	
	centerContentHV : function(h,v){
	//H - horizontal: x position multiplier relative to canvas width
	//V - vertical: y position multiplier relative to canvas height
	//example: 0.5 means center point of canvas
	//because m.move_offsetX points to center of content, 
	//this will center content horizontally on canvas
	//h and/or v can be boolean false, meaning skip
	//also could be used for various snapping to grids
		var m = this;
		
		checkToolsetMode();
		if(m.prepareBuffers() == true){
			history_keeper.store("moveModule",current_tool,toolset_mode,selected_layer_i,m.store_components);
			m.opid = history_keeper.opid;
		}
		
		if(h !== false) m.move_offsetX = Math.floor(drawingAreaWidth * h);
		if(v !== false) m.move_offsetY = Math.floor(drawingAreaHeight * v);
		
		
		m.moveContent();
		
		m.moveSelection();
		
		m.updateUIConfigMenu();
		
		selected_layer.updateView();
		stackLiveView();
	},
	
	flipSelectedContent : function(scaleX,scaleY){
		var m = this;
		
		checkToolsetMode();
		if(m.prepareBuffers() == true){
			history_keeper.store("moveModule",current_tool,toolset_mode,selected_layer_i,m.store_components);
			m.opid = history_keeper.opid;
		}
		//
		
		flipContent(m.move_area_layer.c,m.move_area_layer.ctx, scaleX,scaleY);
		flipContent(m.move_area_mask.c,m.move_area_mask.ctx, scaleX,scaleY);
		flipContent(m.move_area_selection.c,m.move_area_selection.ctx, scaleX,scaleY);
		
		//
		m.drawMediators();

		m.moveContent();
		
		m.moveSelection();
		
		m.updateUIConfigMenu();
		
		selected_layer.updateView();
		stackLiveView();
	},
	
	setTransformSize : function(w,h,dpoint){
	//dpoint - [x_direction, y_direction]
	//dpoint values tell which direction to transform
	//-1 to 1 with 0 being middle middle
	//[-1 is left, -1 is top]
	//[1 is right, 1 is bottom]
	
		var m = this;
		
		checkToolsetMode();
		if(m.prepareBuffers() == true){
			history_keeper.store("moveModule",current_tool,toolset_mode,selected_layer_i,m.store_components);
			m.opid = history_keeper.opid;
		}
		if(dpoint == null)dpoint=[0,0];
		w = Math.max(1,w);
		h = Math.max(1,h);
		/* 
		//anchored transform calculation version
		let angle = m.transform.angle;
		let c_x = (w - m.transform.w)/2;//difference between centers
		let c_y = (h - m.transform.h)/2;
		//^note: can set anchors by setting c_x and c_y to +,0,-
		let temp_x = c_x*Math.cos(angle) - c_y*Math.sin(angle);
		let temp_y = c_y*Math.cos(angle) + c_x*Math.sin(angle);
		
		m.move_offsetX += Math.round(temp_x);
		m.move_offsetY += Math.round(temp_y);
		*/
		
		
		//
		var c_x = dpoint[0]*Math.floor((w - m.transform.w)/2);
		var c_y = dpoint[1]*Math.floor((h - m.transform.h)/2);
		
		if(dpoint[0] < 0){
			if(m.transform.w%2 != w%2){
				c_x += dpoint[0]*(w%2);
			}
		}else{
			if(m.transform.w%2 != w%2){
				c_x += dpoint[0]*(1-w%2);
			}
		}
		//
		if(dpoint[1] < 0){
			if(m.transform.h%2 != h%2){
				c_y += dpoint[1]*(h%2);
			}
		}else{
			if(m.transform.h%2 != h%2){
				c_y += dpoint[1]*(1-h%2);
			}
		}
		
		m.transform.w = w;
		m.transform.h = h;
		
		m.fitMediators();
		m.drawMediators();
		
		let angle = m.transform.angle;
		let temp_x = c_x*Math.cos(angle) - c_y*Math.sin(angle);
		let temp_y = c_y*Math.cos(angle) + c_x*Math.sin(angle);
		
		m.move_offsetX += Math.floor(temp_x);
		m.move_offsetY += Math.floor(temp_y);

		m.moveContent();
		
		m.moveSelection();
		
		m.updateUIConfigMenu();
		
		selected_layer.updateView();
		stackLiveView();
	},
	
	resetTransformDimensions : function(){
	//reset transform dimenstions	
		var m = this;
		
		checkToolsetMode();
		if(m.prepareBuffers() == true){
			history_keeper.store("moveModule",current_tool,toolset_mode,selected_layer_i,m.store_components);
			m.opid = history_keeper.opid;
		}

		m.transform.w = m.boundingBox[2];
		m.transform.h = m.boundingBox[3];
		
		
		m.fitMediators();
		m.drawMediators();
		
		if(m.move_offsetX < 0)m.move_offsetX = 0;
		if(m.move_offsetY < 0)m.move_offsetY = 0;
		if(m.move_offsetX > drawingAreaWidth)m.move_offsetX = drawingAreaWidth;
		if(m.move_offsetY > drawingAreaHeight)m.move_offsetY = drawingAreaHeight;
		//
		m.moveContent();
		m.moveSelection();
		
		m.updateUIConfigMenu();
		
		selected_layer.updateView();
		stackLiveView();
	},
	
	setTransformRotate : function(angle){
	//expects angle in radians
		var m = this;
		
		checkToolsetMode();
		if(m.prepareBuffers() == true){
			history_keeper.store("moveModule",current_tool,toolset_mode,selected_layer_i,m.store_components);
			m.opid = history_keeper.opid;
		}
		
		m.transform.angle = angle;
		
		m.drawMediators();
		
		//
		m.moveContent();
		
		m.moveSelection();
		
		m.updateUIConfigMenu();
		
		selected_layer.updateView();
		stackLiveView();
	},
	
	fitTransformDimensions : function(){
		var m = this;
		
		checkToolsetMode();
		if(m.prepareBuffers() == true){
			history_keeper.store("moveModule",current_tool,toolset_mode,selected_layer_i,m.store_components);
			m.opid = history_keeper.opid;
		}
		
		//scale fit
		let wh_scale = Math.min(selected_layer.c.width / m.boundingBox[2], selected_layer.c.height / m.boundingBox[3]);
		
		m.transform.w = Math.round(m.boundingBox[2]*wh_scale);
		m.transform.h = Math.round(m.boundingBox[3]*wh_scale);
		m.transform.angle = 0;
		
		m.move_offsetX = Math.floor(selected_layer.c.width/2);
		m.move_offsetY = Math.floor(selected_layer.c.height/2);
		
		m.fitMediators();
		m.drawMediators();
		
		m.moveContent();
		m.moveSelection();
		
		m.updateUIConfigMenu();
		
		selected_layer.updateView();
		stackLiveView();
	},
	
	liveTransformStart : function(e,type){
		if(selection_module.selection_active == true)selection_module.clearSelectionView();
		
		var m = this;
		
		var c_rect = live_view.getBoundingClientRect();
		//note: floor seems to work more precise
		var x = Math.floor((e.x-c_rect.x)/canvas_view.current_zoom);
		var y = Math.floor((e.y-c_rect.y)/canvas_view.current_zoom);
		
		m.drag_active = true;
		m.drag_originX = x;
		m.drag_originY = y;
		//
		m.transform.live.w = m.transform.w;
		m.transform.live.h = m.transform.h;
		m.transform.live.angle = m.transform.angle;
		
		if(type == "rotate"){
			m.transform.live.angle_dir_prev = -Math.atan2( -(y-m.move_offsetY), x-m.move_offsetX) + Math.PI;
		}
		
		//check necessary preliminaries
		if(m.mediator.live_transform.width != drawingAreaWidth || m.mediator.live_transform.height != drawingAreaHeight){
			m.mediator.live_transform.width = drawingAreaWidth;
			m.mediator.live_transform.height = drawingAreaHeight;
		}
	},
	
	liveTransformDo : function(e,type,data){
		//parse/process input from UI transform controls
		//calls proper function to show live transform
		var m = this;
		
		var c_rect = live_view.getBoundingClientRect();
		//note: floor seems to work more precise
		var x = Math.floor((e.x-c_rect.x)/canvas_view.current_zoom);
		var y = Math.floor((e.y-c_rect.y)/canvas_view.current_zoom);
		
		
		
		switch(type){
			case "size":
				let dpoint = data;
				let angle = m.transform.angle;
				let dx = x-m.drag_originX;
				let dy = y-m.drag_originY;
				let dw = dx*Math.cos(-angle) - dy*Math.sin(-angle);
				let dh = dy*Math.cos(-angle) + dx*Math.sin(-angle);
				
				
				//both ways
				if(m.mode[2] == true){
					dw *= 2*dpoint[0];
					dh *= 2*dpoint[1];
					dpoint = [0,0];
				}else{
					dw *= dpoint[0];
					dh *= dpoint[1];
				}
				
				let w = Math.max(1, Math.round(m.transform.w + dw) );
				let h = Math.max(1, Math.round(m.transform.h + dh) );
				
				//constrain proportions
				if(m.mode[0] == true){
					if((m.transform.h > m.transform.w && data[1] != 0) || data[0] == 0){
						w = Math.round(h*(m.transform.w/m.transform.h));
					}else{
						h = Math.round(w*(m.transform.h/m.transform.w));
					}
				}
				//limit maximum size
				w = Math.min(8000,w);
				h = Math.min(8000,h);
				//
				m.transform.live.w = w;
				m.transform.live.h = h;
				m.transform.live.dpoint[0] = dpoint[0];
				m.transform.live.dpoint[1] = dpoint[1];
				//
				m.liveTransformBasic(w,h,dpoint);
				//
				UI.mt_area_w.value = w;
				UI.mt_area_h.value = h;
			break;
			//
			case "rotate":
				var a_p = m.transform.live.angle_dir_prev;//angle directional previous
				var a_c = -Math.atan2( -(y-m.move_offsetY), x-m.move_offsetX) + Math.PI;//angle directional current
				var d_a = a_c - a_p;//angle directional delta
				
				if(Math.abs(d_a) > Math.PI){
				//more than 180 difference
				//then do 360-difference
					d_a = -Math.sign(d_a)*((Math.PI*2) - Math.abs(d_a));
				}
				
				
				
				var live_angle = m.transform.live.angle;
				//convert to degrees
				live_angle = live_angle * 180/Math.PI;
				d_a = d_a * 180/Math.PI;
				
				
				
				if(m.mode[0] == true){//
				//stepped angle 5 degree
					live_angle = Math.round(live_angle);
					var angle_step = 5;
					d_a = d_a - ( (live_angle+d_a) % angle_step );
					live_angle = live_angle + d_a;
					
					a_c = a_p + (d_a * Math.PI/180);
					
				}else{
					live_angle += d_a;
				}
				
				//limit from -360 to 360
				live_angle = live_angle % 360;
				
				m.transform.live.angle = live_angle * Math.PI/180;
				m.transform.live.angle_dir_prev = a_c;
				m.liveTransformBasic(m.transform.w,m.transform.h,[0,0]);
				//
				UI.mt_area_angle.value = (m.transform.live.angle*180/Math.PI).toFixed(2);
				
			break;
		}
		
	},
	
	liveTransformEnd : function(e){
		var m = this;
		m.drag_active = false;
		try{
			switch(m.current_action.name){
				case "size":
					m.setTransformSize(m.transform.live.w, m.transform.live.h, m.transform.live.dpoint);
				break;
				//
				case "rotate":
					m.setTransformRotate(m.transform.live.angle);
				break;
				//
			}
			
		}catch(err){
			console.log(err);
			alert(err);
		}
	},
	
	liveTransformBasic : function(w,h,dpoint){
		//live resize and rotate
		//Hybrid between moveContent and transform functions
		//using m.mediator.live_transform
		var m = this;
		
		var angle = m.transform.live.angle;
		var c_x = Math.floor(w/2 - dpoint[0]*(w - m.transform.w)/2);
		var c_y = Math.floor(h/2 - dpoint[1]*(h - m.transform.h)/2);
		
		//
		m.mediator.live_transform_ctx.clearRect(0,0, m.mediator.live_transform.width,m.mediator.live_transform.height);
		m.mediator.live_transform_ctx.translate(m.move_offsetX,m.move_offsetY);
		m.mediator.live_transform_ctx.rotate(angle);
		//
		
		if(m.selection_active == true){
			//layer
			if(m.target == "layer"){
				m.mediator.live_transform_ctx.drawImage(m.move_area_layer.c, -c_x,-c_y, w,h);
				m.layer_buffer.output(selected_layer.ctx);
				selected_layer.ctx.drawImage(m.mediator.live_transform, 0,0);
				m.mediator.live_transform_ctx.clearRect(-c_x,-c_y, w,h);
			}
			
			//mask, same condition as in moveContent
			if((m.target == "mask" || m.move_src_type == "canvas") && m.config.mask_link == true && selected_layer.mask_enabled == true){
				
				m.mask_buffer.output(selected_layer.mask_ctx);
				
				//selection footprint
				m.mediator.live_transform_ctx.drawImage(m.move_area_selection.c, -c_x,-c_y, w,h);
				selected_layer.mask_ctx.globalCompositeOperation = "destination-out";
				selected_layer.mask_ctx.drawImage(m.mediator.live_transform, 0,0);
				selected_layer.mask_ctx.globalCompositeOperation = "source-over";
				m.mediator.live_transform_ctx.clearRect(-c_x,-c_y, w,h);
				
				m.mediator.live_transform_ctx.drawImage(m.move_area_mask.c, -c_x,-c_y, w,h);
				selected_layer.mask_ctx.drawImage(m.mediator.live_transform, 0,0);
			}
		}else{
			//layer
			if(m.target == "layer"){
				
				m.mediator.live_transform_ctx.drawImage(m.move_area_layer.c, -c_x,-c_y, w,h);
				selected_layer.ctx.clearRect(0,0, selected_layer.c.width,selected_layer.c.height);
				selected_layer.ctx.drawImage(m.mediator.live_transform, 0,0);
				m.mediator.live_transform_ctx.clearRect(-c_x,-c_y, w,h);
				//mask
				if(m.config.mask_link == true && selected_layer.mask_enabled == true){
					selected_layer.mask_ctx.clearRect(0,0, selected_layer.mask.width,selected_layer.mask.height);
					m.mediator.live_transform_ctx.drawImage(m.move_area_mask.c, -c_x,-c_y, w,h);
					selected_layer.mask_ctx.drawImage(m.mediator.live_transform, 0,0);
				}
			}
			//mask
			if(m.target == "mask"){
				m.mediator.live_transform_ctx.drawImage(m.move_area_mask.c, -c_x,-c_y, w,h);
				selected_layer.mask_ctx.clearRect(0,0, selected_layer.mask.width,selected_layer.mask.height);
				selected_layer.mask_ctx.drawImage(m.mediator.live_transform, 0,0);
			}
		}
		//

		//reset
		m.mediator.live_transform_ctx.rotate(-angle);
		m.mediator.live_transform_ctx.translate(-m.move_offsetX,-m.move_offsetY);
		
		//
		selected_layer.updateView();
		stackLiveView();
	},
	
	////UI
	updateUITransformControls : function(){
		var m = this;
		var x = Math.floor(drawingAreaWidth/2);
		var y = Math.floor(drawingAreaHeight/2);
		var w = drawingAreaWidth;
		var h = drawingAreaHeight;
		var angle = 0;
		//shows proper dimensions in UI move config menu
		//when out of scope of current move session
		if( m.session_docVer >= history_keeper.docVer || m.opid != history_keeper.opid ){
			if(selection_module.selection_active == true){
				var boundingBox = selection_module.getBoundingBox();
				x = boundingBox[0] + Math.floor(boundingBox[2]/2);
				y = boundingBox[1] + Math.floor(boundingBox[3]/2);
				w = boundingBox[2];
				h = boundingBox[3];
			}
		//
		}else{
			x = m.move_offsetX;
			y = m.move_offsetY;
			w = m.transform.w;
			h = m.transform.h;
			angle = m.transform.angle;
		}
		UI.mt_transform_box.style.left = ((x+(w%2)/2)/drawingAreaWidth*100).toFixed(5)+"%";
		UI.mt_transform_box.style.top = ((y+(h%2)/2)/drawingAreaHeight*100).toFixed(5)+"%";
		UI.mt_transform_box.style.width = (w/drawingAreaWidth*100).toFixed(5)+"%";
		UI.mt_transform_box.style.height = (h/drawingAreaHeight*100).toFixed(5)+"%";
		UI.mt_transform_box.style.transform = "translate(-50%,-50%) rotate("+(angle*180/Math.PI).toFixed(5)+"deg)";
	},
	
	updateUIConfigMenu : function(x,y){
		var m = this;
		if(x != null && y != null){
		//quick update within current move session based on given parameters
			UI.mt_area_pos_x.value = x;
			UI.mt_area_pos_y.value = y;
			UI.mt_area_w.value = m.transform.w;
			UI.mt_area_h.value = m.transform.h;
			return;
		}
		//shows proper dimensions in UI move config menu
		//when out of scope of current move session
		if( m.session_docVer >= history_keeper.docVer || m.opid != history_keeper.opid ){
			if(selection_module.selection_active == true){
				var boundingBox = selection_module.getBoundingBox();
				UI.mt_area_pos_x.value = Math.floor( boundingBox[0] + boundingBox[2] / 2 );
				UI.mt_area_pos_y.value = Math.floor( boundingBox[1] + boundingBox[3] / 2 );
				UI.mt_area_w.value = boundingBox[2];
				UI.mt_area_h.value = boundingBox[3];
			}else{
				UI.mt_area_pos_x.value = Math.floor(drawingAreaWidth/2);
				UI.mt_area_pos_y.value = Math.floor(drawingAreaHeight/2);
				UI.mt_area_w.value = drawingAreaWidth;
				UI.mt_area_h.value = drawingAreaHeight;
			}
			UI.mt_area_angle.value = 0.00;
		//
		}else{
		//updating within current move session
			UI.mt_area_pos_x.value = m.move_offsetX;
			UI.mt_area_pos_y.value = m.move_offsetY;
			UI.mt_area_w.value = m.transform.w;
			UI.mt_area_h.value = m.transform.h;
			UI.mt_area_angle.value = (m.transform.angle*180/Math.PI).toFixed(2);
		}
	},
	
	//// clipboard actions
	
	parseClipboardDataPaste : function(data){
		var m = this;
		if(data == null){
			m.clipboard.occupied = false;
		}
		
		if(data == null || (m.clipboard.occupied && m.clipboard.data == data) ){
			//console.log("the same");
		}else{
			//console.log("not same");
			m.clipboard.data = data;
			m.clipboard.occupied = true;
			m.clipboard.buffer.put(m.clipboard.img);
		}
		
	},
	
	pasteImage : function(){
		//console.log("pasting image");
		
		var m = this;
		var img = m.clipboard.buffer.c;
		
		if(m.prepareBuffers(img) == true){
			history_keeper.store("moveModule",current_tool,toolset_mode,selected_layer_i,m.store_components);
			m.opid = history_keeper.opid;
			
		}else{
			return;
		}
		m.moveContent();
		
		m.moveSelection();
		
		m.updateUIConfigMenu();
		m.updateUITransformControls();
		
		selected_layer.updateView();
		stackLiveView();
	},
	
	cutImage : async function(){

		//console.log("cutting image");
		
		var m = this;
		
		solidifySpree();
		
		m.putSelectedContent();
		
		m.clipboard.buffer.put(m.selected_content_buffer.c);
		
		//write to clipboard if available
		if(typeof(ClipboardItem) != "undefined"){
			
			try {
				const imgURL = m.selected_content_buffer.c.toDataURL();
				const data = await fetch(imgURL);
				const blob = await data.blob();

				await navigator.clipboard.write([
				  new ClipboardItem({
					[blob.type]: blob
				  })
				]);
				m.clipboard.occupied = true;
				m.clipboard.data = imgURL;
				//console.log('Fetched image copied.');
			} catch(err) {
				console.error(err.name, err.message);
				//backup plan to just null clipboard
				navigator.clipboard.writeText("");
				m.clipboard.occupied = false;
				m.clipboard.data = null;
			}
		}else{
			navigator.clipboard.writeText("");
			m.clipboard.occupied = false;
			m.clipboard.data = null;
		}
		
		//clear the area
		if(selection_module.selection_active == false){
		//
			if(selected_layer.target == "layer"){
				history_keeper.store("layer",current_tool,toolset_mode,selected_layer_i);
			}else if(selected_layer.target == "mask"){
				history_keeper.store("mask",current_tool,toolset_mode,selected_layer_i);
			}
			selected_layer.clearTargetContent();
		}else{
		//
			if(selected_layer.target == "layer"){
				history_keeper.store("layer",current_tool,toolset_mode,selected_layer_i);
				selection_module.deleteSelectedArea(selected_layer.ctx);
			}else if(selected_layer.target == "mask"){
				history_keeper.store("mask",current_tool,toolset_mode,selected_layer_i);
				selection_module.deleteSelectedArea(selected_layer.mask_ctx);
			}
		}
		selected_layer.updateView();
		stackLiveView();
	},
	
	copyImage : async function(){
	
		//console.log("copying image");
		
		var m = this;
		
		solidifySpree();
		
		m.putSelectedContent();
		
		m.clipboard.buffer.put(m.selected_content_buffer.c);

		//write to clipboard if available
		if(typeof(ClipboardItem) != "undefined"){
			
			try {
				const imgURL = m.selected_content_buffer.c.toDataURL();
				const data = await fetch(imgURL);
				const blob = await data.blob();

				await navigator.clipboard.write([
				  new ClipboardItem({
					[blob.type]: blob
				  })
				]);
				m.clipboard.occupied = true;
				m.clipboard.data = imgURL;
				//console.log('Fetched image copied.');
			} catch(err) {
				console.error(err.name, err.message);
				//backup plan to just null clipboard
				navigator.clipboard.writeText("");
				m.clipboard.occupied = false;
				m.clipboard.data = null;
			}
		}else{
			navigator.clipboard.writeText("");
			m.clipboard.occupied = false;
			m.clipboard.data = null;
		}

	},
	
	importImage : function(img){
		var m = this;
		
		//console.log("importing image");
		
		var m = this;
		solidifySpree();
		if(m.prepareBuffers(img) == true){
			
			history_keeper.store("moveModule",current_tool,toolset_mode,selected_layer_i,m.store_components);
			m.opid = history_keeper.opid;
			
		}else{
			return;
		}
		m.moveContent();
		
		m.moveSelection();
		
		m.updateUIConfigMenu();
		m.updateUITransformControls();
		
		selected_layer.updateView();
		stackLiveView();
	},
	
	exportSelectedContent : function(){
		var m = this;
		m.putSelectedContentView();
		return m.selected_content_buffer.c.toDataURL();
	},
	
	putSelectedContentView : function(){
		var m = this;
		var src_c = null;
		
		if(selected_layer.target == "layer"){
			src_c = selected_layer.c;
		}else if(selected_layer.target == "mask" && selected_layer.mask != null){
			src_c = selected_layer.mask;
		}
		
		if(selection_module.selection_active == true){
			var boundingBox = selection_module.getBoundingBox();
			m.selected_content_buffer.put(src_c, boundingBox[0],boundingBox[1],boundingBox[2],boundingBox[3]);
			
			m.selected_content_buffer.setComposite("destination-in");
			m.selected_content_buffer.stack(selection_module.selection, boundingBox[0],boundingBox[1],boundingBox[2],boundingBox[3]);
			m.selected_content_buffer.resetComposite();
		}else{
			var boundingBox = [0,0, src_c.width,src_c.height];
			m.selected_content_buffer.put(src_c, boundingBox[0],boundingBox[1],boundingBox[2],boundingBox[3]);
		
		}
		
	},
	
	putSelectedContent : function(){
		var m = this;
		var src_c = null;
		
		if(selected_layer.target == "layer"){
		//difference between view and this version
			src_c = selected_layer.c;
		}else if(selected_layer.target == "mask" && selected_layer.mask != null){
			src_c = selected_layer.mask;
		}
		
		if(selection_module.selection_active == true){
			var boundingBox = selection_module.getBoundingBox();
			m.selected_content_buffer.put(src_c, boundingBox[0],boundingBox[1],boundingBox[2],boundingBox[3]);
			
			m.selected_content_buffer.setComposite("destination-in");
			m.selected_content_buffer.stack(selection_module.selection, boundingBox[0],boundingBox[1],boundingBox[2],boundingBox[3]);
			m.selected_content_buffer.resetComposite();
		}else{
			var boundingBox = [0,0, src_c.width,src_c.height];
			m.selected_content_buffer.put(src_c, boundingBox[0],boundingBox[1],boundingBox[2],boundingBox[3]);
		
		}
	}
	

}

var move_module = new moveModule();

//moveModule binds

UI.mt_transform_box.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	move_module.mouseIsDown = true;
	checkToolsetMode();
	move_module.actionStart(e,"move");
	
	showUIElement(UI.mt_action_screen);
});
UI.mt_transform_box.addEventListener("touchmove", function(e){e.preventDefault();},true);

UI.mt_action_screen.addEventListener("pointermove", function(e){
	e.stopPropagation();
	if(move_module.mouseIsDown == true){
		move_module.actionDo(e);
	}
});

UI.mt_action_screen.addEventListener("pointerup", function(e){
	e.stopPropagation();
	move_module.mouseIsDown = false;
	hideUIElement(UI.mt_action_screen);
	move_module.actionEnd(e);
});
//
UI.mt_rotate_handle.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	move_module.mouseIsDown = true;
	checkToolsetMode();
	move_module.actionStart(e,"rotate");
	
	showUIElement(UI.mt_action_screen);
});
//
UI.mt_dpoint_1.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	move_module.mouseIsDown = true;
	checkToolsetMode();
	move_module.actionStart(e,"size",[-1,-1]);
	
	showUIElement(UI.mt_action_screen);
});
UI.mt_dpoint_2.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	move_module.mouseIsDown = true;
	checkToolsetMode();
	move_module.actionStart(e,"size",[0,-1]);
	
	showUIElement(UI.mt_action_screen);
});
UI.mt_dpoint_3.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	move_module.mouseIsDown = true;
	checkToolsetMode();
	move_module.actionStart(e,"size",[1,-1]);
	
	showUIElement(UI.mt_action_screen);
});
UI.mt_dpoint_4.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	move_module.mouseIsDown = true;
	checkToolsetMode();
	move_module.actionStart(e,"size",[-1,0]);
	
	showUIElement(UI.mt_action_screen);
});
UI.mt_dpoint_5.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	move_module.mouseIsDown = true;
	checkToolsetMode();
	move_module.actionStart(e,"size",[1,0]);
	
	showUIElement(UI.mt_action_screen);
});
UI.mt_dpoint_6.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	move_module.mouseIsDown = true;
	checkToolsetMode();
	move_module.actionStart(e,"size",[-1,1]);
	
	showUIElement(UI.mt_action_screen);
});
UI.mt_dpoint_7.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	move_module.mouseIsDown = true;
	checkToolsetMode();
	move_module.actionStart(e,"size",[0,1]);
	
	showUIElement(UI.mt_action_screen);
});
UI.mt_dpoint_8.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	move_module.mouseIsDown = true;
	checkToolsetMode();
	move_module.actionStart(e,"size",[1,1]);
	
	showUIElement(UI.mt_action_screen);
});
//





//-----------------------------------Move Module structures END

//-----------------------------------Selection Structures
function selectionModule(){
	var sm = this;
	
	sm.buff = new canvasBuffer();
	sm.buff_view = new canvasBuffer();
	
	sm.selection_active = false;
	sm.selectionPixelData = null;//used for quick access to pixel data lookup
	sm.new_selection = false;//flag to check for click deselect
	
	sm.drag_active = false;
	sm.drag_originX = 0;
	sm.drag_originY = 0;
	sm.boundingBox = [0,0,0,0];
	
	//multi-purpose can use to store movement offsets when needed
	sm.move_offsetX = 0;
	sm.move_offsetY = 0;
	
	sm.nudge_active = false;
	
	//for tracking of modes activated by modifier keys before action starts
	//this way when hk.getToolModState is requested during action - 
	//can compare to m.mode_pre_action and see if mode was activated during action
	sm.mode_pre_action = null;//[false,false,false];//for now 2 modes/mod keys
	//to store current active modes, defined as a property for simpler
	//passthrough between action functions
	//requested with hk.getToolModState in actionDo
	sm.mode = null;//[false,false,false];
	//note: mode = [unused, subtract, add]
	
	//selection map / actual selection
	sm.selection = document.createElement("canvas");
	sm.selection_ctx = sm.selection.getContext("2d");
	sm.selection.width = drawingAreaWidth;
	sm.selection.height = drawingAreaHeight;
	sm.selection_ctx.imageSmoothingEnabled = false;
	
	
	//used for copying selection to toggle selection back n forth
	sm.selection_toggle = document.createElement("canvas");
	sm.selection_toggle_ctx = sm.selection_toggle.getContext("2d");
	sm.selection_toggle.width = sm.selection.width;
	sm.selection_toggle.height = sm.selection.height;
	sm.selection_toggle_ctx.imageSmoothingEnabled = false;
	
	//outline of selection
	sm.selection_view = document.getElementById("selectionView");
	sm.selection_view_ctx = sm.selection_view.getContext("2d");
	sm.selection_view.width = c_view.offsetWidth;
	sm.selection_view.height = c_view.offsetHeight;
	sm.selection_view_ctx.imageSmoothingEnabled = false;
	sm.selection_view_ctx.lineWidth = "1";
	sm.selection_view_ctx.strokeStyle = "red";
	
	//for imprinting selection
	//and then using it for making selection outline in selection_view
	sm.selection_view_mediator = document.createElement("canvas");
	sm.selection_view_mediator_ctx = sm.selection_view_mediator.getContext("2d");
	sm.selection_view_mediator.width = c_view.offsetWidth;
	sm.selection_view_mediator.height = c_view.offsetHeight;
	sm.selection_view_mediator_ctx.imageSmoothingEnabled = false;
	
	//dynamic selection, like animation of box selection being drawn
	sm.dynamic_view = document.getElementById("selectionDynamicView");
	sm.dynamic_view.width = c_view.offsetWidth;
	sm.dynamic_view.height = c_view.offsetHeight;
	sm.dynamic_view_ctx = sm.dynamic_view.getContext("2d");
	sm.dynamic_view_ctx.imageSmoothingEnabled = false;
	sm.dynamic_view_ctx.fillStyle = "red";
	sm.dynamic_view_ctx.strokeStyle = "red";
	
	//make a checkerboard
	sm.checkerboard = document.createElement("canvas");
	sm.checkerboard_ctx = sm.checkerboard.getContext("2d");
	sm.checkerboard.width = sm.dynamic_view.width;
	sm.checkerboard.height = sm.dynamic_view.height;
	
	//support canvas for lasso or any other selection that needs
	//a mediation canvas before drawing to selection
	//lasso needs it to remove anti-aliasing
	sm.selection_mediator = document.createElement("canvas");
	sm.selection_mediator_ctx = sm.selection_mediator.getContext("2d");
	sm.selection_mediator.width = sm.selection.width;
	sm.selection_mediator.height = sm.selection.height;
	sm.selection_mediator_ctx.imageSmoothingEnabled = false;
	sm.selection_mediator_ctx.lineWidth = "1";
	sm.selection_mediator_ctx.fillStyle = "red";
	sm.selection_mediator_ctx.strokeStyle = "red";
	
	
	sm.outline_opacity = 180;
	sm.outline_dotted_pattern = [[0,0,0],[255,255,255]];
	
	
	sm.selectArea_originX = 0;
	sm.selectArea_originY = 0;
	
	
	sm.opid = 0;
	
	//AutoSelect config
	sm.config = {};
	sm.config.contiguous = true;//contiguous
	sm.config.all_layers = true;
	sm.config.rgb_margin = 25;//0-255 color variance
	sm.config.tone_margin = 35;//0-255 luminosity variance
	sm.config.selectArea_aspect_lock = false;
	sm.config.selectArea_aspect_ratio = 1.0;
}

selectionModule.prototype = {
	
	loadConfigAutoSelect : function(config){
		var sm = this;
		for(let config_name in config){
			sm.config[config_name] = config[config_name];
		}
	},
	
	setConfig : function(option,val){
	//generic internal for any config
		this.config[option] = val;
	},
	
	setConfigAutoSelect : function(option,val){
	//same as generic but does config notification
		this.config[option] = val;
		//
		uc_keeper.notifyGenUpdateNeeded("generalConfig","ToolOptionsAutoSelect");
	},
	
	updateUISelectionConfig : function(){
		var sm = this;
		UI.sm_all_layers.checked = sm.config.all_layers;
		UI.sm_contiguous.checked = sm.config.contiguous;
		UI.sm_rgb_margin.value = sm.config.rgb_margin;
		UI.sm_tone_margin.value = sm.config.tone_margin;
	},
	getUIInfo : function(){
		var sm = this;
		sm.config.all_layers = UI.sm_all_layers.checked;
		sm.config.contiguous = UI.sm_contiguous.checked;
		sm.config.rgb_margin = parseInt(UI.sm_rgb_margin.value);
		sm.config.tone_margin = parseInt(UI.sm_tone_margin.value);
	},
	
	getPixelAlpha : function(x,y){
	//a little misnamed, it returns pixel availability at coordinate
	//from standpoint of selection
		var sm = this;
		if(sm.selection_active == true){
			return sm.selectionPixelData[(y*sm.selection.width+x)*4 + 3];
		}else{
			return 255;
		}
	},
	
	getPixelDataAtIndex : function(i){
	//a little misnamed, it returns pixel availability at index
	//from standpoint of selection
		var sm = this;
		if(sm.selection_active == true){
			return sm.selectionPixelData[i];
		}else{
			return 255;
		}
	},
	
	resetCheckerboard(size){
		var sm = this;
		sm.checkerboard.width = sm.dynamic_view.width;
		sm.checkerboard.height = sm.dynamic_view.height;
		chamber_buffer[1].setSize(size*2,size*2);
		chamber_buffer[1].ctx.fillRect(0,0,size,size);
		chamber_buffer[1].ctx.fillRect(size,size,size,size);
		chamber_buffer[1].ctx.fillStyle = "white";
		chamber_buffer[1].ctx.fillRect(size,0,size,size);
		chamber_buffer[1].ctx.fillRect(0,size,size,size);
		chamber_buffer[1].ctx.fillStyle = "black";
		sm.checkerboard_ctx.fillStyle = sm.checkerboard_ctx.createPattern(chamber_buffer[1].c,"repeat");
		sm.checkerboard_ctx.fillRect(0,0, sm.checkerboard.width,sm.checkerboard.height);
	},
	
	clearSelectionView : function(){
		var sm = this;
		sm.selection_view_ctx.clearRect(0,0, sm.selection_view.width,sm.selection_view.height);
	},
	
	detectSelection : function(){
	//loops over every pixel in selection until it finds non-transparent pixel
		var sm = this;
		
		//another version similar to canvasIsEmpty(ctx);
		const sData = sm.selection_ctx.getImageData(0, 0, sm.selection.width, sm.selection.height).data;
		var found = false;
		for(let i=3,len=sData.length;i<len;i+=4){
			if(sData[i] > 0){
				found = true;
				break;
			}
		}
		
		//this approach seem to be slower
		//const pixelBuffer = new Uint32Array( sData.buffer );
		//const found = pixelBuffer.some(color => color !== 0);
		if(found == true){
			sm.selectionPixelData = sData;
		}
		sm.selection_active = found;
		
		return found;
	},
	
	//
	makeSelectionOutline : function(){
	//pixel scan approach
		var sm = this;
		
		if(sm.selection_active == false){
			sm.selection_view_ctx.clearRect(0,0,sm.selection_view.width,sm.selection_view.height);
			return;
		}
		
		var dotted_pattern = sm.outline_dotted_pattern;
		var outline_opacity = sm.outline_opacity;
		
		const s_view_mediator_height = sm.selection_view_mediator.height;
		const s_view_mediator_width = sm.selection_view_mediator.width;
		
		//clear current selection view
		sm.selection_view_mediator_ctx.clearRect(0,0, s_view_mediator_width,s_view_mediator_height);
		imprintCanvasView(sm.selection,sm.selection_view_mediator,sm.selection_view_mediator_ctx);
		
		var sData = sm.selection_view_mediator_ctx.getImageData(0,0,s_view_mediator_width,s_view_mediator_height);
		var svData = sm.selection_view_ctx.createImageData(sm.selection_view.width,sm.selection_view.height);
		
		//referencing optimization
		var sData_data = sData.data;
		var svData_data = svData.data;

		
		var looking_for = 1;
		var target_i = 0;
		var dp_alternator = 0;
		//Walk across
		//vertical
		var i = 0;
		var j = 0;
		
		for(i=0;i<s_view_mediator_height;++i){
			
			looking_for = 1;
			dp_alternator = 1-dp_alternator;
			//horizontal
			for(j=0;j<s_view_mediator_width;++j){
				
				target_i =  (i*s_view_mediator_width*4) + (j*4);
				//seeking opaque
				if(looking_for == 1 && sData_data[target_i+3] > 0){
					
					looking_for = 0;
					
					svData_data[target_i] = dotted_pattern[dp_alternator][0];
					svData_data[target_i+1] = dotted_pattern[dp_alternator][1];
					svData_data[target_i+2] = dotted_pattern[dp_alternator][2];
					
					svData_data[target_i+3] = outline_opacity;
					
					
				//seeking transparent
				}else if(looking_for == 0 && sData_data[target_i+3] == 0){
					
					looking_for = 1;
					
					svData_data[target_i-4] = dotted_pattern[dp_alternator][0];
					svData_data[target_i-3] = dotted_pattern[dp_alternator][1];
					svData_data[target_i-2] = dotted_pattern[dp_alternator][2];
					
					svData_data[target_i-1] = outline_opacity;
					
				}
				
			}
			
			//deal with right edge
			if(looking_for == 0){
				target_i = (i*s_view_mediator_width*4) + ((j-1)*4);
				
				svData_data[target_i] = dotted_pattern[dp_alternator][0];
				svData_data[target_i+1] = dotted_pattern[dp_alternator][1];
				svData_data[target_i+2] = dotted_pattern[dp_alternator][2];
					
				svData_data[target_i+3] = outline_opacity;
				
			}
			
		}
		
		
		
		looking_for = 1;
		target_i = 0;
		dp_alternator = 0;
		//Walk vertically
		//horizontal
		for(i=0;i<s_view_mediator_width;++i){
			
			looking_for = 1;
			dp_alternator = 1-dp_alternator;
			//vertical
			for(j=0;j<s_view_mediator_height;++j){
				
				target_i =  (j*s_view_mediator_width*4) + (i*4);
				//seeking opaque
				if(looking_for == 1 && sData_data[target_i+3] > 0){
					
					looking_for = 0;
					
					svData_data[target_i] = dotted_pattern[dp_alternator][0];
					svData_data[target_i+1] = dotted_pattern[dp_alternator][1];
					svData_data[target_i+2] = dotted_pattern[dp_alternator][2];
					
					svData_data[target_i+3] = outline_opacity;
					
					
				//seeking transparent
				}else if(looking_for == 0 && sData_data[target_i+3] == 0){
					
					looking_for = 1;
					svData_data[target_i-s_view_mediator_width*4] = dotted_pattern[dp_alternator][0];
					svData_data[target_i-s_view_mediator_width*4+1] = dotted_pattern[dp_alternator][1];
					svData_data[target_i-s_view_mediator_width*4+2] = dotted_pattern[dp_alternator][2];
					
					svData_data[target_i-s_view_mediator_width*4+3] = outline_opacity;
					
				}
				
			}
			
			//deal with bottom edge
			if(looking_for == 0){
				target_i =  ((j-1)*s_view_mediator_width*4) + (i*4);
				
				svData_data[target_i] = dotted_pattern[dp_alternator][0];
				svData_data[target_i+1] = dotted_pattern[dp_alternator][1];
				svData_data[target_i+2] = dotted_pattern[dp_alternator][2];
					
				svData_data[target_i+3] = outline_opacity;
				
			}
			
		}
	
		sm.selection_view_ctx.putImageData(svData,0,0);
	},
	
	
	selectAll : function(){
		var sm = this;
		sm.selection_ctx.fillRect(0,0,sm.selection.width,sm.selection.height);
		sm.selection_active = true;
		
		sm.detectSelection();//needed for pixel data
		sm.makeSelectionOutline();
	},
	
	selectContent : function(){
		var sm = this;
		
		sm.clearSelection();
		if(selected_layer.target == "layer"){
			var layer;
			for(let i=0;i<selected_layer_multi.length;i++){
				layer = gf.contents[ selected_layer_multi[i] ];
				sm.selection_ctx.drawImage(layer.view, 0,0, layer.view.width, layer.view.height);
			}
		}else if(selected_layer.target == "mask"){
			sm.selection_ctx.drawImage(selected_layer.mask, 0,0, selected_layer.mask.width, selected_layer.mask.height);
		}
		
		makeCanvasContentOpaque(sm.selection, sm.selection_ctx);
		sm.detectSelection();
		sm.makeSelectionOutline();
	},
	
	clearSelection : function(){
	//internal clear of selection and view
		var sm = this;
		sm.selection_ctx.clearRect(0,0,sm.selection.width,sm.selection.height);
		sm.selection_view_ctx.clearRect(0,0,sm.selection_view.width,sm.selection_view.height);
	},
	
	clearSelectionView : function(){
		//clears just the selection view
		var sm = this;
		sm.selection_view_ctx.clearRect(0,0,sm.selection_view.width,sm.selection_view.height);
	},
	
	deselectAll : function(){
		var sm = this;
		
		sm.clearSelection();
		sm.selection_active = false;
		
	},
	
	toggleSelection : function(){
		var sm = this;
		
		if(sm.selection_active == true){
			sm.selection_toggle_ctx.clearRect(0,0, sm.selection_toggle.width,sm.selection_toggle.height);
			sm.selection_toggle_ctx.drawImage(sm.selection,0,0);
			sm.clearSelection();
			sm.selection_active = false;
		}else{
			sm.selection_ctx.drawImage(sm.selection_toggle,0,0);
			sm.detectSelection();
			sm.makeSelectionOutline();
		}
	},
	
	invertSelection : function(){
		var sm = this;
		
		sm.selection_ctx.globalCompositeOperation = "xor";
		sm.selection_ctx.fillRect(0,0, sm.selection.width,sm.selection.height);
		sm.selection_ctx.globalCompositeOperation = "source-over";
		sm.detectSelection();
		sm.makeSelectionOutline();
	},
	
	selectionFromLayer : function(layer_i){
		var sm = this;
		
		sm.clearSelection();
		let target_layer = gf.getAtIndex(layer_i);
		
		sm.selection_ctx.globalAlpha = target_layer.opacity;
		sm.selection_ctx.drawImage(target_layer.view, 0,0);
		sm.selection_ctx.globalAlpha = 1;
		
		sm.detectSelection();
		sm.makeSelectionOutline();
	},
	
	selectionFromLayerAdd : function(layer_i){
		var sm = this;
		
		sm.selection_ctx.drawImage(gf.getAtIndex(layer_i).view, 0,0);
		sm.detectSelection();
		sm.makeSelectionOutline();
	},
	
	selectionFromLayerSubtract : function(layer_i){
		var sm = this;
		
		sm.selection_ctx.globalCompositeOperation = "destination-out";
		sm.selection_ctx.drawImage(gf.getAtIndex(layer_i).view, 0,0);
		sm.selection_ctx.globalCompositeOperation = "source-over";
		sm.detectSelection();
		sm.makeSelectionOutline();
	},
	
	selectionFromSpree : function(){
	//turns spree into a selection
		var sm = this;
		sm.clearSelection();
		sm.selection_ctx.drawImage(spree.view, 0,0);
		sm.detectSelection();
		sm.makeSelectionOutline();
	},
	
	dragStart : function(e){
		var sm = this;
		
		var c_rect = live_view.getBoundingClientRect();
		//note: floor seems to work more precise
		sm.drag_originX = Math.floor((e.x-c_rect.x)/canvas_view.current_zoom);
		sm.drag_originY = Math.floor((e.y-c_rect.y)/canvas_view.current_zoom);
		sm.drag_active = true;
		
		sm.buff_view.put(sm.selection_view);
		
		if(current_tool == "select_tool"){
			sm.boundingBox = sm.getBoundingBox();
		}
	},
	
	dragDo : function(e){
		var sm = this;
		
		var c_rect = live_view.getBoundingClientRect();
		//note: floor seems to work more precise
		var x = Math.floor((e.x-c_rect.x)/canvas_view.current_zoom);
		var y = Math.floor((e.y-c_rect.y)/canvas_view.current_zoom);
		
		var offsetX = x-sm.drag_originX;
		var offsetY = y-sm.drag_originY;
		
		//constrain selection movement within canvas
		if(current_tool == "select_tool"){
			offsetX = Math.min(drawingAreaWidth-(sm.boundingBox[0]+sm.boundingBox[2]),Math.max(-sm.boundingBox[0],offsetX));
			offsetY = Math.min(drawingAreaHeight-(sm.boundingBox[1]+sm.boundingBox[3]),Math.max(-sm.boundingBox[1],offsetY));
		}
		
		//translate to selection view
		offsetX = Math.round(offsetX * canvas_view.current_zoom);
		offsetY = Math.round(offsetY * canvas_view.current_zoom);
		
		sm.buff_view.output(sm.selection_view_ctx,sm.selection_view,offsetX,offsetY);
	},
	
	dragEnd : function(e){
		var sm = this;
		
		var c_rect = live_view.getBoundingClientRect();
		//note: floor seems to work more precise
		var x = Math.floor((e.x-c_rect.x)/canvas_view.current_zoom);
		var y = Math.floor((e.y-c_rect.y)/canvas_view.current_zoom);
		
		sm.buff.put(sm.selection);
		
		var offsetX = x-sm.drag_originX;
		var offsetY = y-sm.drag_originY;
		
		//constrain selection movement within canvas
		if(current_tool == "select_tool"){
			offsetX = Math.min(drawingAreaWidth-(sm.boundingBox[0]+sm.boundingBox[2]),Math.max(-sm.boundingBox[0],offsetX));
			offsetY = Math.min(drawingAreaHeight-(sm.boundingBox[1]+sm.boundingBox[3]),Math.max(-sm.boundingBox[1],offsetY));
		}
		
		sm.buff.output(sm.selection_ctx,sm.selection,offsetX,offsetY);
		sm.detectSelection();
		sm.makeSelectionOutline();
	
	},
	
	//nudges content in direction with a multiplier
	nudgeDo : function(d,mult){
		var sm = this;
		var dx = 0;
		var dy = 0;
		
		if(sm.nudge_active == false){
			sm.buff_view.put(sm.selection_view);
			sm.nudge_active = true;
		}
		
		if(sm.opid < history_keeper.opid){
			history_keeper.store("selection",current_tool,toolset_mode,selected_layer_i);
			sm.opid = history_keeper.opid;
		}
		
		switch(d){
			//LEFT
			case 1:
				dx =-1;
			break;
			//
			//UP
			case 2:
				dy = -1;
			break;
			//
			//RIGHT
			case 3:
				dx = 1;
			break;
			//
			//DOWN
			case 4:
				dy = 1;
			break;
			//
		}
		if(mult != null){
			dx = dx*mult;
			dy = dy*mult;
		}
		
		sm.move_offsetX += dx;
		sm.move_offsetY += dy;
		
		
		sm.buff_view.output(sm.selection_view_ctx,sm.selection_view,
			(sm.move_offsetX*canvas_view.current_zoom),
			(sm.move_offsetY*canvas_view.current_zoom));

	},
	
	nudgeEnd : function(){
		var sm = this;
		sm.buff.put(sm.selection);
		sm.buff.output(sm.selection_ctx,sm.selection,sm.move_offsetX,sm.move_offsetY);
		sm.move_offsetX = 0;
		sm.move_offsetY = 0;
		sm.nudge_active = false;
		sm.detectSelection();
		sm.makeSelectionOutline();
	},
	
	///// selection action manager functions
	actionStart : function(e){
		var sm = this;
		
		var c_rect = live_view.getBoundingClientRect();
		//note: floor seems to work more precise
		var x = Math.floor((e.x-c_rect.x)/canvas_view.current_zoom);
		var y = Math.floor((e.y-c_rect.y)/canvas_view.current_zoom);
		
		let mod_state = hk.getToolModState(current_tool);
		sm.mode = mod_state;
		sm.mode_pre_action = mod_state;
		
		//check mouse down on existing selection
		if(sm.selection_active == true){//small optimization
			
			//small optimization
			if(sm.mode[1] == false && sm.mode[2] == false){
			//no add, no subtract
				if( x >= 0 && x <= sm.selection.width &&
					y >= 0 && y <= sm.selection.height &&
					(sm.selectionPixelData[(y*sm.selection.width + x)*4 + 3] > 0)){
					//action is drag selection unless add or subtract mode
					sm.drag_active = true;
				}else{
					
					if(current_tool == "lasso_tool" || current_tool == "select_tool"){
					//history store is moved from mouse_down to mouse_up for these tools
						sm.clearSelectionView();
					}else{
						sm.deselectAll();
					}
					
					
				}
			}
		}
		
		///
		
		if(sm.drag_active){
			sm.dragStart(e);
		}else{
			
			switch(current_tool){
				case "lasso_tool":
					sm.lassoDrawStart(e);
				break;
				//
				case "select_tool":
					sm.selectAreaStart(e);
				break;
				//
				case "auto_select_tool":
					sm.autoSelectStart(e);
				break;
				//
			}
			
		}
		
	},
	
	actionDo : function(e){
		var sm = this;
		
		if(sm.drag_active){
			sm.dragDo(e);
		}else{
		
			switch(current_tool){
				case "lasso_tool":
					sm.lassoDrawDo(e);
				break;
				//
				case "select_tool":
					sm.selectAreaDo(e);
				break;
				//
				case "auto_select_tool":
					sm.autoSelectDo(e);
				break;
				//
			}
			
		}
	},
	
	actionEnd : function(e){
		var sm = this;
		
		if(sm.drag_active){
			sm.dragEnd(e);
			sm.drag_active = false;
		}else{
			
			switch(current_tool){
				case "lasso_tool":
					sm.lassoDrawEnd(e);
				break;
				//
				case "select_tool":
					sm.selectAreaEnd(e);
				break;
				//
				case "auto_select_tool":
					sm.autoSelectEnd(e);
				break;
				//
			}
			
		}
		sm.detectSelection();
		sm.makeSelectionOutline();
		
		//moved from actionStart to suit store at mouse_up
		//primarily for lasso tool and select tool arrow nudge
		sm.opid = history_keeper.opid;
		
	},
	/////////
	lassoDrawStart : function(e){
		var sm = this;
		
		var c_rect = live_view.getBoundingClientRect();

		var x = Math.round((e.x-c_rect.x)/canvas_view.current_zoom);
		var y = Math.round((e.y-c_rect.y)/canvas_view.current_zoom);
		
		sm.dynamic_view_ctx.beginPath();
		sm.selection_mediator_ctx.clearRect(0,0, sm.selection_mediator.width,sm.selection_mediator.height);
		sm.selection_mediator_ctx.beginPath();
		
		sm.dynamic_view_ctx.moveTo(e.x-c_view_rect_x, e.y-c_view_rect_y);
		sm.selection_mediator_ctx.moveTo(x,y);
	},
	
	lassoDrawDo : function(e){
		var sm = this;
		
		var c_rect = live_view.getBoundingClientRect();

		var x = Math.round((e.x-c_rect.x)/canvas_view.current_zoom);
		var y = Math.round((e.y-c_rect.y)/canvas_view.current_zoom);
		
		sm.dynamic_view_ctx.lineTo(e.x-c_view_rect_x, e.y-c_view_rect_y);
		sm.dynamic_view_ctx.stroke();
		sm.selection_mediator_ctx.lineTo(x,y);
		
		//apply checkerboard
		sm.dynamic_view_ctx.globalCompositeOperation = "source-in";
		sm.dynamic_view_ctx.drawImage(sm.checkerboard,0,0);
		sm.dynamic_view_ctx.globalCompositeOperation = "source-over";
	},
	
	lassoDrawEnd : function(e){
		var sm = this;
		
		sm.dynamic_view_ctx.clearRect(0,0,sm.dynamic_view.width,sm.dynamic_view.height);
		
		
		sm.selection_mediator_ctx.closePath();
		let selection_composite_mode = "source-over";
		if(sm.mode[2] == true){
		//subtract
			sm.selection_ctx.globalCompositeOperation = "destination-out";
			selection_composite_mode = "destination-out";
		}
		
		sm.selection_mediator_ctx.fill();
		//remove anti-aliasing
		makeCanvasContentOpaque(sm.selection_mediator,sm.selection_mediator_ctx);
		
		//draw to selection
		sm.selection_ctx.drawImage(sm.selection_mediator, 0,0);
		
		if(selection_composite_mode != "source-over"){
			//reset
			sm.selection_ctx.globalCompositeOperation = "source-over";
			selection_composite_mode = "source-over";
		}
		
		
		//lasso fill
		if(fill_module.getConfig("lasso_fill") == true){
		
			if(selected_layer.target == "layer"){
				
				if(sm.mode[2] == true){//subtract
					let composite_store = spree.view_ctx.globalCompositeOperation;
					spree.view_ctx.globalCompositeOperation = "destination-out";
					spree.view_ctx.drawImage(sm.selection_mediator,0,0);
					spree.view_ctx.globalCompositeOperation = composite_store;
				}else{
					//set color
					sm.selection_mediator_ctx.globalCompositeOperation = "source-atop";
					sm.selection_mediator_ctx.fillStyle = current_color;
					sm.selection_mediator_ctx.fillRect(0,0, sm.selection_mediator.width,sm.selection_mediator.height);
					sm.selection_mediator_ctx.globalCompositeOperation = "source-over";
					//
					spree.view_ctx.drawImage(sm.selection_mediator,0,0);
				}
				spree.update();
			}else if(selected_layer.target == "mask"){
				if(sm.mode[2] == true){//subtract
					let composite_store = selected_layer.mask_ctx.globalCompositeOperation;
					selected_layer.mask_ctx.globalCompositeOperation = "destination-out";
					selected_layer.mask_ctx.drawImage(sm.selection_mediator,0,0);
					selected_layer.mask_ctx.globalCompositeOperation = composite_store;
				}else{
					//set color white
					sm.selection_mediator_ctx.globalCompositeOperation = "source-atop";
					sm.selection_mediator_ctx.fillStyle = "white";
					sm.selection_mediator_ctx.fillRect(0,0, sm.selection_mediator.width,sm.selection_mediator.height);
					sm.selection_mediator_ctx.globalCompositeOperation = "source-over";
					//
					selected_layer.mask_ctx.drawImage(sm.selection_mediator,0,0);
				}
			}
			selected_layer.updateView();
			stackLiveView();
		}
		
	},
	
	selectAreaStart : function(e){
		var sm = this;
		
		var c_rect = live_view.getBoundingClientRect();
		var x = Math.round((e.x-c_rect.x)/canvas_view.current_zoom);
		var y = Math.round((e.y-c_rect.y)/canvas_view.current_zoom);
		
		if(sm.config.selectArea_aspect_lock == true){
		//bound to canvas
			x = Math.min(sm.selection.width, Math.max(0, x));
			y = Math.min(sm.selection.height, Math.max(0, y));
		}
		sm.selectArea_originX = x;
		sm.selectArea_originY = y;
	},
	
	selectAreaDo : function(e){
		var sm = this;
		
		var c_rect = live_view.getBoundingClientRect();
		var x = Math.round((e.x-c_rect.x)/canvas_view.current_zoom);
		var y = Math.round((e.y-c_rect.y)/canvas_view.current_zoom);
		
		var rect_x = Math.min(sm.selectArea_originX,x); 
		var rect_y = Math.min(sm.selectArea_originY,y);
		
		var rect_w = Math.max(sm.selectArea_originX,x) - rect_x;
		var rect_h = Math.max(sm.selectArea_originY,y) - rect_y;
		
		//aspect lock
		if(sm.config.selectArea_aspect_lock == true){
			var ratio = sm.config.selectArea_aspect_ratio;
			if(sm.config.selectArea_aspect_ratio >= 1){
				
				rect_h = rect_w / sm.config.selectArea_aspect_ratio;
				
				if(rect_y == y || (rect_x == x && rect_y == y)){
					rect_y = sm.selectArea_originY - rect_h;
				}
				
			}else{
				
				rect_w = rect_h * sm.config.selectArea_aspect_ratio;
				
				if(rect_x == x || (rect_x == x && rect_y == y)){
					rect_x = sm.selectArea_originX - rect_w;
				}
				
			}
			
			//bound height
			if(rect_y < 0){
				
				rect_w = (sm.selectArea_originY) * ratio;
				rect_y = 0;
				rect_h = sm.selectArea_originY;
				if(rect_x < sm.selectArea_originX){
					rect_x = sm.selectArea_originX - rect_w;
				}
				
			}else if(rect_y+rect_h > sm.selection.height){
				
				rect_w = (sm.selection.height-sm.selectArea_originY) * ratio;
				rect_y = sm.selectArea_originY;
				rect_h = sm.selection.height-sm.selectArea_originY;
				if(rect_x < sm.selectArea_originX){
					rect_x = sm.selectArea_originX - rect_w;
				}
				
			}
			//bound width
			if(rect_x < 0){
				
				rect_w = sm.selectArea_originX;
				rect_x = 0;
				rect_h = sm.selectArea_originX / ratio;
				if(rect_y < sm.selectArea_originY){
					rect_y = sm.selectArea_originY - rect_h;
				}
				
			}else if(rect_x+rect_w > sm.selection.width){
				
				rect_w = (sm.selection.width-sm.selectArea_originX);
				rect_x = sm.selectArea_originX;
				rect_h = (sm.selection.width-sm.selectArea_originX) / ratio;
				if(rect_y < sm.selectArea_originY){
					rect_y = sm.selectArea_originY - rect_h;
				}
				
			}
		}
		
		sm.dynamic_view_ctx.clearRect(0,0, sm.dynamic_view.width,sm.dynamic_view.height);
		
		//translate for dynamic view
		rect_x = Math.round(rect_x * canvas_view.current_zoom + c_rect.x - c_view_rect_x);
		rect_y = Math.round(rect_y * canvas_view.current_zoom + c_rect.y - c_view_rect_y);
		rect_w = Math.round(rect_w * canvas_view.current_zoom);
		rect_h = Math.round(rect_h * canvas_view.current_zoom);
		//workaround to get sharp line
		sm.dynamic_view_ctx.fillRect(rect_x,rect_y, rect_w,rect_h);
		if(rect_w > 2 && rect_h > 2){
			sm.dynamic_view_ctx.clearRect(rect_x+1,rect_y+1, rect_w-2,rect_h-2);
		}
		
		//apply checkerboard
		sm.dynamic_view_ctx.globalCompositeOperation = "source-in";
		sm.dynamic_view_ctx.drawImage(sm.checkerboard,0,0);
		sm.dynamic_view_ctx.globalCompositeOperation = "source-over";
	},
	
	selectAreaEnd : function(e){
		var sm = this;
		
		var c_rect = live_view.getBoundingClientRect();
		//note: floor seems to work more precise
		var x = Math.round((e.x-c_rect.x)/canvas_view.current_zoom);
		var y = Math.round((e.y-c_rect.y)/canvas_view.current_zoom);
		
		let selection_composite_mode = "source-over";
		if(sm.mode[2] == true){//subtract
			sm.selection_ctx.globalCompositeOperation = "destination-out";
			selection_composite_mode = "destination-out";
		}
		
		//fill here
		var rect_x = Math.min(sm.selectArea_originX,x); 
		var rect_y = Math.min(sm.selectArea_originY,y);
		var rect_w = Math.max(sm.selectArea_originX,x) - rect_x;
		var rect_h = Math.max(sm.selectArea_originY,y) - rect_y;
		
		//aspect lock
		if(sm.config.selectArea_aspect_lock == true){
			var ratio = sm.config.selectArea_aspect_ratio;
			if(sm.config.selectArea_aspect_ratio >= 1){
				
				rect_h = rect_w / sm.config.selectArea_aspect_ratio;
				
				if(rect_y == y || (rect_x == x && rect_y == y)){
					rect_y = sm.selectArea_originY - rect_h;
				}
				
			}else{
				
				rect_w = rect_h * sm.config.selectArea_aspect_ratio;
				
				if(rect_x == x || (rect_x == x && rect_y == y)){
					rect_x = sm.selectArea_originX - rect_w;
				}
				
			}
			
			//bound height
			if(rect_y < 0){
				
				rect_w = (sm.selectArea_originY) * ratio;
				rect_y = 0;
				rect_h = sm.selectArea_originY;
				if(rect_x < sm.selectArea_originX){
					rect_x = sm.selectArea_originX - rect_w;
				}
				
			}else if(rect_y+rect_h > sm.selection.height){
				
				rect_w = (sm.selection.height-sm.selectArea_originY) * ratio;
				rect_y = sm.selectArea_originY;
				rect_h = sm.selection.height-sm.selectArea_originY;
				if(rect_x < sm.selectArea_originX){
					rect_x = sm.selectArea_originX - rect_w;
				}
				
			}
			//bound width
			if(rect_x < 0){
				
				rect_w = sm.selectArea_originX;
				rect_x = 0;
				rect_h = sm.selectArea_originX / ratio;
				if(rect_y < sm.selectArea_originY){
					rect_y = sm.selectArea_originY - rect_h;
				}
				
			}else if(rect_x+rect_w > sm.selection.width){
				
				rect_w = (sm.selection.width-sm.selectArea_originX);
				rect_x = sm.selectArea_originX;
				rect_h = (sm.selection.width-sm.selectArea_originX) / ratio;
				if(rect_y < sm.selectArea_originY){
					rect_y = sm.selectArea_originY - rect_h;
				}
				
			}
		}
		
		//fill
		if(rect_w != 0 && rect_h != 0){
			sm.selection_ctx.fillRect(rect_x,rect_y, rect_w,rect_h);
		}
		
		if(selection_composite_mode != "source-over"){
			//reset
			sm.selection_ctx.globalCompositeOperation = "source-over";
			selection_composite_mode = "source-over";
		}
		
		sm.dynamic_view_ctx.clearRect(0,0, sm.dynamic_view.width,sm.dynamic_view.height);
	},
	
	autoSelectStart : function(e){
		var sm = this;
		
		return;
	},
	
	autoSelectDo : function(e){
		var sm = this;
		
		var arg_list;
		if(sm.config.all_layers){
			arg_list = [live_view,live_view_ctx, e];
		}else{
			arg_list = [selected_layer.view,selected_layer.view_ctx, e];
		}
		//
		if(sm.config.contiguous){
			sm.fillSelect(arg_list[0],arg_list[1],arg_list[2]);
		}else{
			sm.fillSelectOpen(arg_list[0],arg_list[1],arg_list[2]);
		}
		
		sm.detectSelection();
		sm.makeSelectionOutline();
		return;
	},
	
	autoSelectEnd : function(e){
		var sm = this;
		
		var arg_list;
		if(sm.config.all_layers){
			arg_list = [live_view,live_view_ctx, e];
		}else{
			arg_list = [selected_layer.view,selected_layer.view_ctx, e];
		}
		//
		if(sm.config.contiguous){
			sm.fillSelect(arg_list[0],arg_list[1],arg_list[2]);
		}else{
			sm.fillSelectOpen(arg_list[0],arg_list[1],arg_list[2]);
		}
		//
		sm.detectSelection();
		sm.makeSelectionOutline();
		return;
	},
	
	checkPixelSame : function(current, target){
		var sm = this;
		var same = false;
		var same_color = false;
		var same_alpha = false;
		var same_tone = false;
		//calculate lightness
		var lightness = 0;
		same_color = (Math.abs(current[0]-target[0])+Math.abs(current[1]-target[1])+Math.abs(current[2]-target[2]) ) <= sm.config.rgb_margin;
		same_alpha = (current[3]>0&&target[3]>0) || (current[3]==0&&target[3]==0);
		
		//small optimization to eliminate unneeded calculations
		if(same_color && same_alpha){
			lightness = Math.round( (Math.max(current[0],current[1],current[2]) + Math.min(current[0],current[1],current[2])) / 2);
			same_tone = Math.abs(lightness-target[4])<sm.config.tone_margin;
		}
		
		same = same_tone&&same_color&&same_alpha;
		return same;
	},
	
	//support for use with autoSelect, like a fill function but for selection
	//contiguous version
	fillSelect : function(c,ctx,e){
		var sm = this;
		
		var fill_val = 255;
		if(sm.mode[2] == true){//subtract
			fill_val = 0;
		}
		
		var c_rect = live_view.getBoundingClientRect();
		//note: floor seems to work more precise
		var x = Math.floor((e.x-c_rect.x)/canvas_view.current_zoom);
		var y = Math.floor((e.y-c_rect.y)/canvas_view.current_zoom);
		const width = c.width;
		const height = c.height;
		//width and height limits for indexing into array
		//(!) important: there is a difference between uses of width, height and index calculations and limits
		const w_limit = width-1;
		const h_limit = height-1;
		
		if(x<0 || x>w_limit || y<0 || y>h_limit)return;
		
		var i = (x+(y*width))*4;
		//map of filled/selected pixels in current selection, for coordinates
		var fill_map_data = ctx.createImageData(c.width,c.height).data;
		//starting points for horizontal walks of the fill
		//gets populated on the go
		var coords = [[x,y]];
		
		
		//canvas that gets sampled
		var area_data = ctx.getImageData(0,0, c.width,c.height).data;
		//canvas that gets filled
		var fill_area = sm.selection_ctx.getImageData(0,0, sm.selection.width,sm.selection.height);
		var fill_area_data = fill_area.data;
		var same = true;
		var same_next = false;
		//possible next pixel
		var p = [0,0,0,0];
		var p_i = 0;
		
		var d_x = 0;
		var target = [area_data[i],area_data[i+1],area_data[i+2],area_data[i+3]];
		target.push( Math.round( (Math.max(area_data[i],area_data[i+1],area_data[i+2]) + Math.min(area_data[i],area_data[i+1],area_data[i+2])) / 2) );
		
		var trail_up = false;
		var trail_down = false;
		//pixel that is currently being sampled
		var current;
		var j = 0;
		while(j<coords.length){
			
			x=coords[j][0];
			y=coords[j][1];
			
			i = (x+(y*width))*4;
			trail_up = false;
			trail_down = false;
			current = [area_data[i],area_data[i+1],area_data[i+2],area_data[i+3]];
			
			//first go right
			d_x = 1;
			while(true){
			
				same = sm.checkPixelSame(current,target);
				if(!same || fill_map_data[i+3]>0){
					//console.log(same,current,target);
					break;
				}
				
				//to not go negative row
				//sample pixel from row up
				if(y>0){
					//position row up
					p_i = i-(width*4);
					p[0] = area_data[p_i];
					p[1] = area_data[p_i+1];
					p[2] = area_data[p_i+2];
					p[3] = area_data[p_i+3];
					
					same_next = fill_map_data[p_i+3]==0&&sm.checkPixelSame(p,target);
					
					if(trail_up == false && same_next){
						trail_up = true;
						coords.push([x,y-1]);
					}else if(trail_up == true && !same_next){
						trail_up = false;
					}
				}
				
				//to not go overboard row
				//sample pixel from row down
				if(y<h_limit){
					p_i = i+(width*4);
					p[0] = area_data[p_i];
					p[1] = area_data[p_i+1];
					p[2] = area_data[p_i+2];
					p[3] = area_data[p_i+3];
					
					same_next = fill_map_data[p_i+3]==0&& sm.checkPixelSame(p,target);
					
					if(trail_down == false && same_next){
						trail_down = true;
						coords.push([x,y+1]);
					}else if(trail_down == true && !same_next){
						trail_down = false;
					}
				}
				
				//set pixel
				fill_map_data[i+3] = 255;
				
				fill_area_data[i] = fill_val;
				fill_area_data[i+3] = fill_val;
				
				
				//go to next pixel
				i+=4*d_x;
				x+=d_x;
				current = [area_data[i],area_data[i+1],area_data[i+2],area_data[i+3]];
				
				same = sm.checkPixelSame(current,target);
				
				//go left or end this row walk
				if(x>w_limit || fill_map_data[i+3]>0 || !same){
				//console.log("going left");
					d_x = -1;
					x = coords[j][0]-1;
					if(x<0)break;
					i = (x+(y*width))*4;
					trail_up = false;
					trail_down = false;
					current = [area_data[i],area_data[i+1],area_data[i+2],area_data[i+3]];
				}else if(x<0){
					//console.log("exiting line");
					break;
				}
			
			}
			//
			
			j++;
		}
		//
		sm.selection_ctx.putImageData(fill_area, 0,0);
	},
	
	//support for use with autoSelect, like a fill function but for selection
	//whole canvas version / not contiguous
	fillSelectOpen : function(c,ctx,e){
		var sm = this;
		
		var c_rect = live_view.getBoundingClientRect();
		//note: floor seems to work more precise
		var x = Math.floor((e.x-c_rect.x)/canvas_view.current_zoom);
		var y = Math.floor((e.y-c_rect.y)/canvas_view.current_zoom);
		
		var area_data = ctx.getImageData(0,0,c.width,c.height).data;
		var fill_area = sm.selection_ctx.getImageData(0,0, sm.selection.width,sm.selection.height);
		var fill_area_data = fill_area.data;
		var target_pos = (y*c.width*4)+(x*4);
		//[r,g,b,a,lightness]
		var target = [area_data[target_pos],area_data[target_pos+1],area_data[target_pos+2],area_data[target_pos+3],0];
		//calculate lightness (max + min)/2
		target[4] = Math.round( (Math.max(target[0],target[1],target[2]) + Math.min(target[0],target[1],target[2])) / 2);
		
		var current = [0,0,0,0];
		var same = true;
		
		var fill_val = 255;
		if(sm.mode[2] == true){//subtract
			fill_val = 0;
		}
		
		let area_data_len = area_data.length;
		for(var i=0;i<area_data_len;i+=4){
			
			current[0] = area_data[i];
			current[1] = area_data[i+1];
			current[2] = area_data[i+2];
			current[3] = area_data[i+3];
			
			same = sm.checkPixelSame(current,target);
			
			if(same){
				fill_area_data[i] = fill_val;
				fill_area_data[i+1] = 0;//fill_val;
				fill_area_data[i+2] = 0;//fill_val;
				fill_area_data[i+3] = fill_val;
			}
		}
		
		sm.selection_ctx.putImageData(fill_area,0,0);
		
	},
	
	deleteSelectedArea : function(ctx){
		var sm = this;
		if(sm.selection_active == false)return;
		ctx.globalCompositeOperation = "destination-out";
		ctx.drawImage(sm.selection, 0,0);
		ctx.globalCompositeOperation = "source-over";
	},
	
	makeSelectionOpaque : function(){
		var sm = this;
		makeCanvasContentOpaque(sm.selection, sm.selection_ctx);
		sm.selectionPixelData = sm.selection_ctx.getImageData(0,0, sm.selection.width,sm.selection.height).data;
	},
	
	selectWrap : function(){
		var sm = this;
		//produces removes transparent pixels from selection, essentially wrapping
		//content in layer view
		if(sm.selection_active == false){
			sm.selection_ctx.fillRect(0,0, sm.selection.width,sm.selection.height);
		}
		
		var s_imgData = sm.selection_ctx.getImageData(0,0, sm.selection.width,sm.selection.height);
		var l_imgData = selected_layer.view_ctx.getImageData(0,0, selected_layer.view.width,selected_layer.view.height);
		
		var s_data = s_imgData.data;
		var l_data = l_imgData.data;
		
		var l_data_len = l_data.length;
		
		for(var i=0;i<l_data_len;i+=4){
			if(l_data[i+3] == 0){
				s_data[i+3] = 0;
			}
		}
		
		sm.selection_ctx.putImageData(s_imgData,0,0);
		sm.detectSelection();
		sm.makeSelectionOutline();
	},
	
	makeSelectionArea : function(w,h){
		var sm = this;
		sm.selection_ctx.clearRect(0,0, sm.selection.width,sm.selection.height);
		
		sm.selection_ctx.fillRect(((sm.selection.width-w)/2),((sm.selection.height-h)/2),w,h);
		sm.detectSelection();
		sm.makeSelectionOutline();
	},
	
	getBoundingBox : function(){
		var sm = this;
		var offsetX = 0;
		var offsetY = 0;
		var w = 0;
		var h = 0;
		
		if(sm.selection_active == false){
			return [offsetX,offsetY, w,h];
		}
		
		var selection_w = sm.selection.width;
		var selection_h = sm.selection.height;
		//get y coordinate
		var found = false;
		for(var y=0;y<selection_h;y++){
			for(var x=0;x<selection_w;x++){
				if(sm.selectionPixelData[(y*selection_w+x)*4 + 3] > 0){
					offsetY = y;
					found = true;
					break;
				}
			}
			if(found == true)break;
		}
	
		//get height
		found = false;
		for(var y=selection_h-1;y>-1;y--){
			for(var x=selection_w-1;x>-1;x--){
				if(sm.selectionPixelData[(y*selection_w+x)*4 + 3] > 0){
					h = y-offsetY+1;
					found = true;
					break;
				}
			}
			if(found == true)break;
		}
		
		
		found = false;
		//get x coordinate
		for(var x=0;x<selection_w;x++){
			for(var y=0;y<selection_h;y++){
				if(sm.selectionPixelData[(y*selection_w+x)*4 + 3] > 0){
					offsetX = x;
					found = true;
					break;
				}
			}
			if(found == true)break;
		}
		
		found = false;
		//get width
		for(var x=selection_w-1;x>-1;x--){
			for(var y=selection_h-1;y>-1;y--){
				if(sm.selectionPixelData[(y*selection_w+x)*4 + 3] > 0){
					w = x-offsetX+1;
					found = true;
					break;
				}
			}
			if(found == true)break;
		}
		
		return [offsetX,offsetY, w,h];
	
	},
	
	flipCanvas : function(scaleX,scaleY){
		var sm = this;
		if(sm.selection_active == false)return;
		
		chamber_buffer[0].put(sm.selection);
		sm.selection_ctx.translate(-sm.selection.width * ((-1+scaleX)/2), -sm.selection.height * ((-1+scaleY)/2));
		sm.selection_ctx.scale(scaleX,scaleY);
		chamber_buffer[0].output(sm.selection_ctx);
		sm.selection_ctx.setTransform(1, 0, 0, 1, 0, 0);
		
		this.detectSelection();
		this.makeSelectionOutline();
	},
	
	//resizing clears selection
	resizeCanvas : function(w,h){
		var sm = this;
		
		sm.selection.width = w;
		sm.selection.height = h;
		sm.selection_ctx.imageSmoothingEnabled = false;
		
		sm.selection_toggle.width = w;
		sm.selection_toggle.height = h;
		sm.selection_toggle_ctx.imageSmoothingEnabled = false;
		
		sm.selection_mediator.width = w;
		sm.selection_mediator.height = h;
		sm.selection_mediator_ctx.imageSmoothingEnabled = false;
		sm.selection_mediator_ctx.lineWidth = "1";
		sm.selection_mediator_ctx.fillStyle = "red";
		sm.selection_mediator_ctx.strokeStyle = "red";
		
		sm.selection_active = false;
		
	},
	
	//resizing clears selection
	resizeImage : function(w,h){
		var sm = this;
		
		sm.selection.width = w;
		sm.selection.height = h;
		sm.selection_ctx.imageSmoothingEnabled = false;
		
		sm.selection_toggle.width = w;
		sm.selection_toggle.height = h;
		sm.selection_toggle_ctx.imageSmoothingEnabled = false;
		
		sm.selection_mediator.width = w;
		sm.selection_mediator.height = h;
		sm.selection_mediator_ctx.imageSmoothingEnabled = false;
		sm.selection_mediator_ctx.lineWidth = "1";
		sm.selection_mediator_ctx.fillStyle = "red";
		sm.selection_mediator_ctx.strokeStyle = "red";
		
		sm.selection_active = false;
	},
	
	cropCanvas : function(x,y,w,h){
		var sm = this;
		
		chamber_buffer[0].put(sm.selection, x,y, w,h);
		
		sm.selection.width = w;
		sm.selection.height = h;
		sm.selection_ctx.imageSmoothingEnabled = false;
		
		sm.selection_toggle.width = w;
		sm.selection_toggle.height = h;
		sm.selection_toggle_ctx.imageSmoothingEnabled = false;
		
		sm.selection_mediator.width = w;
		sm.selection_mediator.height = h;
		sm.selection_mediator_ctx.imageSmoothingEnabled = false;
		sm.selection_mediator_ctx.lineWidth = "1";
		sm.selection_mediator_ctx.fillStyle = "red";
		sm.selection_mediator_ctx.strokeStyle = "red";
		
		chamber_buffer[0].output(sm.selection_ctx);
		sm.detectSelection();
		sm.makeSelectionOutline();
	},
	
	rotateCanvas90 : function(direction){
		var sm = this;
		rotateCanvasObj90(sm.selection,sm.selection_ctx, direction);
		rotateCanvasObj90(sm.selection_mediator,sm.selection_mediator_ctx, direction);
		rotateCanvasObj90(sm.selection_toggle,sm.selection_toggle_ctx, direction);
		sm.detectSelection();
		sm.makeSelectionOutline();
	}
	

}

var selection_module = new selectionModule();
selection_module.resetCheckerboard(2);
selection_module.updateUISelectionConfig();

//-----------------------------------Selection Structures END


//-----------------------------------Brush Structures
function brush(){
	var b = this;
	b.size = 1;
	b.tip_size = b.size;//reflects dipped tip size
	b.raw_size = 1.0;
	b.r = b.size/2;
	b.flow = 1.0;
	b.opacity = 1.0;
	b.hardness = 1.0;
	b.spacing = 0.20;//tip spacing %
	
	b.sizePressureEnabled = false;
	b.sizePressureMinDiameter = 0.01;
	
	b.flowPressureEnabled = false;
	
	b.directionEnabled = false;
	
	b.brush_type = "default";//default or custom
	b.custom_tip = null;//to be a canvas or image obj
	
	b.blend_assist = false;//brush blend mode toggle
	b.blend_assist_default = false;
	b.blend_mix = [0,0,0];//rgb of previous colors during blending
	b.blend_trail_active = false;
	
	b.flip_x_jitter = false;
	b.flip_y_jitter = false;
	b.roundness_jitter = 1.0;
	
	b.angle_jitter = 0;
	
	b.scatter_distance = 0.0;
	b.scatter_size_jitter = 1.0;
	b.scatter_count = 1;
	b.scatter_count_jitter = 0;
	
	//clone brush feature
	b.clone_sample = document.createElement("canvas");
	b.clone_sample_ctx = b.clone_sample.getContext("2d");
	b.clone_sample.width = b.size;
	b.clone_sample.height = b.size;
	b.clone_mode_active = false;

	//brush tip
	b.c = document.createElement("canvas");
	b.ctx = b.c.getContext("2d");
	b.c.width = b.size;
	b.c.height = b.size;
	//b.ctx.clearRect(0,0,b.c.width,b.c.height);

	b.color = "black";//maybe use rgba(0,0,0,0); if it fits color picker nicely
	//
	//guiding properties
	//to allow faster/simpler condition checks during brush drawing
	/*
	b.performance = {
		"doTransform" : false
	};
	*/
}

brush.prototype = {

	dip : function(){
		//note: tip_size - using given custom size for tip 
		//to go in the center of brush canvas
		var b = this;
		//
		var tip_size = b.tip_size;
		var tip_r = tip_size/2;
		
		//
		b.ctx.clearRect(0,0,b.size,b.size);
		if(b.brush_type == "default"){
			var grd = b.ctx.createRadialGradient(b.r, b.r, 0, b.r, b.r, tip_r);//prepare brush params: _ _ radius1 _ _ radius2 brush hardness
			grd.addColorStop( b.hardness, "black");
			grd.addColorStop(1, 'rgba(0,0,0,0)');
			b.ctx.fillStyle = grd;
			b.ctx.fillRect(0, 0, b.size, b.size);
		}else if(b.brush_type == "custom"){
			b.ctx.drawImage(b.custom_tip, b.r-tip_r, b.r-tip_r, tip_size, tip_size);
		}
		
		if(b.clone_mode_active == true){
		//clone brush tip
			b.ctx.globalCompositeOperation = "source-in";
			b.ctx.drawImage(b.clone_sample, b.r-tip_r, b.r-tip_r, tip_size, tip_size);
		}else{
		//giving color to brush
			b.ctx.globalCompositeOperation = "source-atop";
			b.ctx.fillStyle = b.color;
			b.ctx.fillRect(0, 0, b.size, b.size);
		}
		//restore setting
		b.ctx.globalCompositeOperation = "source-over";
		
	},

	setColor : function(color){
		var b = this;
		b.color = color;
		b.dip();
		return 0;
	},
	
	setSize : function(b_size, nominal){
		var b = this;
		
		b.tip_size = Math.round(b_size);
		if(nominal == true){
		//using same canvas, but different size tip
		//for things like size pressure, or size jitter
			b.dip();
			return;
		}
		//
		b.raw_size = b_size;
		b_size = Math.round(b_size);
		b.size = b_size;
		b.r = b.size/2;
		
		b.c.width = b_size;
		b.c.height = b_size;
		
		b.dip();
	},
	
	setHardness : function(b_hardness){
		var b = this;
		b.hardness = b_hardness;
		
		b.dip();
	},
	
	setFlow : function(b_flow){
		this.flow = b_flow;
	},
	
	setOpacity : function(b_opacity){
		this.opacity = b_opacity;
	},
	
	setSpacing : function(b_spacing){
		this.spacing = b_spacing/10/10;
	},
	
	//set pen pressure variables dynamically on a live brush if needed
	setSizePressureEnabled : function(active){
		this.sizePressureEnabled = active;
	},
	
	setSizePressureMinDiameter : function(val){
		this.sizePressureMinDiameter = val;
	},
	
	setFlowPressureEnabled : function(active){
		var b = this;
		b.flowPressureEnabled = active;
		if(!active){
			b.setFlow(current_bay.flow);
		}
	},
	
	setCloneMode : function(active){
		this.clone_mode_active = active;
		this.dip();
	},
	
	makeBrushCloneSample : function(c, x,y){
		var b = this;
		
		var offsetX = -(x-b.c.width/2);
		var offsetY = -(y-b.c.width/2);
		
		b.clone_sample.width = b.size;
		b.clone_sample.height = b.size;
		b.clone_sample_ctx.clearRect(0,0, b.clone_sample.width,b.clone_sample.height);
		
		b.clone_sample_ctx.drawImage(c, offsetX, offsetY);
		
		if(selection_module.selection_active == true){
			b.clone_sample_ctx.globalCompositeOperation = "destination-in";
			b.clone_sample_ctx.drawImage(selection_module.selection, offsetX,offsetY);
			b.clone_sample_ctx.globalCompositeOperation = "source-over";
		}
		
	},
	//
	load : function(bpreset){
		var b = this;
		b.size = bpreset.size;
		b.raw_size = b.size;
		b.tip_size = b.size;
		b.r = b.size/2;
		b.flow = bpreset.flow;
		b.opacity = bpreset.opacity;
		b.hardness = bpreset.hardness;
		b.spacing = bpreset.spacing;
		
		b.sizePressureEnabled = bpreset.sizePressureEnabled;
		b.sizePressureMinDiameter = bpreset.sizePressureMinDiameter;
		
		b.flowPressureEnabled = bpreset.flowPressureEnabled;
		
		b.directionEnabled = bpreset.directionEnabled;
		
		if(bpreset.brush_type == "custom" && bpreset.custom_tip != null){
			b.brush_type = bpreset.brush_type;//default or custom
		}else{
			b.brush_type = "default";
		}
		
		b.blend_assist = bpreset.blend_assist;//brush blend mode toggle
		b.blend_assist_default = b.blend_assist;
		
		b.flip_x_jitter = bpreset.flip_x_jitter;
		b.flip_y_jitter = bpreset.flip_y_jitter;
		b.roundness_jitter = bpreset.roundness_jitter;
		
		b.angle_jitter = bpreset.angle_jitter;
		
		b.scatter_distance = bpreset.scatter_distance;
		b.scatter_size_jitter = bpreset.scatter_size_jitter;
		b.scatter_count = bpreset.scatter_count;
		b.scatter_count_jitter = bpreset.scatter_count_jitter;
		
		b.c.width = b.size;
		b.c.height = b.size;
		b.ctx.clearRect(0,0,b.c.width,b.c.height);
		
		
		b.color = current_bay.color;
		
		if(b.brush_type == "custom"){
			b.custom_tip = new Image();
			b.custom_tip.src = bpreset.custom_tip;
			b.custom_tip.decode().then( () =>{
				b.dip();
			});
		}else{
			b.dip();
		}
		//
		/*
		b.performance.doTransform = b.directionEnabled ||
									b.angle_jitter > 0 ||
									b.flip_x_jitter ||
									b.flip_y_jitter ||
									b.roundness_jitter < 1.0;
		*/
	}

}


//-----------------------------------Brush structures END

//-----------------------------------Bay structures

function bay(){	
	//this bay
	var tb = this;
	
	//a pointer to brush preset in use by this bay
	//used for storing/exporting bay config, for preset name
	tb.activeBrushPreset = null;
	tb.activeBrushPresetId = 0;
	
	tb.brush = new brush();
	
	tb.size = tb.brush.size;
	tb.raw_size = tb.brush.size;
	
	//calculated spacing/step in pixels relative to bay brush size
	tb.step_spacing = tb.size*tb.brush.spacing;
	
	tb.size_bay_link_ref = 0;
	tb.size_bay_link_value = 100;
	tb.size_bay_link_active = false;
	
	tb.zoom_size = false;
	tb.zoom_size_value = 0;//stores bay size at point of zoom size activation
	
	tb.opacity = tb.brush.opacity;
	tb.flow = tb.brush.flow;
	tb.hardness = tb.brush.hardness;
	//if true will preserve color in this bay
	tb.keep_color = false;
	tb.color = "black";

}

bay.prototype = {

	load : function(config){
		var tb = this;
		
		//attribute copy
		for(var config_name in config){
			tb[config_name] = config[config_name];
		}
		//needed to avoid setting size of linked bay during load
		tb.size_bay_link_active = false;
		
		tb.activeBrushPreset = bp_keeper.getPresetById(config.activeBrushPresetId);
		if(tb.activeBrushPreset == null){
			//not found, make first preset active
			tb.loadBrushPreset(bp_keeper.getDefaultPreset());
		}else{
			tb.loadBrushPreset(tb.activeBrushPreset);
		}
		
		tb.setSize(config.size);
		tb.size_bay_link_active = config.size_bay_link_active;
		
		tb.setOpacity(config.opacity);
		tb.setFlow(config.flow);
		tb.setHardness(config.hardness);
		
		
	},
	
	setAttribute : function(attr,val){
		this[attr] = val;
	},
	
	setSize : function(b_size){
		var tb = this;
		tb.raw_size = b_size;
		b_size = Math.round(b_size);
		if(b_size<2)b_size = 1;
		tb.brush.setSize(b_size);
		tb.size = b_size;
		if(tb.size_bay_link_active){
			var linked_bay = bay_keeper.getBay(tb.size_bay_link_ref);
			//just modifying internal directly to not make a chain loop of setSize calls
			linked_bay.size = Math.round(tb.size/tb.size_bay_link_value * 100);
		}
		if(tb.zoom_size){
			tb.zoom_size_value = tb.raw_size * canvas_view.current_zoom;
		}
		tb.step_spacing = Math.max(1,tb.size*tb.brush.spacing);
	},
	
	getSize : function(){
		return this.size;
	},
	
	setOpacity : function(b_opacity){
		var tb = this;
		tb.opacity = b_opacity;
		tb.brush.setOpacity(b_opacity);
	},
	
	getOpacity : function(){
		return this.opacity;
	},
	
	getBrushOpacity : function(){
		return this.brush.opacity;
	},
	
	setFlow : function(b_flow){
		var tb = this;
		tb.flow = b_flow;
		tb.brush.setFlow(b_flow);
	},
	
	setHardness : function(b_hardness){
		var tb = this;
		tb.hardness = b_hardness;
		tb.brush.setHardness(b_hardness);
	},
	
	getFlow : function(){
		return this.flow;
	},
	
	getBrushFlow : function(){
		return this.brush.flow;
	},
	
	getHardness : function(){
		return this.brush.hardness;
	},
	
	setColor : function(b_color){
		var tb = this;
		tb.brush.setColor(b_color);
		tb.color = b_color;
		current_color = b_color;
	},
	
	toggleKeepColor : function(active){
		var tb = this;
		if(active == false){
			tb.setColor(current_color);
			color_picker.updateColorId();
		}
		tb.keep_color = active;
	},
	
	getKeepColor : function(){
		var tb = this;
		return tb.keep_color;
	},
	
	toggleBlendAssist : function(){
		var tb = this;
		tb.brush.blend_assist = !tb.brush.blend_assist_default;
	},
	
	resetBlendAssist : function(){
		var tb = this;
		tb.brush.blend_assist = tb.brush.blend_assist_default;
	},
	
	setBlendAssist : function(val){
		var tb = this;
		tb.brush.blend_assist = val;
	},
	
	getBlendAssist : function(){
		var tb = this;
		return tb.brush.blend_assist;
	},
	
	setCloneMode : function(active){
		this.brush.setCloneMode(active);
	},
	
	getCloneMode : function(val){
		return this.brush.clone_mode_active;
	},
	
	select : function(){
	//this bay is selected, prepare	
	//previous note: again bug with tb scope level, perhaps use current_bay instead of tb.
		current_bay = this;
		
		if(this.size_bay_link_active){
			var new_size = bay_keeper.getBay(this.size_bay_link_ref).getSize();
			new_size = Math.round(new_size * this.size_bay_link_value/10/10);
			this.setSize(new_size);
		}else if(this.zoom_size){
			this.setSize(this.zoom_size_value / canvas_view.current_zoom);
		}else{
			//update size of the brush in case it was modified by a bay linked to it
			this.setSize(this.size);
		}
		//
		if(this.keep_color == false){
			this.setColor(current_color);
		}else{
			UI.color_id.style.background = this.color;
		}
		
		current_brush = current_bay.brush;
	},
	
	setSizeBayLinkRef : function(bay_ref_index){
		var tb = this;
		tb.size_bay_link_ref = bay_ref_index;
		if(this.size_bay_link_active){
			var new_size = bay_keeper.getBay(this.size_bay_link_ref).getSize();
			new_size = Math.round(new_size * this.size_bay_link_value/10/10);
			this.setSize(new_size);
		}
	},
	
	toggleSizeBayLink : function(active){
		this.size_bay_link_active = active;
		if(this.size_bay_link_active){
			var new_size = bay_keeper.getBay(this.size_bay_link_ref).getSize();
			new_size = Math.round(new_size * this.size_bay_link_value/10/10);
			this.setSize(new_size);
		}
	},
	
	setSizeBayLinkValue : function(value){
		this.size_bay_link_value = value;
		if(this.size_bay_link_active){
			var new_size = bay_keeper.getBay(this.size_bay_link_ref).getSize();
			new_size = Math.round(new_size * this.size_bay_link_value/10/10);
			this.setSize(new_size);
		}
	},
	
	getSizeBayLinkRef : function(){
		return this.size_bay_link_ref;
	},
	
	getSizeBayLinkStatus : function(){
		return this.size_bay_link_active;
	},
	
	getSizeBayLinkValue : function(){
		return this.size_bay_link_value;
	},
	
	getBrush : function(){
		return this.brush;
	},
	
	loadBrushPreset : function(bpreset){
		var tb = this;
		
		tb.activeBrushPreset = bpreset;
		tb.activeBrushPresetId = tb.activeBrushPreset.id;
		//note: id is assigned by brushPresetKeeper
		
		if(bpreset.color != null){
			tb.color = bpreset.color;
			tb.keep_color = true;
		}
		
		tb.brush.load(bpreset);
		
		if(tb.size_bay_link_active){
		//linked bay size
			tb.toggleSizeBayLink(true);
		}else{
			tb.setSize(bpreset.size);
		}
		tb.opacity = bpreset.opacity;
		tb.flow = bpreset.flow;
		tb.hardness = bpreset.hardness;
	}
	
}


//creates bays for keeping brush objects. tracks bay selection for each brush tool
//also transponds setting calls to brush objects
function bayKeeper(){
	var bk = this;
	
	bk.configTitle = "BayConfig";
	bk.bays = [];
	bk.bays[0] = new bay();
	bk.bays[1] = new bay();
	bk.bays[2] = new bay();
	bk.bays[3] = new bay();
	bk.bays[4] = new bay();
	bk.bays[5] = new bay();
	bk.bays[6] = new bay();
	bk.bays[7] = new bay();
	
	//bay index associated with each brush tool
	bk.bay_tool = {};
	bk.bay_tool["brush_tool_0"] = 0;
	bk.bay_tool["brush_tool_1"] = 0;
	bk.bay_tool["eraser_tool_0"] = 0;
	bk.bay_tool["eraser_tool_1"] = 0;
	
	bk.single_brush_lock = false;
	bk.single_brush_bay = 0;
	
	bk.quick_brush_size_active = false;
	
	//for delaying notifying db update
	//example when wheel is used instead of button
	bk.bay_size_delay_db_action = null;
	
	
	bk.selected_bay_i = 0;
	bk.bays[bk.selected_bay_i].select();
}

bayKeeper.prototype = {
	
	//params is an array of values to init a brush object 
	//in bay at index bay_index
	loadConfigBay : function(config){
		for(var i=0;i<config.length;i++){
			this.bays[i].load(config[i]);
			//brush icon
			brushTipSampleImgMaker.updateBayIcon(UI["bay_"+i+"_icon"],this.bays[i]);
			UI["bay_"+i].setAttribute("title",this.bays[i].activeBrushPreset.name);
		}
	},
	
	loadConfigBaySelection : function(config){
		var bk = this;
		bk.bay_tool["brush_tool_0"] = config["brush_tool_0"];
		bk.bay_tool["brush_tool_1"] = config["brush_tool_1"];
		bk.bay_tool["eraser_tool_0"] = config["eraser_tool_0"];
		bk.bay_tool["eraser_tool_1"] = config["eraser_tool_1"];
		bk.single_brush_lock = config["single_brush_lock"];
		bk.single_brush_bay = config["single_brush_bay"];
		
		if(bk.single_brush_lock == true){
			bk.selected_bay_i = bk.single_brush_bay;
			UI.bay_single_brush_lock.checked = true;
		}else{
			bk.selected_bay_i = bk.bay_tool["brush_tool_0"];
		}
		//bk.bays[bk.selected_bay_i].select();
		bk.selectBay(bk.selected_bay_i);
		bk.updateUIBaySelect();
	},
	
	setBayBrush : function(bay_index, params){
		var bk = this;
		bk.bays[bay_index].setBrush(params);
	},
	
	selectBay : function(bay_index){
		var bk = this;

		//reset blend assist on tool change or toggle off on eraser
		//current_bay.resetBlendAssist();
		if(current_tool == "eraser_tool"){
			current_bay.setBlendAssist(false);
		}else{
			current_bay.resetBlendAssist();
		}
		
		
		bk.selected_bay_i = bay_index;
		bk.bays[bay_index].select();
		
		if(bk.single_brush_lock == true){
			bk.single_brush_bay = bay_index;
		}else{
			bk.bay_tool[current_tool+"_"+spree_mode] = bay_index;
		}
		//UI bay selection
		bk.updateUIBaySelect();
		
		//treat touch key as indicator
		if(current_bay.brush.blend_assist == true){
		//if(current_bay.brush.blend_assist_default){
			touch_module.toggleTouchKeyOnUI("blend_assist_tool");
		}else{
			touch_module.toggleTouchKeyOffUI("blend_assist_tool");
		}
	},
	
	updateUIBaySelect : function(){
		var bk = this;
		try{
			if(bk.single_brush_lock == true){
				UI["bay_"+bk.single_brush_bay].checked = true;
				UI["bay_"+bk.single_brush_bay+"_erase"].checked = true;
			}else{
				UI["bay_"+ bk.bay_tool[current_tool+"_0"] ].checked = true;;
				UI["bay_"+ bk.bay_tool[current_tool+"_1"] +"_erase"].checked = true;
			}
		}catch(err){
			console.log("UI bay not found: ",err);
		}
	},
	
	getBay : function(bay_index){
		var bk = this;
		return bk.bays[bay_index];
	},
	
	getBayIndexByBrushId : function(brush_id){
		var bk = this;
		for(let i=0,len=bk.bays.length; i<len; ++i){
			if(bk.bays[i].activeBrushPresetId == brush_id){
				return i;
			}
		}
		return null;
	},
	
	setSingleBrushLock : function(val){
		var bk = this;
		if(current_tool != "brush_tool" && current_tool != "eraser_tool"){
			changeTool("brush_tool");
		}
		bk.single_brush_lock = val;
		if(val == true){
			bk.single_brush_bay = bay_keeper.bay_tool[current_tool+"_"+spree_mode];
		}else{
			//note: this is a call to a global function to update bay values and cursor
			selectBay(bay_keeper.bay_tool[current_tool+"_"+spree_mode]);
		}
		
		//UI bay selection
		bk.updateUIBaySelect();
		
		//
		uc_keeper.notifyGenUpdateNeeded("generalConfig","bay_selection");
	}
	
}




//-----------------------------------Bay structures END

//-----------------------------------Color Picker structures

function colorPicker(color_id,cpf_hue_sb, cpf_selector,cpf_selector_cursor, cpf_hue_gradient,cpf_hue_selector,cpf_hue_selector_cursor ,cp_sample){
	var cp = this;
	
	cp.mouseIsDown = false;
	
	cp.color = "rgb(0,0,0)";
	current_color = cp.color;
	cp.rgb = [0,0,0];
	
	cp.color_id = color_id;
	cp.color_id.style.background = cp.color;
	
	cp.auto_apply = UI.cp_auto_apply.checked;
	
	//store HSL values
	cp.current_hue = 0;//in degrees
	cp.current_b = 0;//in percentages
	cp.current_s = 0;//in percentages
	cp.current_hue_rgb = [255,0,0];
	
	cp.hue_sb = cpf_hue_sb;
	
	cp.s = cpf_selector;//to draw field selector 
	cp.s_cursor = cpf_selector_cursor;
	
	cp.hue = cpf_hue_gradient;
	
	cp.hue_selector = cpf_hue_selector;
	cp.hue_selector_cursor = cpf_hue_selector_cursor;
	
	cp.sample = cp_sample;
	
	
	//can be "view" or "layer"
	//in view mode dropper selects color as it appears to user
	//in layer mode dropper selects color from current layer at its full opacity
	if(UI.cp_dropper_mode.checked){
		cp.dropper_mode = "layer";
	}else{
		cp.dropper_mode = "view";
	}
	
	//eyedropper tool 1x1 sampling canvas for quicker img data on large canvases
	cp.dropper_sample = document.createElement("canvas");
	cp.dropper_sample_ctx = cp.dropper_sample.getContext("2d");
	cp.dropper_sample.width = 1;
	cp.dropper_sample.height = 1;
	
	//misc flags/params that help module to alter behaviors across functions
	cp.modVars = {dropper_canvas_autoclose : false,
					dropper_ref_autoclose : false};
	
	cp.updateSample();
}

colorPicker.prototype = {

	updateSample : function(){
		var cp = this;
		var rgb = ApplySBToHue(cp.current_s,cp.current_b,cp.current_hue_rgb);
		cp.rgb = rgb;
		cp.color = "rgb("+rgb+")";
		cp.sample.style.backgroundColor = cp.color;
		
		UI.cp_hue_input.value = Math.round(cp.current_hue);
		UI.cp_saturation_input.value = Math.round(cp.current_s);
		UI.cp_brightness_input.value = Math.round(cp.current_b);
		UI.cp_r_input.value = rgb[0];
		UI.cp_g_input.value = rgb[1];
		UI.cp_b_input.value = rgb[2];
		UI.cp_hex_input.value = RGBtoHex(rgb);
	},
	
	selectHue : function(ey){
		var cp = this;
		
		var c_rect = cp.hue.getBoundingClientRect();
		var coordinateY = Math.round(ey - c_rect.y);
		if(coordinateY > cp.hue.clientHeight){
			coordinateY = cp.hue.clientHeight;
		}else if(coordinateY < 0){
			coordinateY = 0;
		}
		cp.current_hue = 360-Math.round(360/cp.hue.clientHeight * coordinateY);
		
		//fill with converted value
		var rgb = HueDegToRGB(cp.current_hue);
		cp.hue_sb.style.backgroundColor = "rgb("+rgb+")";
		cp.current_hue_rgb = rgb;
		
		cp.drawHueSelector();
		
		cp.updateSample();
	},
	
	selectSB : function(ex,ey){
		var cp = this;

		var c_rect = cp.s.getBoundingClientRect();
		var coordinateX = Math.round(ex - c_rect.x);// (-1 * canvas position X with offset) + (mouse event position) - (radius of brush size)
		var coordinateY = Math.round(ey - c_rect.y);
		
		if(coordinateX > cp.s.clientWidth){
			coordinateX = cp.s.clientWidth;
		}else if(coordinateX < 0){
			coordinateX = 0;
		}
		if(coordinateY > cp.s.clientHeight){
			coordinateY = cp.s.clientHeight;
		}else if(coordinateY < 0){
			coordinateY = 0;
		}
		
		cp.current_b = Math.round(100/cp.s.clientHeight * (cp.s.clientHeight-coordinateY));
		cp.current_s = Math.round(100/cp.s.clientWidth * coordinateX);
		cp.drawSBselector();
		cp.updateSample();
	},
	
	getColor : function(){
		return this.color;
	},
	
	RGBtoHueSB : function(rgb){
	
	/*notes:
	If Red is max, then Hue = (G-B)/(max-min)
	If Green is max, then Hue = 2.0 + (B-R)/(max-min)
	If Blue is max, then Hue = 4.0 + (R-G)/(max-min)
	min and max are relative to this^
	*/
		var cp = this;
		var i_max = 0;
		var i_min = 0;
		var c_max = rgb[0];
		var c_min = rgb[0];
		var c_med = rgb[0];
		for(var i=0;i<3;i++){

			if(c_max < rgb[i]){
				c_max = rgb[i];
				i_max = i;
			}
			if(c_min > rgb[i]){
				c_min = rgb[i];
				i_min = i;
			}
		}
		
		var i_med = (3-i_max-i_min)%3;
		c_med = rgb[i_med];
		
		
		if(c_max == 0){
			cp.current_b = 0;
			return;
		}
		
		
		var b = 100/255*c_max;
		
		var s = 100/255*(c_min/b*100);

		if(c_min == c_max){
			cp.current_b = b;
			cp.current_s = 100-s;
			return;
		}
		
		var h = (360+60*(i_max*2 + ((rgb[(i_max+1)%3] - rgb[(i_max+2)%3]) / (c_max - c_min))))%360;

		var p_med = Math.round(255 - ( (255-(c_med/b*100)) / (100-s) * 100 ));
		
		cp.current_hue = h;
		cp.current_s = 100-s;
		cp.current_b = b;
		cp.current_hue_rgb[i_min] = 0;
		cp.current_hue_rgb[i_max] = 255;
		cp.current_hue_rgb[i_med] = p_med;
		
	},
	
	processRGBInput : function(rgb){
		var cp = this;
		cp.RGBtoHueSB(rgb);

		//set pure hue
		cp.hue_sb.style.backgroundColor = "rgb("+cp.current_hue_rgb+")";
		
		cp.drawSBselector();
		cp.drawHueSelector();
		
		cp.updateSample();
	},
	
	processHueInput : function(hue){
		var cp = this;
		cp.current_hue = hue;
		cp.current_hue_rgb = HueDegToRGB(cp.current_hue);
		//set pure hue
		cp.hue_sb.style.backgroundColor = "rgb("+cp.current_hue_rgb+")";
		
		//draw the selector
		cp.drawHueSelector();
		
		cp.updateSample();
	},
	
	processSInput : function(s){
		var cp = this;
		cp.current_s = s;
		cp.drawSBselector();
		
		cp.updateSample();
	},
	
	processBInput : function(b){
		var cp = this;
		cp.current_b = b;
		cp.drawSBselector();
		
		cp.updateSample();
	},
	
	drawSBselector : function(){
		var cp = this;		
		cp.s_cursor.style.left = cp.current_s+"%";
		cp.s_cursor.style.top = (100-cp.current_b)+"%";
	},
	
	drawHueSelector : function(){
		var cp = this;
		cp.hue_selector_cursor.style.top = (100-(cp.current_hue/360*100))+"%";
	},
	//
	openToolDropperCanvas : function(autoclose){
		if(autoclose == true){
			this.modVars.dropper_canvas_autoclose = true;
		}
		dynamic_ui_ctx.clearRect(0,0,dynamic_ui.width,dynamic_ui.height);
		showUIElement(UI.cp_dropper_screen);
	},
	
	closeToolDropperCanvas : function(){
		hideUIElement(UI.cp_dropper_screen);
		this.modVars.dropper_canvas_autoclose = false;
	},
	//
	openToolDropperRefLayer : function(autoclose){
		if(autoclose == true){
			this.modVars.dropper_ref_autoclose = true;
		}
		ref_layer.style.display="block";
	},
	
	closeToolDropperRefLayer : function(){
		ref_layer.style.display="none";
		this.modVars.dropper_ref_autoclose = false;
	},
	//
	useDropperCanvas : function(e){
		var cp = this;
		var area;
		var c_rect = live_view.getBoundingClientRect();
		var coordinateX = Math.floor((e.x - c_rect.x)/canvas_view.current_zoom);
		var coordinateY = Math.floor((e.y - c_rect.y)/canvas_view.current_zoom);
		var fc = [];//found color
		
		cp.dropper_sample_ctx.clearRect(0,0,1,1);
		
		if(cp.dropper_mode == "layer"){
			cp.dropper_sample_ctx.drawImage(selected_layer.view, -coordinateX, -coordinateY);
			area = cp.dropper_sample_ctx.getImageData(0,0,1,1);
			fc[0] = area.data[0];
			fc[1] = area.data[1];
			fc[2] = area.data[2];
			cp.processRGBInput(fc);
		}else if(cp.dropper_mode == "view"){
			cp.dropper_sample_ctx.drawImage(live_view, -coordinateX, -coordinateY);
			area = cp.dropper_sample_ctx.getImageData(0,0,1,1);
			//treat transparent as white
			//(foregroundRed * foregroundAlpha) + (backgroundRed * (1.0 - foregroundAlpha));
			fc[0] = (area.data[0] * 1/255*area.data[3]) + 255-area.data[3];
			fc[1] = (area.data[1] * 1/255*area.data[3]) + 255-area.data[3];
			fc[2] = (area.data[2] * 1/255*area.data[3]) + 255-area.data[3];
			cp.processRGBInput(fc);
		}
		//live color id update
		cp.updateColorId();
		return;
	},
	
	useDropperRefLayer : function(e){
		var cp = this;
		var area_data;
		var c_rect = ref_layer.getBoundingClientRect();
		var coordinateX = e.x - c_rect.x;
		var coordinateY = e.y - c_rect.y;
		var fc = [];//found color
		
		cp.dropper_sample_ctx.clearRect(0,0,1,1);
		cp.dropper_sample_ctx.drawImage(ref_layer, -coordinateX, -coordinateY);
		
		area_data = ref_layer_ctx.getImageData(coordinateX,coordinateY,1,1).data;
		if(area_data[3] == 0)return;
		fc[0] = area_data[0];
		fc[1] = area_data[1];
		fc[2] = area_data[2];
		cp.processRGBInput(fc);
		//live color id update
		cp.updateColorId();
		return;
	},
	
	updateColorId : function(){
		var cp = this;
		cp.color_id.style.background = cp.color;
	}

}
//colorPicker/eyedropper screen bind
UI.cp_dropper_screen.addEventListener("pointerdown", function(e){
	color_picker.mouseIsDown = true;
	color_picker.useDropperCanvas(e);
});
UI.cp_dropper_screen.addEventListener("pointermove", function(e){
	if(color_picker.mouseIsDown == true){
		color_picker.useDropperCanvas(e);
	}
});
UI.cp_dropper_screen.addEventListener("pointerup", function(e){
	color_picker.mouseIsDown = false;
	applyColorPickerColor();
	//
	if(color_picker.modVars.dropper_canvas_autoclose == true){
		color_picker.closeToolDropperCanvas();
		touch_module.toggleTouchKeyOffUI("cp_dropper_tool");
	}
});
//ref layer color picking
ref_layer.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	color_picker.mouseIsDown = true;
	color_picker.useDropperRefLayer(e);
	return;
});

ref_layer.addEventListener("pointermove", function(e){
	e.stopPropagation();
	if(!color_picker.mouseIsDown)return;
	color_picker.useDropperRefLayer(e);
	return;
});

ref_layer.addEventListener("pointerup", function(e){
	e.stopPropagation();
	color_picker.mouseIsDown = false;
	applyColorPickerColor();
	//
	if(color_picker.modVars.dropper_ref_autoclose == true){
		color_picker.closeToolDropperRefLayer();
		touch_module.toggleTouchKeyOffUI("color_palette_tool");
	}
	return;
});
//

//-----------------------------------Color Picker structures END

//-----------------------------------Adjustments structures

var colorFilter = {
	
	init : function(){
		var cf = this;
		
		cf.preview_active = true;
		cf.mem_active = false;
		
		cf.original_c = document.createElement('canvas');
		cf.original_ctx = colorFilter.original_c.getContext("2d");
		cf.current_c = document.createElement('canvas');
		cf.current_ctx = this.current_c.getContext("2d");
		cf.original_imageData = null;
		cf.current_imageData = null;
		cf.width = 0;
		cf.height = 0;
		//HSB
		cf.h_val = 0;
		cf.s_val = 0;
		cf.b_val = 0;
		//Gamma
		cf.g_val = 1;
		
		cf.softlight_val = 0;
		cf.hardlight_val = 0;
		cf.contrast_val = 0;
		
		//if true will assign h_val hue to desaturated pixels upon saturation
		cf.desat_hue = false;
		
		//affected range
		cf.h_range = [0,360];//TODO maybe expand range some circular way
		cf.s_range = [0,100];
		cf.b_range = [0,100];
		
		cf.blend_filter_screen = document.createElement('canvas');
		cf.blend_filter_screen_ctx = cf.blend_filter_screen.getContext("2d");
	},
	
	setValue : function(option,val){
		this[option] = val;
	},
	
	setRange : function(option,index,val){
		this[option][index] = val;
	},
	
	prepare : function(c){
		//store original and set current for processing
		var cf = this;
		if(cf.width != c.width || cf.height != c.height){
			cf.width = c.width;
			cf.height = c.height;
			cf.original_c.width = cf.width;
			cf.original_c.height = cf.height;
			cf.current_c.width = cf.width;
			cf.current_c.height = cf.height;
			cf.blend_filter_screen.width = cf.width;
			cf.blend_filter_screen.height = cf.height;
		}
		
		
		cf.original_ctx.clearRect(0,0,cf.width,cf.height);
		cf.current_ctx.clearRect(0,0,cf.width,cf.height);
		
		cf.original_ctx.drawImage(c,0,0);
		cf.current_ctx.drawImage(c,0,0);
		
		//cache image data
		cf.original_imageData = cf.original_ctx.getImageData(0,0,cf.width,cf.height);
		//make opaque
		var data = cf.original_imageData.data;
		const data_len = data.length;
		let pixel_data_i = 0;
		for(let i=0;i<data_len;i+=4){
			pixel_data_i = i+3;
			if(data[pixel_data_i] > 0 && data[pixel_data_i] < 255){
				data[pixel_data_i] = 255;
			}
		}
		cf.current_imageData = cf.current_ctx.getImageData(0,0,cf.width,cf.height);
		
		cf.blend_filter_screen_ctx.globalCompositeOperation = "source-over";
		cf.blend_filter_screen_ctx.fillStyle = "rgb(128,128,128)";
		if(selection_module.selection_active == true){
			cf.blend_filter_screen_ctx.clearRect(0,0, cf.blend_filter_screen.width,cf.blend_filter_screen.height);
			cf.blend_filter_screen_ctx.drawImage(selection_module.selection,0,0);
		}else{
			cf.blend_filter_screen_ctx.fillRect(0,0, cf.blend_filter_screen.width,cf.blend_filter_screen.height);
		}
		cf.blend_filter_screen_ctx.globalCompositeOperation = "source-atop";
	},
	
	resetValues : function(){
		var cf = this;
		cf.h_val = 0;
		cf.s_val = 0;
		cf.b_val = 0;
		cf.g_val = 1;
		cf.softlight_val = 0;
		cf.hardlight_val = 0;
		cf.vibrance_val = 0;
		cf.contrast_val = 0;
	},
	
	resetRanges : function(){
		var cf = this;
		cf.h_range = [0,360];//TODO maybe expand range some circular way
		cf.s_range = [0,100];
		cf.b_range = [0,100];
	},
	
	restoreOriginal : function(ctx_out){
		var cf = this;
		ctx_out.clearRect(0,0,cf.width,cf.height);
		ctx_out.drawImage(cf.original_c,0,0);
	},
	
	output : function(ctx_out){
		var cf = this;
		ctx_out.clearRect(0,0,cf.width,cf.height);
		ctx_out.drawImage(cf.current_c,0,0);
	},
	
	applyChanges : function(){
		var cf = this;
		cf.original_ctx.clearRect(0,0,cf.width,cf.height);
		cf.original_ctx.drawImage(cf.current_c,0,0);
		cf.resetValues();
	},
	
	adjust : function(){
		var cf = this;
		
		var imageData = cf.current_imageData;
		var data = imageData.data;//pixel data to be modified
		const o_data = cf.original_imageData.data;//pixel data sample reference
		data.set(o_data);//resetting image data to original opaque
		const data_len = data.length;
		
		var rgb_pixel = null;
		var hsb_pixel = null;
		var selection_alpha = 255;
		
		//helper pixel vars
		var pb,pa,lightness;
		var pixel_skip = false;
		const hsb_active = (cf.h_val != 0 || cf.s_val != 0 || cf.b_val != 0);//optimization
		const limit_active = (cf.h_range[0] > 0 || cf.h_range[1] < 360) ||
						(cf.s_range[0] > 0 || cf.s_range[1] < 100) ||
						(cf.b_range[0] > 0 || cf.b_range[1] < 100);//optimization
		//localizing things
		const vibrance_active = cf.vibrance_val != 0;
		const contrast_active = cf.contrast_val != 0;
		const softlight_active = cf.softlight_val != 0;
		const gamma_active = cf.g_val != 1;
		const gammaCorrection = 1/cf.g_val;
		
		const selection_active = selection_module.selection_active;
		if(selection_active == true){
			var selectionPixelData = selection_module.selectionPixelData;
		}
		for (var i = 0; i < data_len; i += 4) {
			//check pixel is visible
			if(selection_active == true) selection_alpha = selectionPixelData[i+3];
			//note: using data here instead of o_data because o_data is opaque
			if(o_data[i+3] > 0 && selection_alpha > 0){
				
				if(hsb_active == true || limit_active == true){
					//get pixel in HSB format
					hsb_pixel = RGBtoHSB([o_data[i],o_data[i+1],o_data[i+2]]);
					
					if(limit_active == true){
						//check affected range
						pixel_skip = (hsb_pixel[0] < cf.h_range[0] || hsb_pixel[0] > cf.h_range[1]) || 
									(hsb_pixel[1] < cf.s_range[0] || hsb_pixel[1] > cf.s_range[1]) || 
									(hsb_pixel[2] < cf.b_range[0] || hsb_pixel[2] > cf.b_range[1]);
					}
				}
				
				//debug
				/*
				if(hsb_pixel[1] < 0){
					console.log(hsb_pixel);
					return;
				}
				*/
				
				
				if(pixel_skip == false){
					
					if(hsb_active == true){
					//optimization
						//do hue
						//val between -180 and 180
						hsb_pixel[0] = hsb_pixel[0]+cf.h_val;
						if(hsb_pixel[0] > 360)hsb_pixel[0] -= 360;
						if(hsb_pixel[0] < 0)hsb_pixel[0] += 360;
						
						
						//do saturation
						//val between 0 and 100
						if(hsb_pixel[1] > 0 || cf.desat_hue){ 
							hsb_pixel[1] = hsb_pixel[1]+cf.s_val;
							if(hsb_pixel[1] > 100)hsb_pixel[1] = 100;
							if(hsb_pixel[1] < 0)hsb_pixel[1] = 0;
						}
						
						//do brightness
						//val between 0 and 100
						hsb_pixel[2] = hsb_pixel[2]+cf.b_val;
						if(hsb_pixel[2] > 100)hsb_pixel[2] = 100;
						if(hsb_pixel[2] < 0)hsb_pixel[2] = 0;
						
						
						
						
						
						
						//store new pixel data
						rgb_pixel = HSBtoRGB(hsb_pixel);
					}else{
						rgb_pixel = [o_data[i],o_data[i+1],o_data[i+2]];
					}
					//do any other rgb-based adjustments
					//here
					
					//do vibrance
					if(vibrance_active == true){
						lightness = Math.round( (Math.max(rgb_pixel[0],rgb_pixel[1],rgb_pixel[2]) + Math.min(rgb_pixel[0],rgb_pixel[1],rgb_pixel[2])) / 2);
						
						rgb_pixel[0] = rgb_pixel[0] - (lightness - rgb_pixel[0]) * (cf.vibrance_val/10/10);
						rgb_pixel[1] = rgb_pixel[1] - (lightness - rgb_pixel[1]) * (cf.vibrance_val/10/10);
						rgb_pixel[2] = rgb_pixel[2] - (lightness - rgb_pixel[2]) * (cf.vibrance_val/10/10);
					}
					
					//do contrast
					if(contrast_active == true){
						//let lightness = Math.round( (Math.max(rgb_pixel[0],rgb_pixel[1],rgb_pixel[2]) + Math.min(rgb_pixel[0],rgb_pixel[1],rgb_pixel[2])) / 2);
						rgb_pixel[0] = rgb_pixel[0] - (128 - rgb_pixel[0]) * (cf.contrast_val/10/10)/2;
						rgb_pixel[1] = rgb_pixel[1] - (128 - rgb_pixel[1]) * (cf.contrast_val/10/10)/2;
						rgb_pixel[2] = rgb_pixel[2] - (128 - rgb_pixel[2]) * (cf.contrast_val/10/10)/2;
					}
					
					//do light
					if(softlight_active == true){
						pb = 0.5 + selection_alpha/255*(cf.softlight_val/10/10);
						pa = rgb_pixel[0]/255;
						rgb_pixel[0] = 255*(2 * pa * pb + pa*pa - 2 * pa*pa*pb);
						
						pa = rgb_pixel[1]/255;
						rgb_pixel[1] = 255*(2 * pa * pb + pa*pa - 2 * pa*pa*pb);
						
						pa = rgb_pixel[2]/255;
						rgb_pixel[2] = 255*(2 * pa * pb + pa*pa - 2 * pa*pa*pb);
					}
					
					//do gamma
					//val between 10 and 0.1
					if(gamma_active == true){
						
						
						rgb_pixel[0] = 255 * Math.pow((rgb_pixel[0] / 255), gammaCorrection);
						rgb_pixel[1] = 255 * Math.pow((rgb_pixel[1] / 255), gammaCorrection);
						rgb_pixel[2] = 255 * Math.pow((rgb_pixel[2] / 255), gammaCorrection);
					}
					
					if(selection_alpha < 255){
						//(foregroundRed * foregroundAlpha) + (backgroundRed * (1.0 - foregroundAlpha));
						data[i] = (rgb_pixel[0] * 1/255*selection_alpha) + (data[i] * (1.0 - 1/255*selection_alpha));
						data[i+1] = (rgb_pixel[1] * 1/255*selection_alpha) + (data[i+1] * (1.0 - 1/255*selection_alpha));
						data[i+2] = (rgb_pixel[2] * 1/255*selection_alpha) + (data[i+2] * (1.0 - 1/255*selection_alpha));
					}else{
						data[i] = rgb_pixel[0];
						data[i+1] = rgb_pixel[1];
						data[i+2] = rgb_pixel[2];
					}
					
					//adjustments end
					
				}//affected range check end
			}//pixel visible check end
			
		}//pixel loop end

		cf.current_ctx.putImageData(imageData, 0, 0);
		
		cf.current_ctx.globalCompositeOperation = "destination-in";
		cf.current_ctx.drawImage(cf.original_c,0,0);
		cf.current_ctx.globalCompositeOperation = "source-over";
	},
	
	getCurrent : function(){
		return this.current_c;
	},
	
	parseUIGammaInput : function(val,mode){
		//mode is 0 or 1 depending on slider value or number field value
		var output = 0.0;//default value
		var parsed_val = 0;
		if(mode == 1){
		//field
			parsed_val = val-1;
			
			if(parsed_val < 0){
				output = parsed_val*10*10*10;
			}else{
				output = parsed_val*10*10;
			}
		
		}else{
		//slider
			if(val < 0){
				output = (100+Math.round(val/10))/10/10;
			}else{
				output = (100+val)/10/10;
			}
		}
		return output;
	}
	

}

colorFilter.init();

function updateUIColorFilter(){
	UI.cf_hue_value.value = colorFilter.h_val;
	UI.cf_hue_slider.value = colorFilter.h_val;
	
	UI.cf_saturation_value.value = colorFilter.s_val;
	UI.cf_saturation_slider.value = colorFilter.s_val;
	
	UI.cf_brightness_value.value = colorFilter.b_val;
	UI.cf_brightness_slider.value = colorFilter.b_val;
	
	UI.cf_gamma_value.value = colorFilter.g_val;
	UI.cf_gamma_slider.value = colorFilter.g_val;
	
	UI.cf_softlight_value.value = colorFilter.softlight_val;
	UI.cf_softlight_slider.value = colorFilter.softlight_val;
	
	UI.cf_vibrance_value.value = colorFilter.vibrance_val;
	UI.cf_vibrance_slider.value = colorFilter.vibrance_val;
	
	UI.cf_contrast_value.value = colorFilter.contrast_val;
	UI.cf_contrast_slider.value = colorFilter.contrast_val;
	
	//
	UI.cf_hue_limit_lower_value.value = colorFilter.h_range[0];
	UI.cf_hue_limit_lower_slider.value = colorFilter.h_range[0];
	UI.cf_hue_limit_upper_value.value = colorFilter.h_range[1];
	UI.cf_hue_limit_upper_slider.value = colorFilter.h_range[1];
	
	UI.cf_saturation_limit_lower_value.value = colorFilter.s_range[0];
	UI.cf_saturation_limit_lower_slider.value = colorFilter.s_range[0];
	UI.cf_saturation_limit_upper_value.value = colorFilter.s_range[1];
	UI.cf_saturation_limit_upper_slider.value = colorFilter.s_range[1];
	
	UI.cf_brightness_limit_lower_value.value = colorFilter.b_range[0];
	UI.cf_brightness_limit_lower_slider.value = colorFilter.b_range[0];
	UI.cf_brightness_limit_upper_value.value = colorFilter.b_range[1];
	UI.cf_brightness_limit_upper_slider.value = colorFilter.b_range[1];
	
	UI.cf_desat_hue.checked = colorFilter.desat_hue;
	UI.cf_preview.checked = colorFilter.preview_active;
	UI.cf_mem.checked = colorFilter.mem_active;
}

function performColorFilterOptions(option){
	var ctx_out = selected_layer.ctx;
	
	switch(option){
		case "preview":
			colorFilter.adjust();
			if(colorFilter.preview_active == true){
				colorFilter.output(ctx_out);
				selected_layer.updateView();
				stackLiveView();
			}
		break;
		//
		case "toggle_preview":
			if(colorFilter.preview_active == true){
				colorFilter.output(ctx_out);
			}else{
				colorFilter.restoreOriginal(ctx_out);
			}
			selected_layer.updateView();
			stackLiveView();
		break;
		//
		case "cancel":
			colorFilter.restoreOriginal(ctx_out);
			selected_layer.updateView();
			stackLiveView();
			UI.color_filter_menu.style.display = "";
			UI.global_cf_menu_lock_screen.style.display = "";
			
			hk.requestUnlock();
		break;
		//
		case "apply":
			//do history store
			colorFilter.restoreOriginal(ctx_out);
			history_keeper.store("layer",current_tool,toolset_mode,selected_layer_i);
			colorFilter.output(ctx_out);
			
			UI.color_filter_menu.style.display = "";
			UI.global_cf_menu_lock_screen.style.display = "";
			
			hk.requestUnlock();
		break;
		//
		case "reset_values":
			colorFilter.resetValues();
			performColorFilterOptions("preview");
			updateUIColorFilter();
		break;
		//
		case "reset_ranges":
			colorFilter.resetRanges();
			performColorFilterOptions("preview");
			updateUIColorFilter();
		break;
		//
		case "open":
			solidifySpree();
			try{
				hk.requestLock();
				
				colorFilter.prepare(selected_layer.c);
				
				if(colorFilter.mem_active == true){
					performColorFilterOptions("preview");
				}else{
					colorFilter.resetValues();
					colorFilter.resetRanges();
					colorFilter.preview_active = true;
					updateUIColorFilter();
				}
				UI.color_filter_menu.style.display = "block";
				UI.global_cf_menu_lock_screen.style.display = "block";
			}catch(err){
				console.log(err);
				alert(err);
				//on fail attempt maybe to cancel
				performColorFilterOptions("cancel");
			}
		break;
		//
	
	
	}

}

//-----------------------------------Adjustments structures END


var dragWindow = {
	elem : null,
	dragScreen : document.getElementById("dragWindow_screen"),
	posX : 0,
	posY : 0,
	diffX : 0,
	diffY : 0,
	mouseIsDown : false,
	
	"down" : function(obj,e){
		this.dragScreen.style.display = "block";
		this.elem = obj;
		this.mouseIsDown = true;
		var window_pos = this.elem.getBoundingClientRect();
		this.posX = window_pos.x;
		this.posY = window_pos.y;
		this.diffX = e.x - this.posX;
		this.diffY = e.y - this.posY;
	},
	
	"move" : function(e){
		if(!this.mouseIsDown)return;
		this.elem.style.left = (e.x - this.diffX) + "px";
		this.elem.style.top = (e.y - this.diffY) + "px";
	},
	
	"up" : function(){
		this.dragScreen.style.display = "none";
	}
	
}


//Set up visible canvases into vars
var dynamic_ui = document.getElementById("dynamicUI");
dynamic_ui.width = c_view.offsetWidth;
dynamic_ui.height = c_view.offsetHeight;
var dynamic_ui_ctx = dynamic_ui.getContext("2d");
//caching position for faster in-frame draw like during cursorDraw
var dynamic_ui_rect_x = dynamic_ui.getBoundingClientRect().x;
var dynamic_ui_rect_y = dynamic_ui.getBoundingClientRect().y;
//
var dynamic_manipulation = document.getElementById("dynamicManipulation");
dynamic_manipulation.width = drawingAreaWidth;
dynamic_manipulation.height = drawingAreaHeight;
var dynamic_manipulation_ctx = dynamic_manipulation.getContext("2d");
//
var live_view = document.getElementById("liveView");
live_view.width = drawingAreaWidth;
live_view.height = drawingAreaHeight;
live_view.style.width = drawingAreaWidth + "px";
live_view.style.height = drawingAreaHeight + "px";
var live_view_ctx = live_view.getContext("2d");

//similar to live_view but with certain features/layers omitted from stack
//use case for example for blending assist to sample only current and below layers
var live_view_limited = document.createElement("canvas");
var live_view_limited_ctx = live_view_limited.getContext("2d");
live_view_limited.width = drawingAreaWidth;
live_view_limited.height = drawingAreaHeight;
live_view_limited.style.width = drawingAreaWidth + "px";
live_view_limited.style.height = drawingAreaHeight + "px";
//live_view_limited_ctx.clearRect(0,0,live_view_limited.width,live_view_limited.height);

var tiny_preview = document.getElementById("tinyPreview");
tiny_preview.width = drawingAreaWidth;
tiny_preview.height = drawingAreaHeight;
var tiny_preview_ctx = tiny_preview.getContext("2d");
//tiny_preview_ctx.clearRect(0,0,tiny_preview.width,tiny_preview.height);
//to setup zoom toggle from start
canvas_view.zoomFit();
canvas_view.zoomFit();
//
var brush_mediator_opacity = document.createElement("canvas");
var brush_mediator_opacity_ctx = brush_mediator_opacity.getContext("2d");
brush_mediator_opacity.width = drawingAreaWidth;
brush_mediator_opacity.height = drawingAreaHeight;
//brush_mediator_opacity_ctx.clearRect(0,0,brush_mediator_opacity.width,brush_mediator_opacity.height);

//construct brush mediator SUPPORT canvas
var brush_mediator_flow = document.createElement("canvas");
var brush_mediator_flow_ctx = brush_mediator_flow.getContext("2d");
brush_mediator_flow.width = drawingAreaWidth;
brush_mediator_flow.height = drawingAreaHeight;
//brush_mediator_flow_ctx.clearRect(0,0,brush_mediator_flow.width,brush_mediator_flow.height);

//brush tip mediator for effects
//var brush_mediator_tip = document.createElement("canvas");
//var brush_mediator_tip_ctx = brush_mediator_tip.getContext("2d");


//layer mixing chamber, area of brush influence
var chamber = document.createElement("canvas");
var chamber_ctx = chamber.getContext("2d");
chamber.width = 1;
chamber.height = 1;

//chamber_ctx.clearRect(0,0,chamber.width,chamber.height);

var chamber_live_view = document.createElement("canvas");
var chamber_live_view_ctx = chamber_live_view.getContext("2d");
chamber_live_view.width = drawingAreaWidth;
chamber_live_view.height = drawingAreaHeight;
//chamber_live_view_ctx.clearRect(0,0,chamber_live_view.width,chamber_live_view.height);

var chamber_mask_mediator = document.createElement("canvas");
var chamber_mask_mediator_ctx = chamber_mask_mediator.getContext("2d");
chamber_mask_mediator.width = 1;
chamber_mask_mediator.height = 1;

var chamber_blend_sample = document.createElement("canvas");
var chamber_blend_sample_ctx = chamber_blend_sample.getContext("2d");
chamber_blend_sample.width = 3;
chamber_blend_sample.height = 3;
//chamber_blend_sample_ctx.clearRect(0,0,chamber_blend_sample.width,chamber_blend_sample.height);

//clipping and folder mask mixing chamber, area of brush influence
//for mixing layer.view with folder and clipping mask 
//before drawing to chamber for live view stacking
var chamber_clipping_mask = document.createElement("canvas");
//chamber_clipping_mask.width = drawingAreaWidth;
//chamber_clipping_mask.height = drawingAreaHeight;
var chamber_clipping_mask_ctx = chamber_clipping_mask.getContext("2d");
//chamber_clipping_mask_ctx.clearRect(0,0,chamber_clipping_mask.width,chamber_clipping_mask.height);

var chamber_clipping_mask_brush = document.createElement("canvas");
//chamber_clipping_mask_brush.width = 1;
//chamber_clipping_mask_brush.height = 1;
var chamber_clipping_mask_brush_ctx = chamber_clipping_mask_brush.getContext("2d");
//chamber_clipping_mask_brush_ctx.clearRect(0,0,chamber_clipping_mask_brush.width,chamber_clipping_mask_brush.height);

var chamber_clipping_mask_limited = document.createElement("canvas");
//chamber_clipping_mask_limited.width = drawingAreaWidth;
//chamber_clipping_mask_limited.height = drawingAreaHeight;
var chamber_clipping_mask_limited_ctx = chamber_clipping_mask_limited.getContext("2d");
//chamber_clipping_mask_limited_ctx.clearRect(0,0,chamber_clipping_mask_limited.width,chamber_clipping_mask_limited.height);

var chamber_clipping_mask_brush_limited = document.createElement("canvas");
//chamber_clipping_mask_brush_limited.width = 1;
//chamber_clipping_mask_brush_limited.height = 1;
var chamber_clipping_mask_brush_limited_ctx = chamber_clipping_mask_brush_limited.getContext("2d");
//chamber_clipping_mask_brush_limited_ctx.clearRect(0,0,chamber_clipping_mask_brush_limited.width,chamber_clipping_mask_brush_limited.height);

//canvas var to help making brush icons, stores brush tip sample
//then image is created from this canvas for display
var brushTipSample = document.createElement("canvas");
var brushTipSample_ctx = brushTipSample.getContext("2d");
brushTipSample.width = 100;
brushTipSample.height = 100;
//brushTipSample_ctx.clearRect(0,0,brushTipSample.width,brushTipSample.height);

//GLOBAL VARS DEFINE HERE --------------------------------------
var fullscreen_state = false;

//general folder
var gf = new bookKeeper();
gf.add(new layer("Background"));
gf.contents[0].fill("white");
gf.contents[0].updateView();
layer_counter++;
gf.add(new layer("Layer "+layer_counter));
layer_counter++;
gf.add(new layer("Layer "+layer_counter));

gf.updateIdIndexMap();
gf.updateClipMap();
//layer_counter++;
var current_folder = null;//reference to folder that current layer is in.  ex: bookKeeper.pos
var selected_layer_folder = null;

var selected_layer = null;//user selected layer reference
var selected_layer_i = 0;
var selected_layer_multi = [];

var spree = new spreeLayer();

var current_brush = false;

var bay_keeper = new bayKeeper();



//GLOBAL VARS DEFINE HERE END ---------------------------------

//event coordinates are read and processed -> 
//brushMark/brushMarknostop -> 
//RunBrushOnCanvas -> drawBrush -> stackLiveViewBrush
function RunBrushOnCanvas(brush,xyp){
//abstraction for drawing brush with set features
	
	//determining which history line to notify about target area
	let history_line = null;
	if(selected_layer.target == "layer"){
		history_line = history_keeper.lines.spree;
	}else{
		history_line = history_keeper.lines.mask;
	}
	//
	const tip_data = [0,0,0,0];//[x,y,w,h]
	//scatter count effect
	let count = brush.scatter_count;
	let count_jitter = brush.scatter_count_jitter;
	if(count > 1 || count_jitter > 0){
		
		if(count_jitter > 0){
			count -= Math.floor(Math.random()*(count_jitter+1));
		}
		
		for(let i=0; i<count; ++i){
			drawBrush(brush,xyp, tip_data);
			stackLiveViewBrush(tip_data);
			//
			history_line.notifyTargetAreaRect(tip_data[0],tip_data[1], tip_data[0]+tip_data[2], tip_data[1]+tip_data[3]);
		}
		
	}else{
		drawBrush(brush,xyp, tip_data);
		stackLiveViewBrush(tip_data);
		//
		history_line.notifyTargetAreaRect(tip_data[0],tip_data[1], tip_data[0]+tip_data[2], tip_data[1]+tip_data[3]);
	}

}
//----------put down brush function
function drawBrush(brush,xyp, tip_data){

	var ex = Math.floor(xyp[0]);
	var ey = Math.floor(xyp[1]);
	var ed = xyp[2];//direction
	var ep = xyp[3];//pressure
	var b_tip_size = brush.size;
	var tip_angle = 0.0;
	var tip_scaleX = 1.0;
	var tip_scaleY = 1.0;
	var tip_roundness = 1.0;
	
	var sm = selection_module;
	var selection_active = sm.selection_active;


	//Pen pressure Size
	if(brush.sizePressureEnabled){
		b_tip_size = Math.max(1 , Math.ceil(current_bay.size*brush.sizePressureMinDiameter+((current_bay.size-current_bay.size*brush.sizePressureMinDiameter)*ep))  );
	}
	//Scatter Size jitter
	var tip_size_mod = b_tip_size;
	if(brush.scatter_size_jitter < 1.0){
		tip_size_mod = Math.max(1 , Math.floor(b_tip_size * (1 - Math.random()*(1 - brush.scatter_size_jitter))) );
	}
	
	if(tip_size_mod != brush.tip_size){
		//(!) nominal size change / only tip print gets changed, 
		//canvas/brush.size stays the same
		brush.setSize( tip_size_mod , true);
	}
	//
	
	
	var flow = current_bay.flow;
	//Pen pressure Flow
	if(brush.flowPressureEnabled){
		flow = flow*ep;
	}
	
	//Roundness jitter
	if(brush.roundness_jitter < 1.0)tip_roundness = (1 - Math.random()*(1-brush.roundness_jitter));
	
	//
	var w = brush.size;
	var h = brush.size;
	//chamber_ctx.globalCompositeOperation = "source-over";
	let chamber_composite = "source-over";
	let chamber_alpha = 1;
	//Apply tip modifications if applicable - using tip mediator
	
	if( brush.directionEnabled ||
		brush.angle_jitter > 0 ||
		brush.flip_x_jitter ||
		brush.flip_y_jitter ||
		tip_roundness != 1.0 ){
	
	//if(brush.performance.doTransform){
		//
		let b_rot_size = Math.round(brush.size*1.414);
		w = b_rot_size;
		h = b_rot_size;
		//
		//Direction
		if(brush.directionEnabled){
			tip_angle += ed;
		}
		//
		//Orientation/Angle jitter
		if(brush.angle_jitter > 0){
			tip_angle += ( Math.floor(Math.random()*(brush.angle_jitter*10*10+1))/10/10 - (brush.angle_jitter/2)) * Math.PI/180;
		}
		//
		//Flip x/y jitter
		//1 or -1 at random if flip jitter is enabled
		if(brush.flip_x_jitter)tip_scaleX = 1 - 2*Math.round(Math.random())*brush.flip_x_jitter;
		if(brush.flip_y_jitter)tip_scaleY = 1 - 2*Math.round(Math.random())*brush.flip_y_jitter;
		
		//set chamber dimensions to brush size
		if(chamber.width != w){
			chamber.width = w;
			chamber.height = h;
			chamber_mask_mediator.width = w;
			chamber_mask_mediator.height = h;
		}
		
		chamber_ctx.clearRect(0,0,w,h);
		
		chamber_ctx.translate(w/2,h/2);
		//Rotate
		if(tip_angle != 0){
			
			chamber_ctx.rotate(tip_angle);
		}
		//Roundness, scale x or y
		if(tip_roundness < 1){
			if(Math.random() < 0.5){
				tip_scaleX = tip_scaleX * tip_roundness;
			}else{
				tip_scaleY = tip_scaleY * tip_roundness;
			}
		}
		//Scale
		if(tip_scaleX + tip_scaleY != 2){
			chamber_ctx.scale(tip_scaleX, tip_scaleY);
		}
		//
		//note: order is important
		//in this order of translate and draw x y - when scale flips signs it add the right way
		//similarly without scale it undo translate
		chamber_ctx.drawImage(brush.c,-brush.r,-brush.r);
		
		chamber_ctx.setTransform(1, 0, 0, 1, 0, 0);
	}else{
		//set chamber dimensions to brush size
		if(chamber.width != w){
			chamber.width = w;
			chamber.height = h;
			chamber_mask_mediator.width = w;
			chamber_mask_mediator.height = h;
		}
		chamber_ctx.clearRect(0,0,w,h);
		chamber_ctx.drawImage(brush.c,0,0);
	}
	//
	
	
	if(brush.scatter_distance > 0){
		//radius scatter
		let scatter_radius_angle = Math.random()* 2*Math.PI;
		let scatter_radius = Math.random()* b_tip_size/2 * brush.scatter_distance;
		ex += Math.round( Math.cos(scatter_radius_angle) * scatter_radius );
		ey += Math.round( Math.sin(scatter_radius_angle) * scatter_radius );
		
		//square scatter
		//ex += Math.round( (Math.random()*b_tip_size * brush.scatter_distance) - (b_tip_size/2 * brush.scatter_distance) );
		//ey += Math.round( (Math.random()*b_tip_size * brush.scatter_distance) - (b_tip_size/2 * brush.scatter_distance) );
	}
	

	//get coordinates of brush region
	var brush_coordinateX = Math.ceil(ex-w/2);// (-1 * canvas position X with offset) + (mouse event position) - (radius of brush size)
	var brush_coordinateY = Math.ceil(ey-h/2);
	
	//set tip data for easier transfer
	tip_data[0] = brush_coordinateX;
	tip_data[1] = brush_coordinateY;
	tip_data[2] = w;
	tip_data[3] = h;
	
	var to_chamberX = brush_coordinateX;//offsets the drawImage x,y such that chamber gets drawn only region under the brush
	var to_chamberY = brush_coordinateY;//perhaps faster than cutting out part of image with getImageData etc
	
	//make color white if drawing to mask
	if(selected_layer.target == "mask"){
		chamber_ctx.fillStyle = "white";
		chamber_ctx.globalCompositeOperation = "source-atop";
		chamber_ctx.fillRect(0,0, w,h);
		chamber_ctx.globalCompositeOperation = "source-over";
		
	}else if(brush.blend_assist){//no blending when mask is selected
		//blend brush support
		
		//chrome workaround
		chamber_blend_sample_ctx.clearRect(0,0,3,3);
		
		//using limited view instead
		chamber_blend_sample_ctx.drawImage(live_view_limited,-(ex-1),-(ey-1));
		
		/* 
		//old method, using globalCompositeOperation: 
		//(looping cached selection pixel data seems to perform faster)
		//boundary for blend assist to not pick up color from outside selection
		if(selection_active == true){
			chamber_blend_sample_ctx.globalCompositeOperation = "destination-in";
			chamber_blend_sample_ctx.drawImage(sm.selection,-(ex-1),-(ey-1));
			chamber_blend_sample_ctx.globalCompositeOperation = "source-over";
		}
		*/
		let area_data = chamber_blend_sample_ctx.getImageData(0,0,3,3).data;
		
		const blend_color = [0,0,0];
		var num_colors_picked = 9;
		
		//boundary for blend assist to not pick up color from outside selection
		if(selection_active == true){
			
			let selection_data = sm.selectionPixelData;
			let doc_w = drawingAreaWidth;
			let doc_h = drawingAreaHeight;
			let blend_x = 0;
			let blend_y = 0;
			let selection_i = 0;
			let bdi = 0;
			//loop through region both in cached selection image data and in blend sample
			for(blend_y=ey-1; blend_y<ey-1+3; ++blend_y){
				
				for(blend_x=ex-1; blend_x<ex-1+3; ++blend_x){
					
					selection_i = (blend_y*doc_w + blend_x)*4;
					if( (blend_x+1) * (blend_x - doc_w) < 0 &&//x and y range check using quadratic
						(blend_y+1) * (blend_y - doc_h) < 0 &&
						selection_data[selection_i+3] > 0 &&
						area_data[bdi+3] > 0){
						blend_color[0] += area_data[bdi];
						blend_color[1] += area_data[bdi+1];
						blend_color[2] += area_data[bdi+2];
					}else{
						num_colors_picked--;
					}
					
					bdi+=4;
				}
			
			}
			
		}else{
			for(let bdi=0;bdi<36;bdi+=4){
				if(area_data[bdi+3] > 0){
					blend_color[0] += area_data[bdi];
					blend_color[1] += area_data[bdi+1];
					blend_color[2] += area_data[bdi+2];
				}else{
					num_colors_picked--;
				}
			}
		
		}
		
		
		if(num_colors_picked > 0){
			
			blend_color[0] = Math.round(blend_color[0]/num_colors_picked);
			blend_color[1] = Math.round(blend_color[1]/num_colors_picked);
			blend_color[2] = Math.round(blend_color[2]/num_colors_picked);
			
			//trailing mix blend clause
			if(brush.blend_trail_active == false){
				brush.blend_trail_active = true;
				brush.blend_mix[0] = blend_color[0];
				brush.blend_mix[1] = blend_color[1];
				brush.blend_mix[2] = blend_color[2];
			}else{
				//note: can do various ratios of color drag, not only 50:50
				blend_color[0] = Math.round( (blend_color[0]+brush.blend_mix[0]) / 2 );
				blend_color[1] = Math.round( (blend_color[1]+brush.blend_mix[1]) / 2 );
				blend_color[2] = Math.round( (blend_color[2]+brush.blend_mix[2]) / 2 );
				
				brush.blend_mix[0] = blend_color[0];
				brush.blend_mix[1] = blend_color[1];
				brush.blend_mix[2] = blend_color[2];
			}
			//
			
			
		}else{
			//in case no colors were sampled
			if(brush.blend_trail_active == false){
				//trail been empty so far, so no use it
				chamber_ctx.clearRect(0,0, w,h);
			}else{
				blend_color[0] = brush.blend_mix[0];
				blend_color[1] = brush.blend_mix[1];
				blend_color[2] = brush.blend_mix[2];
			}
		}
		
		chamber_ctx.globalCompositeOperation = "source-atop";
		//note: this way is much faster, than letting js handle array to string conversion
		chamber_ctx.fillStyle = "rgb("+blend_color[0]+","+blend_color[1]+","+blend_color[2]+")";
		chamber_ctx.fillRect(0,0,w,h);
		chamber_ctx.globalCompositeOperation = "source-over";
		
	}
	
	
	//COMBINE / PUT BRUSH on SPREE
	
	//deal with brush FLOW
	brush_mediator_flow_ctx.globalAlpha = flow;
	brush_mediator_flow_ctx.drawImage(chamber,brush_coordinateX,brush_coordinateY);
	
	//deal with brush OPACITY
	chamber_ctx.clearRect(0,0, w,h);
	chamber_ctx.globalAlpha = brush.opacity;
	if(chamber_composite != "source-over"){
		chamber_ctx.globalCompositeOperation = "source-over";
		chamber_composite = "source-over";
	}
	chamber_ctx.drawImage(brush_mediator_flow,to_chamberX,to_chamberY,w,h,0,0,w,h);
	chamber_ctx.globalAlpha = 1;

	//apply selection mask
	if(selection_active == true){
		chamber_ctx.globalCompositeOperation = "destination-in";
		chamber_composite = "destination-in";
		chamber_ctx.drawImage(sm.selection, to_chamberX,to_chamberY, w,h, 0,0, w,h);
		//chamber_ctx.globalCompositeOperation = "source-over";
	}
	
	
	//draw to mediator
	brush_mediator_opacity_ctx.clearRect(brush_coordinateX,brush_coordinateY,w,h);
	brush_mediator_opacity_ctx.drawImage(chamber,brush_coordinateX,brush_coordinateY);
	
	//draw to target through chamber
	chamber_ctx.clearRect(0,0,w,h);
	if(chamber_composite != "source-over"){
		chamber_ctx.globalCompositeOperation = "source-over";
		chamber_composite = "source-over";
	}
	chamber_ctx.drawImage(spree.c,to_chamberX,to_chamberY,w,h,0,0,w,h);
	
	
	//support for brush spree eraser
	if(spree_mode == 1){
		chamber_ctx.globalCompositeOperation = "destination-out";
		chamber_composite = "destination-out";
		chamber_ctx.drawImage(brush_mediator_opacity,to_chamberX,to_chamberY,w,h,0,0,w,h);
		//chamber_ctx.globalCompositeOperation = "source-over";
	}else{
		//just regular draw
		if(chamber_composite != "source-over"){
			chamber_ctx.globalCompositeOperation = "source-over";
			chamber_composite = "source-over";
		}
		chamber_ctx.drawImage(brush_mediator_opacity,to_chamberX,to_chamberY,w,h,0,0,w,h);
	}
	//
	
	//deal with drawing to mask
	if(selected_layer.target == "mask"){
		//check and draw directly into mask if mask is the target
		chamber_mask_mediator_ctx.clearRect(0,0,w,h);
		chamber_mask_mediator_ctx.drawImage(selected_layer.mask,to_chamberX,to_chamberY,w,h,0,0,w,h);
		
		let chamber_mask_composite = "source-over";
		if(current_tool == "eraser_tool"){
			chamber_mask_mediator_ctx.globalCompositeOperation = "destination-out";
			chamber_mask_composite = "destination-out";
		}
		
		chamber_mask_mediator_ctx.drawImage(brush_mediator_opacity,to_chamberX,to_chamberY,w,h,0,0,w,h);//can add brush blending here by switching chamber_mode
		
		//snippet useful for making rgb version of drawing to mask
		//chamber_mask_mediator_ctx.globalCompositeOperation = "destination-over";
		//chamber_mask_mediator_ctx.fillRect(0,0, chamber_mask_mediator.width,chamber_mask_mediator.height);
		//colorToAlphaWhitechamber_mask_mediator,chamber_mask_mediator_ctx);
		
		if(chamber_mask_composite != "source-over")
		chamber_mask_mediator_ctx.globalCompositeOperation = "source-over";
		
		//clean up mediators because no need for their persistence
		//brush_mediator_opacity_ctx.clearRect(brush_coordinateX,brush_coordinateY,w,h);
		//brush_mediator_flow_ctx.clearRect(brush_coordinateX,brush_coordinateY,w,h);
	}else{
		//drawing to spree
		spree.view_ctx.clearRect(brush_coordinateX,brush_coordinateY,w,h);
		spree.view_ctx.drawImage(chamber,brush_coordinateX,brush_coordinateY);
		//now spree.view is ready to be stacked into layer.view
	}
	
	
	if(chamber_composite != "source-over"){
		chamber_ctx.globalCompositeOperation = "source-over";
		chamber_composite = "source-over";
	}
	chamber_ctx.clearRect(0,0,w,h);
	//update layer.view for stacking in live_view
	chamber_ctx.drawImage(selected_layer.c,to_chamberX,to_chamberY,w,h,0,0,w,h);
	//support for layer eraser
	if(current_tool == "eraser_tool"){
		chamber_ctx.globalCompositeOperation = "destination-out";
		chamber_composite = "destination-out";
	}else{
		if(chamber_composite != "source-over"){
			chamber_ctx.globalCompositeOperation = "source-over";
			chamber_composite = "source-over";
		}
	}
	chamber_ctx.drawImage(spree.view,to_chamberX,to_chamberY,w,h,0,0,w,h);//can add brush blending here by switching chamber_mode

	//apply layer mask if enabled and exist
	if(selected_layer.mask_enabled && selected_layer.mask != null){
		chamber_ctx.globalCompositeOperation = "destination-in";
		chamber_composite = "destination-in";
		
		if(selected_layer.target == "mask"){
			chamber_ctx.drawImage(chamber_mask_mediator,0,0);
		}else{
			chamber_ctx.drawImage(selected_layer.mask,to_chamberX,to_chamberY,w,h,0,0,w,h);
		}
		
	}
	
	if(chamber_composite != "source-over")
	chamber_ctx.globalCompositeOperation = "source-over";
	//complete selected_layer.view by replacing region with chamber
	selected_layer.view_ctx.clearRect(brush_coordinateX,brush_coordinateY,w,h);
	selected_layer.view_ctx.drawImage(chamber,brush_coordinateX,brush_coordinateY);
}
//------------------------

//Stack live_view through chamber, region stack

function stackLiveViewBrush(tip_data){
	
	var brush_coordinateX = tip_data[0];
	var brush_coordinateY = tip_data[1];
	var w = tip_data[2];
	var h = tip_data[3];
	//var w = chamber.width;
	//var h = chamber.height;
	
	var to_chamberX = brush_coordinateX;//offsets the drawImage x,y such that chamber gets drawn only region under the brush
	var to_chamberY = brush_coordinateY;//perhaps faster than cutting out part of image with getImageData etc
	
	
	//set chamber dimensions to brush size
	if(chamber_clipping_mask_brush.width != w){
		//set chamber dimensions to live_view 
		chamber_clipping_mask_brush.width = w;
		chamber_clipping_mask_brush.height = h;
		//
		chamber_clipping_mask_brush_limited.width = w;
		chamber_clipping_mask_brush_limited.height = h;
	}
	chamber_ctx.clearRect(0,0,w,h);
	//chamber_ctx.globalCompositeOperation = "source-over";
	let chamber_composite = "source-over";
	chamber_clipping_mask_brush_ctx.clearRect(0,0,w,h);
	//chamber_clipping_mask_brush_ctx.globalCompositeOperation = "source-over";
	chamber_clipping_mask_composite = "source-over";
	
	var limited_view_stacked = false;//flag to run once live view limited stacking
	chamber_clipping_mask_brush_limited_ctx.clearRect(0,0,w,h);
	//start stacking
	
	var use_ctx = chamber_ctx;
	let use_composite = "source-over";
	let use_alpha = 1;
	var gf_pos=0;
	let gf_contents = gf.contents;
	let gf_contents_len = gf_contents.length;
	var clip = -1;
	var current_obj = null;
	var current_clippingMask = null;
	while(gf_pos < gf_contents_len){
		
		current_obj = gf_contents[gf_pos];
		use_composite = "source-over";
		
		if(current_obj.clip > 0){
			//check clipping mask visibility
			if(current_obj.visible){
			
				clip = current_obj.clip;
				current_clippingMask = current_obj;
				
				use_ctx = chamber_clipping_mask_brush_ctx;
				use_ctx.clearRect(0,0,w,h);
				if(use_composite != "source-over")
				use_ctx.globalCompositeOperation = "source-over";
				
				if(selected_layer_i == gf_pos){
					use_ctx.drawImage(current_obj.view,to_chamberX,to_chamberY,w,h,0,0,w,h);
					makeCanvasContentOpaque(chamber_clipping_mask_brush,chamber_clipping_mask_brush_ctx);
					current_obj.clippingMask_ctx.clearRect(brush_coordinateX,brush_coordinateY,w,h);
					current_obj.clippingMask_ctx.drawImage(chamber_clipping_mask_brush,brush_coordinateX,brush_coordinateY);
				}else{
					use_ctx.drawImage(current_obj.clippingMask,to_chamberX,to_chamberY,w,h,0,0,w,h);
				}
				
			}else{
			//skip if not visible
				gf_pos+=current_obj.clip;
			}
		}else{
			if(current_obj.visible){
				
				if(use_composite != current_obj.blending){
					use_ctx.globalCompositeOperation = current_obj.blending;
					use_composite = current_obj.blending;
				}
				
				if(use_alpha != current_obj.opacity){
					use_ctx.globalAlpha = current_obj.opacity;
					use_alpha = current_obj.opacity;
				}
				
				use_ctx.drawImage(current_obj.view,to_chamberX,to_chamberY,w,h,0,0,w,h);
				
				if(use_alpha != 1){
					use_ctx.globalAlpha = 1.0;
					use_alpha = 1;
				}
				
				if(use_composite != "source-over"){
					use_ctx.globalCompositeOperation = "source-over";
					use_composite = "source-over";
				}
				
			}
		}
		
		//end of clipping mask, apply and draw to other chamber
		
		if(clip == 0){
		
			chamber_clipping_mask_brush_ctx.globalCompositeOperation = "destination-in";
			chamber_clipping_mask_brush_ctx.drawImage(current_clippingMask.view,to_chamberX,to_chamberY,w,h,0,0,w,h);
			chamber_clipping_mask_brush_ctx.globalCompositeOperation = "source-over";

			use_ctx = chamber_ctx;
			use_composite = "source-over";
			
			use_ctx.globalAlpha = current_clippingMask.opacity;
			if(use_composite != current_clippingMask.blending){
				use_ctx.globalCompositeOperation = current_clippingMask.blending;
				use_composite = current_clippingMask.blending;
			}
			use_ctx.drawImage(chamber_clipping_mask_brush,0,0);
			use_ctx.globalAlpha = 1.0;
			
			if(use_composite != "source-over"){
				use_ctx.globalCompositeOperation = "source-over";
				use_composite = "source-over";
			}
			
			current_clippingMask = null;
			
		}
		
		//limited view stack
		if(limited_view_stacked == false && selected_layer_i <= gf_pos){
		
			live_view_limited_ctx.clearRect(brush_coordinateX,brush_coordinateY,w,h);
			live_view_limited_ctx.drawImage(chamber,brush_coordinateX,brush_coordinateY);
			
			//do clipping mask for limited view
			if(clip > 0){
				chamber_clipping_mask_brush_limited_ctx.drawImage(chamber_clipping_mask_brush,0,0);
				
				chamber_clipping_mask_brush_limited_ctx.globalCompositeOperation = "destination-in";
				chamber_clipping_mask_brush_limited_ctx.drawImage(current_clippingMask.view,to_chamberX,to_chamberY,w,h,0,0,w,h);
				chamber_clipping_mask_brush_limited_ctx.globalCompositeOperation = "source-over";
				
				live_view_limited_ctx.globalAlpha = current_clippingMask.opacity;
				live_view_limited_ctx.globalCompositeOperation = current_clippingMask.blending;
				live_view_limited_ctx.drawImage(chamber_clipping_mask_brush_limited,brush_coordinateX,brush_coordinateY);
				live_view_limited_ctx.globalAlpha = 1.0;
				live_view_limited_ctx.globalCompositeOperation = "source-over";
			}
			limited_view_stacked = true;
		}
		//
		
		gf_pos++;
		clip--;
		
	}
	

	//complete live_view by replacing region with chamber
	live_view_ctx.clearRect(brush_coordinateX,brush_coordinateY,w,h);
	live_view_ctx.drawImage(chamber,brush_coordinateX,brush_coordinateY);
	
	//update tiny_preview
	tiny_preview_ctx.clearRect(brush_coordinateX,brush_coordinateY,w,h);
	tiny_preview_ctx.drawImage(chamber,brush_coordinateX,brush_coordinateY);

}


function makeCanvasContentOpaque(c,ctx){
	const w = c.width;
	const h = c.height;
	var img = ctx.getImageData(0,0,w,h);
	var imgData = img.data;
	const imgData_len = imgData.length;
	var pixel_alpha;
	for (let i = 3; i < imgData_len; i += 4 ) {
		pixel_alpha = imgData[i];
		if ( pixel_alpha > 0 && pixel_alpha < 255 ) {
			imgData[i] = 255;
		}
	}
	ctx.putImageData(img,0,0);
}


function stackLiveView(){

	var to_chamberX = 0;//offsets the drawImage x,y such that chamber gets drawn only region under the brush
	var to_chamberY = 0;//perhaps faster than cutting out part of image with getImageData etc
	
	//set chamber dimensions to live_view 
	var w = live_view.width;
	var h = live_view.height;
	
	if( chamber_live_view.width != w ||
		chamber_live_view.height != h ||
		chamber_clipping_mask.width != w ||
		chamber_clipping_mask.height != h ){
		
		chamber_live_view.width = w;
		chamber_live_view.height = h;
		chamber_clipping_mask.width = w;
		chamber_clipping_mask.height = h;
		//
		live_view_limited.width = w;
		live_view_limited.height = h;
		chamber_clipping_mask_limited.width = w;
		chamber_clipping_mask_limited.height = h;
	}

	
	chamber_live_view_ctx.clearRect(0,0,w,h);
	chamber_live_view_ctx.globalCompositeOperation = "source-over";
	chamber_clipping_mask_ctx.clearRect(0,0,w,h);
	chamber_clipping_mask_ctx.globalCompositeOperation = "source-over";
	
	var limited_view_stacked = false;//flag to run once live view limited stacking
	chamber_clipping_mask_limited_ctx.clearRect(0,0, w,h);
	//start stacking
	
	var use_ctx = chamber_live_view_ctx;
	var gf_pos=0;
	let gf_contents = gf.contents;
	let gf_contents_len = gf_contents.length;
	var clip = -1;
	var current_clippingMask = null;
	var current_obj = null;
	while(gf_pos < gf_contents_len){
		
		current_obj = gf_contents[gf_pos];
		
		if(current_obj.clip > 0){
			//check clipping mask visibility
			if(current_obj.visible){

				clip = current_obj.clip;
				current_clippingMask = current_obj;
				use_ctx = chamber_clipping_mask_ctx;
				use_ctx.clearRect(0,0,w,h);
				
				use_ctx.globalCompositeOperation = "source-over";
				use_ctx.drawImage(current_obj.clippingMask,to_chamberX,to_chamberY);
				
			}else{
			//skip if not visible
				gf_pos+=current_obj.clip;
			}
		}else{
			
			if(current_obj.visible){
				use_ctx.globalCompositeOperation = current_obj.blending;
				use_ctx.globalAlpha = current_obj.opacity;
				use_ctx.drawImage(current_obj.view,to_chamberX,to_chamberY);
				use_ctx.globalAlpha = 1.0;
				use_ctx.globalCompositeOperation = "source-over";
			}
		}
		
		//end of clipping mask, apply and draw to other chamber
		if(clip == 0){
			chamber_clipping_mask_ctx.globalCompositeOperation = "destination-in";
			chamber_clipping_mask_ctx.drawImage(current_clippingMask.view,to_chamberX,to_chamberY);
			chamber_clipping_mask_ctx.globalCompositeOperation = "source-over";
			
			use_ctx = chamber_live_view_ctx;
			
			use_ctx.globalAlpha = current_clippingMask.opacity;
			use_ctx.globalCompositeOperation = current_clippingMask.blending;
			use_ctx.drawImage(chamber_clipping_mask,0,0);
			use_ctx.globalAlpha = 1.0;
			use_ctx.globalCompositeOperation = "source-over";
			
			current_clippingMask = null;
			
		}
		
		//limited view stack
		if(limited_view_stacked == false && selected_layer_i <= gf_pos){
			live_view_limited_ctx.clearRect(0,0, w,h);
			live_view_limited_ctx.drawImage(chamber_live_view, to_chamberX,to_chamberY);
			
			//do clipping mask for limited view
			if(clip > 0){
				chamber_clipping_mask_limited_ctx.drawImage(chamber_clipping_mask,to_chamberX,to_chamberY);
				
				chamber_clipping_mask_limited_ctx.globalCompositeOperation = "destination-in";
				chamber_clipping_mask_limited_ctx.drawImage(current_clippingMask.view,to_chamberX,to_chamberY);
				chamber_clipping_mask_limited_ctx.globalCompositeOperation = "source-over";
				
				live_view_limited_ctx.globalAlpha = current_clippingMask.opacity;
				live_view_limited_ctx.globalCompositeOperation = current_clippingMask.blending;
				live_view_limited_ctx.drawImage(chamber_clipping_mask_limited,to_chamberX,to_chamberY);
				live_view_limited_ctx.globalAlpha = 1.0;
				live_view_limited_ctx.globalCompositeOperation = "source-over";
			}
			limited_view_stacked = true;
		}
		//
		
		gf_pos++;
		clip--;
		
	}
	

	//complete live_view by replacing region with chamber
	live_view_ctx.clearRect(0,0,w,h);
	live_view_ctx.drawImage(chamber_live_view,0,0);
	
	//update tiny_preview
	tiny_preview_ctx.clearRect(0,0, tiny_preview.width,tiny_preview.height);
	tiny_preview_ctx.drawImage(live_view,0,0);

}


//TODO see if there is anything else needed here, for example deal with folder selection
//also mask selection
//select layer function
function selectLayer(obj_i,target){//mask selection true/false
	selected_layer_i = Math.max(0, Math.min(gf.contents.length-1,obj_i));
	selected_layer = gf.contents[selected_layer_i];
	
	if(target != null){
		selected_layer.setTarget(target);
	}
	
	//transform controls correction
	if(current_tool == "move_tool"){
		move_module.updateUIConfigMenu();
		move_module.updateUITransformControls();
	}
}

//-----

//adding clipping mask / layer object clipping

function clipSelectedLayer(){
	
	if(selected_layer.clip > 0 || selected_layer_i == 0)return;
	
	var found = false;
	var nearest_i = selected_layer_i-1;
	var nearest = gf.contents[nearest_i];
	
	//special case when a new layer is added right after the clipping object
	if(nearest.clip > 0){
		nearest.clip++;
		return;
	}
	var c = null;
	for(var i=nearest_i;i>-1;i--){
		
		c = gf.contents[i];
		if(c.clip > 0){
			if(nearest_i-i <= c.clip){
				c.clip++;
				found = true;
				break;
			}else{
				nearest.addClippingMask();
				found = true;
				break;
			}
		}
	
	}
	if(!found){
		nearest.addClippingMask();
	}
	return;
}

function clipSingleLayer(obj,obj_i){
	
	if(obj.clip > 0 || obj_i == 0)return;
	
	var found = false;
	var nearest_i = obj_i-1;
	var nearest = gf.contents[nearest_i];

	//special case when a new layer is added right after the clipping object
	if(nearest.clip > 0){
		nearest.clip++;
		return;
	}
	var c = null;
	for(var i=nearest_i;i>-1;i--){
		
		c = gf.contents[i];
		if(c.clip > 0){
			if(nearest_i-i <= c.clip){
				c.clip++;
				found = true;
				break;
			}else{
				nearest.addClippingMask();
				found = true;
				break;
			}
		}
	
	}
	if(!found){
		nearest.addClippingMask();
	}
	return;
}

//unclipping mask / layer object unclipping, including the object itself completely
function unclipSelectedLayer(){
	if(selected_layer.clip > 0){
		selected_layer.clip = 0;
		return;
	}
	if(selected_layer_i == 0){
		return;
	}
	
	var nearest_i = selected_layer_i-1;
	var nearest = gf.contents[nearest_i];
	var c = null;
	for(var i=nearest_i;i>-1;i--){
		
		c = gf.contents[i];
		if(c.clip > 0){
			if(nearest_i-i <= c.clip){
				c.clip = nearest_i-i;
				break;
			}
		}
	
	}
	return;
}

//on layer deletion unclip only layer
function unclipSingleLayer(obj,obj_i){
	if(obj.clip > 0){
		obj.clip = 0;
		return;
	}
	if(obj_i == 0){
		return;
	}
	
	var nearest_i = obj_i-1;
	var nearest = gf.contents[nearest_i];
	var c = null;
	for(var i=nearest_i;i>-1;i--){
		
		c = gf.contents[i];
		if(c.clip > 0){
			if(nearest_i-i <= c.clip){
				c.clip--;
				break;
			}
		}
	
	}

	return;
}

function clipCheckLayer(obj,obj_i){
	var clipped = false;
	if(obj.clip > 0){
		return [true,obj];
	}
	if(obj_i == 0){
		return [false,null];
	}
	
	var nearest_i = obj_i-1;
	var c = null;
	var nearest = gf.contents[nearest_i];
	for(var i=nearest_i;i>-1;i--){
		
		c = gf.contents[i];
		if(c.clip > 0){
			if(nearest_i-i < c.clip){
				clipped = true;
				break;
			}
		}
	
	}
	
	if(!clipped)c=null;
	
	return [clipped,c];
}

function unclipMultiLayer(index_list){
	var current = null;
	var clip_counter = 0;
	var clip_obj = null;
	var clip_num = -1;
	//console.log(index_list);
	var i = 0;
	var j = 0;
	while(i<gf.contents.length && j<index_list.length){
		current = gf.contents[i];
		
		if(current.clip > 0){
			if(index_list[j] == i){
			//special case when clipper is selected
				current.clip = 0;
			}else{
				clip_obj = gf.contents[i];
				clip_counter = 0;
				clip_num = clip_obj.clip;
			}
		}
		
		if(index_list[j] == i){
			
			j++;
			
			if(clip_counter <= clip_num){
				
				clip_obj.clip = clip_counter-1;
				clip_num = clip_obj.clip;
			
			}
			
		}
		i++;
		clip_counter++;
	}
}

function unclipMultiLayerCount(index_list){
//decrement clip object if clipped,
	var current = null;
	var clip_obj_array = [];
	for(var i=0;i<index_list.length;i++){
		current = gf.contents[index_list[i]];
		if(current.clip > 0){
			current.clip = 0;
		}else{
			clip_obj_array.push( clipCheckLayer( current, index_list[i] ) );
		}
	}
	
	for(var i=0;i<clip_obj_array.length;i++){
		if(clip_obj_array[i][0] == true){
			clip_obj_array[i][1].clip--;
		}
	}
	
}

//

/////////////////////////////////////////////some general feature functions

function convertUnitsPxCmIn(num, u_in, u_out, dpi = 300){
	
	if(u_in == u_out)return num;
	//cascading approach
	var result = num;
	if(u_in == "px"){
		
		//px to inch
		result = num / dpi;
		
		if(u_out == "cm"){
		//px to cm
			result = result * 2.54;
		}
		
	}else if(u_in == "in"){
		
		if(u_out == "cm"){
		//inch to cm
			result = num * 2.54;
		}else{
		//inch to px
			result = Math.round(num * dpi);
		}
		
	}else if(u_in == "cm"){
		//cm to inch
		result = num / 2.54;
		
		if(u_out == "px"){
		//cm to px
			result = Math.round(result * dpi);
		}
	}
	
	return result;
}

function sanitizeNumber(val){
	return val.replaceAll(/[^0-9.]/g,'');
}

function sanitizeInt(val){
	return val.replaceAll(/[^0-9]/g,'');
}

const docConfigPresetsGeneral = [
["Screen", 
["4K UHD",3840,2160,"px",72],["QHD / 1440p",2560,1440,"px",72],
["Full HD / 1080p",1920,1080,"px",72],["HD / 720p",1280,720,"px",72],
["VGA / 480p",640,480,"px",72]],
//
["Square",
["2000 pixel grid",2000,2000,"px",300],["3000 pixel grid",3000,3000,"px",300],
["4000 pixel grid",4000,4000,"px",300],["800 pixel grid",800,800,"px",300],
["512 pixel grid",512,512,"px",300]],
//
["Print",
["Tabloid",11,17,"in",300],["A3",29.7,42,"cm",300],["A4",21,29.7,"cm",300],
["Letter",8.5,11,"in",300],["Poster",18,24,"in",300],["Legal",8.5,14,"in",300],
["Postcard",4,6,"in",300],["A6",10.5,14.8,"cm",300],["Business Card",3.5,2,"in",300],
["Large Picture",20,16,"in",300]],
//
["Photo",
["Photo",10,15,"cm",300],["Photo",15,20,"cm",300],["Photo",20,30,"cm",300],
["4R",4,6,"in",300],["5R",5,7,"in",300],["6R",6,8,"in",300],["8R",8,10,"in",300],
["S8R",8,12,"in",300],["3 x 2 HQ",3,2,"in",1200],["4 x 3 HQ",4,3,"in",1200]],
//
["Sprite",
["8",8,8,"px",72],["16",16,16,"px",72],["24",24,24,"px",72],
["32",32,32,"px",72],["64",64,64,"px",72]]
//

];

function docConfigKeeper(docConfigPresets){
//assists in document creation, handles logistics / meta data etc.
	var dck = this;
	
	//structure: [["matching preset name",w,h,units,dpi],["",w,h,units,dpi],...];
	dck.prev_presets = [];//previous / recent presets
	dck.prev_presets_capacity = 5;
	
	//structure: [["group name", ["preset name",w,h,units,dpi],["preset name",w,h,units,dpi],...] 
	//			  ["group name", ["preset name",w,h,units,dpi],["preset name",w,h,units,dpi],...] ];
	//presets are groupped by category and index 0 is group name
	dck.presets = docConfigPresets;
	
	dck.presetIndexMap = [];
	dck.selected_preset_i = 0;
	
	//config menu / create new document
	dck.config = {};
	dck.config.name = 'Untitled-1';
	dck.config.w = 2560;
	dck.config.h = 1440;
	dck.config.units = "px";
	dck.config.dpi = 300;
	
	
	UI.doc_new_name.value = dck.config.name;
}

docConfigKeeper.prototype = {

	setConfig : function(option,val){
	//generic internal for any config
		this.config[option] = val;
	},
	
	getConfig : function(option){
		return this.config[option];
	},
	
	updateUIDocConfig : function(){
		var dck = this;
		UI.doc_new_name.value = dck.config.name;
		UI.doc_new_width.value = dck.config.w;
		UI.doc_new_height.value = dck.config.h;
		UI["doc_new_units_"+dck.config.units].checked = true;
		UI.doc_new_dpi.value = dck.config.dpi;
		//
		UI.doc_new_name.value = dck.config.name;
		//
		dck.updateUIOrientation();
	},
	
	updateUIOrientation : function(){
		if(this.config.w < this.config.h){
			
			if(UI.doc_new_orientation_portrait.checked != true){
				UI.doc_new_orientation_portrait.checked = true;
			}
			
		}else if(UI.doc_new_orientation_landscape.checked != true){
			UI.doc_new_orientation_landscape.checked = true;
		}
	},
	
	setUnits : function(units){
		this.config.units = units;
	},
	
	getUnits : function(){
		return this.config.units;
	},
	
	setDPI : function(dpi){
		this.config.dpi = Math.max(1, dpi);
	},
	
	getDPI : function(){
		return this.config.dpi;
	},
	//
	selectPreset : function(preset_i){
		var dck = this;
		dck.selected_preset_i = preset_i;
		var preset = dck.presetIndexMap[preset_i];
		
		dck.config.w = preset[1];
		dck.config.h = preset[2];
		dck.config.units = preset[3];
		dck.config.dpi = preset[4];
	},
	
	addPrevPreset : function(){
	//adds current config as latest preset used
		var dck = this;
		
		var preset = ["",dck.config.w,dck.config.h, dck.config.units, dck.config.dpi];
		
		//remove prev presets from index map
		let prev_len = dck.prev_presets.length;
		dck.presetIndexMap.splice(-prev_len, prev_len);
		//
		
		//check presets to see if dimensions are known to get name
		var gen_preset;
		for(let i=0;i<dck.presetIndexMap.length;i++){
			gen_preset = dck.presetIndexMap[i];
			if(	(preset[3] == gen_preset[3])
				&& ( (preset[1] == gen_preset[1] && preset[2] == gen_preset[2])
					|| (preset[1] == gen_preset[2] && preset[2] == gen_preset[1]) )
				){
			//check units are same && dimensions match in either orientation
			//ppi does not matter for naming
				preset[0] = gen_preset[0];
				break;
			}
		}
		if(preset[0] == "" && preset[1] == preset[2] && preset[3] == "px"){
		//not found within presets but is a pixel grid
			preset[0] = preset[1] + " pixel grid";
		}

		//check if this preset already happens to be in prev presets
		let prev_preset;
		for(let i=0;i<dck.prev_presets.length;i++){
			
			prev_preset = dck.prev_presets[i];
			
			if( (prev_preset[3] == preset[3])
				&& ( (prev_preset[1] == preset[1] && prev_preset[2] == preset[2])
					|| (prev_preset[1] == preset[2] && prev_preset[2] == preset[1]) )
				&& prev_preset[4] == preset[4]){
			//check units match
			//check dimensions match in either orientation
			//check dpi match
			
				//kick out from spot
				dck.prev_presets.splice(i, 1);
			}
		}
		
		dck.prev_presets.unshift(preset);
		//check max capacity
		if(dck.prev_presets.length > dck.prev_presets_capacity){
			dck.prev_presets.pop();
		}
		
		//note: adding prev_presets back 
		//to presetIndexMap should happen in dck.updateUIPrevPresets
	},
	
	updateUIPrevPresets : function(){
	//adds prev_presets to presetIndexMap
	//stacks prev_presets in UI recent group
		var dck = this;
		
		var preset_field = UI.doc_new_presets_recent;
		var group_ui = dck.makeUIConfigPresetGroup("Recent");
		
		var preset_i = dck.presetIndexMap.length;
		var preset = null;
		for(let i=0;i<dck.prev_presets.length;i++){
			preset = dck.prev_presets[i];
			//
			group_ui.appendChild( dck.makeUIConfigPresetTile(preset, preset_i) );
			group_ui.append(" ");//spacing between tiles
			//
			dck.presetIndexMap.push(preset);
			preset_i++;
		}
		preset_field.innerHTML = '';
		preset_field.appendChild(group_ui);
		
	},
	
	makeUIConfigPresetTile : function(preset, preset_i){
		
		var elem = document.createElement('label');
		var m = [];
		
		m0 = document.createElement('input');
		m0.setAttribute("type", "radio");
		m0.setAttribute("name", "doc_new_presets_tile");
		m0.setAttribute("autocomplete", "off");
		m0.value = preset_i;
		m0.className = "hidden-toggler doc-new-presets-tile-btn";
		elem.appendChild(m0);
		//
		m1 = document.createElement('span');
		m1.className = "doc-new-presets-tile";
		elem.appendChild(m1);
		//
		m2 = document.createElement('span');
		m2.className = "doc-new-presets-tile-description";
		m1.appendChild(m2);
		//
		//Name
		m3 = document.createElement('span');
		m3.className = "doc-new-presets-tile-name";
		m3.textContent = preset[0];
		m2.appendChild(m3);
		//
		//Dimensions
		m4 = document.createElement('span');
		m4.className = "doc-new-presets-tile-dimensions";
		m4.textContent = preset[1] + " x " + preset[2];
		m2.appendChild(m4);
		//
		//units & dpi
		m5 = document.createElement('span');
		m5.className = "doc-new-presets-tile-units";
		m5.textContent = preset[3] + " @ " + preset[4] + " ppi";
		m2.appendChild(m5);
		
		return elem;
	},
	
	makeUIConfigPresetGroup : function(group_name){
		
		var elem = document.createElement('span');
		elem.className = "doc-new-presets-group";
		
		var m = document.createElement('span');
		m.className = "doc-new-presets-group-name";
		m.textContent = group_name;
		elem.appendChild(m);
		
		return elem;
	},
	
	prepareConfigPresets : function(){
	//parses previous and general config presets, 
	//sets presetIndexMap
	//stacks UI
	//
		var dck = this;
		
		var preset;
		var preset_i = 0;
		//
		var group_ui;
		var preset_field;
		//general presets
		preset_field = UI.doc_new_presets_general;
		preset_field.innerHTML = "";
		var group;
		var group_name;
		for(let i=0;i<dck.presets.length;i++){
			group = dck.presets[i];
			group_name = group[0];
			//
			group_ui = dck.makeUIConfigPresetGroup(group_name);
			//
			for(let j=1;j<group.length;j++){
				preset = group[j];
				//tile stacking
				group_ui.appendChild( dck.makeUIConfigPresetTile(preset, preset_i) );
				group_ui.append(" ");//spacing between tiles
				//
				dck.presetIndexMap.push(preset);
				preset_i++;
			}
			//
			preset_field.appendChild(group_ui);
		}
		
		
		preset_field = UI.doc_new_presets_recent;
		group_ui = dck.makeUIConfigPresetGroup("Recent");
		//previous presets
		for(let i=0;i<dck.prev_presets.length;i++){
			preset = dck.prev_presets[i];
			//UI stacking
			group_ui.appendChild( dck.makeUIConfigPresetTile(preset, preset_i) );
			group_ui.append(" ");//spacing between tiles
			//
			dck.presetIndexMap.push(preset);
			preset_i++;
		}
		
		preset_field.innerHTML = '';
		preset_field.appendChild(group_ui);
		
	},
	
	loadPrevPresets(config){
		var dck = this;
		dck.prev_presets = config;
		//
		if(dck.prev_presets.length > 0){
			let preset = dck.prev_presets[0];
			dck.config.w = preset[1];
			dck.config.h = preset[2];
			dck.config.units = preset[3];
			dck.config.dpi = preset[4];
		}
	},
	//
	openMenu : function(){
		hk.requestLock();
		this.config.name = "Untitled-1";
		UI.doc_new_name.value = this.config.name;
		showUIElement(UI.global_doc_new_menu_lock_screen);
		showUIElement(UI.doc_new);
	},
	
	closeMenu : function(){
		hk.requestUnlock();
		hideUIElement(UI.global_doc_new_menu_lock_screen,640);//slightly faster
		hideUIElement(UI.doc_new);
	}
}

doc_config_keeper = new docConfigKeeper(docConfigPresetsGeneral);


function makeNewDocument(doc_w,doc_h){
	drawingAreaWidth = doc_w;
	drawingAreaHeight = doc_h;
	
	//
	gf.contents = [];
	
	//
	resizeImage(doc_w,doc_h);
	
	//general folder
	layer_counter = 0;
	gf.add(new layer("Background"));
	gf.contents[0].fill("white");
	gf.contents[0].updateView();
	layer_counter++;
	gf.add(new layer("Layer "+layer_counter));
	layer_counter++;
	gf.add(new layer("Layer "+layer_counter));
	gf.updateIdIndexMap();
	gf.updateClipMap();
	gf.updateIdMaskMap();
	
	selectLayer(1,"layer");
	selected_layer_multi = [selected_layer_i];
	
	
	
	//history keeper
	history_keeper.init(51);
	history_keeper.store("snapshot",current_tool,toolset_mode,selected_layer_i);
	
	//
	canvas_view.zoomFit();
	canvas_view.makeCursor(current_tool,current_bay.size);
	//
	stackLayersUI();
	stackLiveView();
	selection_module.makeSelectionOutline();
	
	gf.stampOPID();
}


function generateProjectFile(){
//generates project file object
/*
p_file structure entries:
name : 				[layer name, ...]	//all layer names in order

layer_c : 			[ c URI, ... ] 		//all layers in order

mask : 		{ layer_index : mask URI } 	//only those that have mask

mask_disabled : 	[layer_index, ... ] //only those that have mask disabled
visibility_hidden : [layer_index, ... ] //only those that have visibility false

blending : 	{ layer_index : blend_mode }	//only those that have different from normal
opacity : 	{ layer_index : layer_opacity } //only those that have different from 100%
clip : 		{ layer_index : clip } 			//only those that are clipping objects

note: this structure allows for flexible addition of new attributes
note: required attributes are: name
*/
	var p_file = {};
	
	p_file.width = drawingAreaWidth;
	p_file.height = drawingAreaHeight;
	
	p_file.name = [];
	p_file.layer_c = [];
	
	p_file.mask = {};
	
	p_file.mask_disabled = [];
	p_file.visibility_hidden = [];
	
	p_file.blending = {};
	p_file.opacity = {};
	p_file.clip = {};
	
	var layer;
	for(var i=0;i<gf.contents.length;i++){
		layer = gf.contents[i];
		
		//name
		p_file.name.push(layer.name);
		
		//layer
		p_file.layer_c.push(layer.c.toDataURL());
		
		//mask
		if(layer.mask != null){
			p_file.mask[i] = layer.mask.toDataURL();
			
			//mask disabled
			if(layer.mask_enabled == false){
				p_file.mask_disabled.push(i);
			}
		}
		
		//visibility hidden
		if(layer.visible == false){
			p_file.visibility_hidden.push(i);
		}
		
		//blending
		if(layer.blending != "source-over"){
			p_file.blending[i] = layer.blending;
		}
		
		//opacity
		if(layer.opacity != 1.0){
			p_file.opacity[i] = layer.opacity;
		}
		
		//clip
		if(layer.clip > 0){
			p_file.clip[i] = layer.clip;
		}
		
	}
	
	return p_file;
}


async function loadProjectFile(p_file, f_name){
//reads and loads project file
	//meta data
	gf.proj_meta.name = f_name;
	//
	
	gf.contents = [];
	layer_counter = 0;
	var contents = gf.contents;
	
	//
	resizeImage(p_file.width,p_file.height);
	
	//flexible read of project file structure by loops for each attribute
	var layer_i;
	var i=0;
	var c_img;
	//make layers and set names
	for(i=0;i<p_file.name.length;i++){
		layer_counter++;
		contents.push(new layer(p_file.name[i]));
	}
	
	//intersect attributes of file and those that program can accept
	//can do fallthrough in cases if some attribute names will change in future
	var attr;
	for(attr in p_file){
	
		switch(attr){
			
			case "layer_c":
				//draw layer c
				for(i=0;i<p_file.layer_c.length;i++){
					c_img = new Image();
					c_img.src = p_file.layer_c[i];
					await c_img.decode();
					contents[i].ctx.drawImage(c_img,0,0);
				}
			break;
			//
			case "mask":
				//draw mask
				for(layer_i in p_file.mask){
					c_img = new Image();
					c_img.src = p_file.mask[layer_i];
					await c_img.decode();
					contents[layer_i].addMask(true);
					contents[layer_i].mask_ctx.drawImage(c_img,0,0);
				}
			break;
			//
			case "mask_disabled":
				//mask disabled
				for(i=0;i<p_file.mask_disabled.length;i++){
					contents[ p_file.mask_disabled[i] ].mask_enabled = false;
				}
			break;
			//
			case "visibility_hidden":
				//visibility hidden
				for(i=0;i<p_file.visibility_hidden.length;i++){
					contents[ p_file.visibility_hidden[i] ].visible = false;
				}
			break;
			//
			case "blending":
				//blending
				for(layer_i in p_file.blending){
					contents[layer_i].blending = p_file.blending[layer_i];
				}
			break;
			//
			case "opacity":
				//opacity
				for(layer_i in p_file.opacity){
					contents[layer_i].opacity = p_file.opacity[layer_i];
				}
			break;
			//
			case "clip":
				//clip
				for(layer_i in p_file.clip){
					contents[layer_i].addClippingMask();
					contents[layer_i].clip = p_file.clip[layer_i];
				}
			break;
			
		}//switch end
		
	}//intersect attr loop end
	
	//update layer view
	for(i=0;i<contents.length;i++){
		contents[i].updateView();
	}
	
	gf.updateIdIndexMap();
	gf.updateClipMap();
	gf.updateIdMaskMap();
	
	selectLayer(contents.length-1,"layer");
	selected_layer_multi = [selected_layer_i];
}

async function loadImageFile(img, f_name){
	//setup meta data
	gf.proj_meta.name = f_name;
	//
	gf.contents = [];
	layer_counter = 0;
	var contents = gf.contents;
	
	//
	resizeImage(img.width,img.height);
	
	//general folder
	layer_counter = 0;
	gf.add(new layer("Background"));
	gf.contents[0].fill("white");
	gf.contents[0].updateView();
	layer_counter++;
	gf.add(new layer("Layer "+layer_counter));
	layer_counter++;
	gf.add(new layer("Layer "+layer_counter));

	gf.updateIdIndexMap();
	gf.updateClipMap();
	gf.updateIdMaskMap();
	
	selectLayer(1,"layer");
	selected_layer_multi = [selected_layer_i];
	
	selected_layer.ctx.drawImage(img,0,0);
	selected_layer.updateView();
}

function saveAsFile(format, options){
//format - string representing file format
//options - [arg1, arg2, ... ]

	switch(format){
		
		case "project":
			try{
				solidifySpree();
				generateDownload(gf.proj_meta.name+"."+PROJECT_FORMAT,"data:text/json;charset=UTF-8,"+JSON.stringify(generateProjectFile()) );
				gf.stampOPID();
			}catch(err){
				alert("Error saving project file");
				console.log(err);
			}
		break;
		//
		
		case "jpeg":
		case "jpg":
			try{
				let img_quality = 1.0;//maximum quality by default
				if(options != null && options[0] <= 1 && options[0] >= 0){
				//expects between 0 and 1 jpeg encoding quality
					img_quality = options[0];
				}
				//
				generateDownload(gf.proj_meta.name+"."+format, live_view.toDataURL('image/jpeg',img_quality));
			}catch(err){
				alert("Error saving "+format+" file");
				console.log(err);
			}
		break;
		//
		
		default:
			//PNG
			try{
				generateDownload(gf.proj_meta.name+".png", live_view.toDataURL('image/png'));
			}catch(err){
				alert("Error saving png file");
				console.log(err);
			}
	}

}
//


function generateDownload(filename,data){
	UI.ts_download_btn.setAttribute("href",data);
	UI.ts_download_btn.setAttribute("download",filename);
	UI.ts_download_btn.click();
}

function makeBrushCloneSample(ex,ey){
	//make coordinates relative to scroll position and zoom
	var c_rect = live_view.getBoundingClientRect();
	var x = Math.floor((ex-c_rect.x)/canvas_view.current_zoom);
	var y = Math.floor((ey-c_rect.y)/canvas_view.current_zoom);
	current_brush.makeBrushCloneSample(selected_layer.view, x,y);
}

function imprintCanvasView(s_c, d_c, d_ctx){
//similar mechanic to how addSelectedLayerToRef works
		d_ctx.imageSmoothingEnabled = false;
		var c_rect = live_view.getBoundingClientRect();
		var c_rect_view = c_view.getBoundingClientRect();
		var to_chamberX =  -(c_rect.x - c_rect_view.x);// canvas_view.current_zoom;
		var to_chamberY =  -(c_rect.y - c_rect_view.y);// canvas_view.current_zoom;
		/* old generic version for reference
		var sx = to_chamberX / canvas_view.current_zoom;
		var sy = to_chamberY / canvas_view.current_zoom;
		var sw = d_c.width / canvas_view.current_zoom;//selected_layer.view.width;// / canvas_view.current_zoom;
		var sh = d_c.height / canvas_view.current_zoom;//selected_layer.view.height// / canvas_view.current_zoom;
		var dx = 0;
		var dy = 0;
		var dw = d_c.width;
		var dh = d_c.height;
		*/
		//small optimization to not try cutting large out of bounds chunks when zoomed far out
		if(s_c.width*canvas_view.current_zoom < d_c.width && s_c.height*canvas_view.current_zoom < d_c.height){
			var sx = 0;
			var sy = 0;
			var sw = s_c.width;//selected_layer.view.width;// / canvas_view.current_zoom;
			var sh = s_c.height;//selected_layer.view.height// / canvas_view.current_zoom;
			var dx = -to_chamberX;
			var dy = -to_chamberY;
			var dw = s_c.width * canvas_view.current_zoom;
			var dh = s_c.height * canvas_view.current_zoom;
		}else{
			var sx = to_chamberX / canvas_view.current_zoom;
			var sy = to_chamberY / canvas_view.current_zoom;
			var sw = d_c.width / canvas_view.current_zoom;//selected_layer.view.width;// / canvas_view.current_zoom;
			var sh = d_c.height / canvas_view.current_zoom;//selected_layer.view.height// / canvas_view.current_zoom;
			var dx = 0;
			var dy = 0;
			var dw = d_c.width;
			var dh = d_c.height;
		}
		//void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
		d_ctx.drawImage(s_c, sx,sy, sw,sh, dx,dy, dw,dh);
}

//two part HSB to RGB conversion
function HueDegToRGB(h){
	//dealing with hue degrees
	var rgb = [0,0,0];
		
	//core hue degrees to rgb
	var i = Math.ceil(h/60);
	var m = 1/60*(60-(60*i-h));
	var c = i%2;
	
	//pure rgb from hue indices
	var i_full = (i - (2-(1-c)) + 3) %3;
	var i_zero = (i - (2-c) + 3) %3;
	i = i%3;
	//gradient value 
	var val = Math.round(255*(1-c) + ((-1+(2*c))*(255*m) ));

	//
	rgb[2-i_full] = 255;
	rgb[2-i_zero] = 0;
	rgb[2-i] = val;
	//hue degrees converted
		
	return rgb;
}

function ApplySBToHue(saturation,brightness,rgb_hue){
	var s = (100-saturation)/10/10;
	var b = brightness/10/10;
	var rgb = [0,0,0];
	
	rgb[0] = Math.round(b* (rgb_hue[0] + ((255-rgb_hue[0])*s)));
	rgb[1] = Math.round(b* (rgb_hue[1] + ((255-rgb_hue[1])*s)));
	rgb[2] = Math.round(b* (rgb_hue[2] + ((255-rgb_hue[2])*s)));

	return rgb;
}
//

function RGBtoHSB(rgb){

	var i_max = 0;
	var i_min = 0;
	var c_max = rgb[0];
	var c_min = rgb[0];
	var c_med = rgb[0];
	for(var i=0;i<3;i++){

		if(c_max < rgb[i]){
			c_max = rgb[i];
			i_max = i;
		}
		if(c_min > rgb[i]){
			c_min = rgb[i];
			i_min = i;
		}
	}
	
	var i_med = (3-i_max-i_min)%3;
	c_med = rgb[i_med];
	
	
	if(c_max == 0){
		return [0,0,0];
	}
	
	var b = 100/255*c_max;
	
	var s = Math.round(100/255*(c_min/b*100));

	if(c_min == c_max){
		return [0,100-s,b];
	}
	
	var h = (360+60*(i_max*2 + ((rgb[(i_max+1)%3] - rgb[(i_max+2)%3]) / (c_max - c_min))))%360;
	
	return [h,100-s,b];
}
//

function HSBtoRGB(hsb){
	//dealing with hue degrees
	var rgb = [0,0,0];
	var h = hsb[0];
	var s = (100-hsb[1])/100;
	var b = hsb[2]/100;

	//core hue degrees to rgb
	var i = Math.ceil(h/60);
	var m = 1/60*(60-(60*i-h));
	var c = i%2;
	
	//pure rgb from hue indices
	var i_full = (i - (2-(1-c)) + 3) %3;
	var i_zero = (i - (2-c) + 3) %3;
	i = i%3;
	//gradient value 
	var val = Math.round(255*(1-c) + ((-1+(2*c))*(255*m) ));

	//apply brightness and saturation and fill the indices
	rgb[2-i_full] = Math.round(b*255);
	rgb[2-i_zero] = Math.round(b*255*s);
	rgb[2-i] = Math.round(b* (val + ((255-val)*s)));

	return rgb;
}

function RGBtoHex(rgb){
	return rgb[0].toString(16).padStart(2, '0')+rgb[1].toString(16).padStart(2, '0')+rgb[2].toString(16).padStart(2, '0');
}

function HextoRGB(hex_str){
	var hex = hex_str.replaceAll(/[^a-fA-F0-9]/gi,'');
	if(hex.length < 6){
		if(hex.length == 3){
			hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
		}else{
			hex = hex.padStart(6, '0');
		}
	}
	return [parseInt(hex.substring(0,2),16),parseInt(hex.substring(2,4),16),parseInt(hex.substring(4,6),16)];
}

function flipContent(c,ctx,scaleX,scaleY){
	//flips contents of a given canvas, uses chamber_buffer[1]
	chamber_buffer[1].put(c);
	ctx.clearRect(0,0,c.width,c.height);
	ctx.translate(-c.width*((-1+scaleX)/2), -c.height*((-1+scaleY)/2));
	ctx.scale(scaleX,scaleY);
	ctx.drawImage(chamber_buffer[1].c,0,0);
	//reverse
	ctx.scale(scaleX,scaleY);
	ctx.translate(c.width*((-1+scaleX)/2), c.height*((-1+scaleY)/2));
}

function flipCanvas(scaleX,scaleY){
	//expected input 1 or -1 for scaleX and scaleY
	
	//flip spree
	spree.flipCanvas(scaleX,scaleY);
	//flip layers
	gf.flipCanvas(scaleX,scaleY);
	//flip selection
	selection_module.flipCanvas(scaleX,scaleY);
}

function resizeCanvas(w,h,quadrant){
	var contentOffsetX = 0;
	var contentOffsetY = 0;
	//contentOffsetX
	/* default value 0 takes care of this first case
	if(quadrant == 1 || quadrant == 4 || quadrant == 7){
	 
	}else */
	if(quadrant == 2 || quadrant == 5 || quadrant == 8){
		contentOffsetX = (w-drawingAreaWidth)/2;
	}else if(quadrant == 3 || quadrant == 6 || quadrant == 9){
		contentOffsetX = w-drawingAreaWidth;
	}
	
	//contentOffsetY
	/* default value 0 takes care of this first case
	if(quadrant == 1 || quadrant == 2 || quadrant == 3){
	
	}else */ 
	if(quadrant == 4 || quadrant == 5 || quadrant == 6){
		contentOffsetY = (h-drawingAreaHeight)/2;
	}else if(quadrant == 7 || quadrant == 8 || quadrant == 9){
		contentOffsetY = h-drawingAreaHeight;
	}
	
	
	drawingAreaWidth = w;
	drawingAreaHeight = h;
			
	spree.resizeCanvas(w,h);
			
	gf.resizeCanvas(w,h,contentOffsetX,contentOffsetY);
			
	selection_module.resizeCanvas(w,h);
	
	live_view.width = drawingAreaWidth;
	live_view.height = drawingAreaHeight;
	live_view.style.width = drawingAreaWidth + "px";
	live_view.style.height = drawingAreaHeight + "px";
	
	tiny_preview.width = drawingAreaWidth;
	tiny_preview.height = drawingAreaHeight;
	
	brush_mediator_opacity.width = drawingAreaWidth;
	brush_mediator_opacity.height = drawingAreaHeight;
	
	brush_mediator_flow.width = drawingAreaWidth;
	brush_mediator_flow.height = drawingAreaHeight;
	
	move_module.updateUIConfigMenu();
	move_module.updateUITransformControls();
}

function resizeImage(w,h,antialias){
	
	drawingAreaWidth = w;
	drawingAreaHeight = h;
	
	spree.resizeImage(w,h);
			
	gf.resizeImage(w,h,antialias);
			
	selection_module.resizeImage(w,h);
	
	live_view.width = drawingAreaWidth;
	live_view.height = drawingAreaHeight;
	live_view.style.width = drawingAreaWidth + "px";
	live_view.style.height = drawingAreaHeight + "px";
	
	tiny_preview.width = drawingAreaWidth;
	tiny_preview.height = drawingAreaHeight;
	
	brush_mediator_opacity.width = drawingAreaWidth;
	brush_mediator_opacity.height = drawingAreaHeight;
	
	brush_mediator_flow.width = drawingAreaWidth;
	brush_mediator_flow.height = drawingAreaHeight;
	
	move_module.updateUIConfigMenu();
	move_module.updateUITransformControls();
}

function cropCanvas(x,y,w,h){
	if(selection_module.selection_active == false){
		alert("Please make a selection first");
		return;
	}
	
	drawingAreaWidth = w;
	drawingAreaHeight = h;
	
	spree.cropCanvas(x,y,w,h);
	
	gf.cropCanvas(x,y,w,h);
	
	selection_module.cropCanvas(x,y,w,h);
	
	live_view.width = drawingAreaWidth;
	live_view.height = drawingAreaHeight;
	live_view.style.width = drawingAreaWidth + "px";
	live_view.style.height = drawingAreaHeight + "px";
	
	tiny_preview.width = drawingAreaWidth;
	tiny_preview.height = drawingAreaHeight;
	
	brush_mediator_opacity.width = drawingAreaWidth;
	brush_mediator_opacity.height = drawingAreaHeight;
	
	brush_mediator_flow.width = drawingAreaWidth;
	brush_mediator_flow.height = drawingAreaHeight;
	
	move_module.updateUIConfigMenu();
	move_module.updateUITransformControls();
}

function rotateCanvasObj90(c,ctx,direction){
//rotates content of given canvas by 90 degrees in given direction
	var w = ctx.canvas.width;
	var h = ctx.canvas.height;
	var imgSmoothingEnabled = ctx.imageSmoothingEnabled;
	
	chamber_buffer[0].put(c);
	
	ctx.clearRect(0,0,w,h);
	c.width = h;
	c.height = w;
	
	ctx.imageSmoothingEnabled = false;
	ctx.translate(c.width/2,c.height/2);
	ctx.rotate(direction*Math.PI/2);
	ctx.translate(-c.height/2,-c.width/2);
	
	ctx.drawImage(chamber_buffer[0].c, 0,0);
	
	//reset
	ctx.translate(c.height/2,c.width/2);
	ctx.rotate(-direction*Math.PI/2);
	ctx.translate(-c.width/2,-c.height/2);
	ctx.imageSmoothingEnabled = imgSmoothingEnabled;
}

function rotateCanvas90(direction){
	let temp_w = drawingAreaWidth;
	drawingAreaWidth = drawingAreaHeight;
	drawingAreaHeight = temp_w;
	
	spree.rotateCanvas90(direction);
	
	gf.rotateCanvas90(direction);
	
	selection_module.rotateCanvas90(direction);
	
	live_view.width = drawingAreaWidth;
	live_view.height = drawingAreaHeight;
	live_view.style.width = drawingAreaWidth + "px";
	live_view.style.height = drawingAreaHeight + "px";
	
	tiny_preview.width = drawingAreaWidth;
	tiny_preview.height = drawingAreaHeight;
	
	brush_mediator_opacity.width = drawingAreaWidth;
	brush_mediator_opacity.height = drawingAreaHeight;
	
	brush_mediator_flow.width = drawingAreaWidth;
	brush_mediator_flow.height = drawingAreaHeight;
	
	move_module.updateUIConfigMenu();
	move_module.updateUITransformControls();
}

function canvasIsEmpty(ctx){
	const imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height).data;
	var isEmpty = true;
	for(let i=3,len=imgData.length;i<len;i+=4){
		if(imgData[i] > 0){
			isEmpty = false;
			break;
		}
	}
	return isEmpty;
	/*
	//seem to be slower
	const pixelBuffer = new Uint32Array(
		ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height).data.buffer
	);
	return !pixelBuffer.some(color => color !== 0);
	*/
}

function findContentBoundingBox(c,ctx){

	var offsetX = 0;
	var offsetY = 0;
	var w = 0;
	var h = 0;
	
	var c_w = c.width;
	var c_h = c.height;
	var pixelData = ctx.getImageData(0,0,c_w,c_h).data;
	//get y coordinate
	var found = false;
	for(var y=0;y<c_h;y++){
		for(var x=0;x<c_w;x++){
			if(pixelData[(y*c_w+x)*4 + 3] > 0){
				offsetY = y;
				found = true;
				break;
			}
		}
		if(found == true)break;
	}

	//get height
	found = false;
	for(var y=c_h-1;y>-1;y--){
		for(var x=c_w-1;x>-1;x--){
			if(pixelData[(y*c_w+x)*4 + 3] > 0){
				h = y-offsetY+1;
				found = true;
				break;
			}
		}
		if(found == true)break;
	}
	
	
	found = false;
	//get x coordinate
	for(var x=0;x<c_w;x++){
		for(var y=0;y<c_h;y++){
			if(pixelData[(y*c_w+x)*4 + 3] > 0){
				offsetX = x;
				found = true;
				break;
			}
		}
		if(found == true)break;
	}
	
	found = false;
	//get width
	for(var x=c_w-1;x>-1;x--){
		for(var y=c_h-1;y>-1;y--){
			if(pixelData[(y*c_w+x)*4 + 3] > 0){
				w = x-offsetX+1;
				found = true;
				break;
			}
		}
		if(found == true)break;
	}
	
	return [offsetX,offsetY, w,h];
}


function mergeLayers(layer_multi){
	//Based on stackLiveView()
	layer_counter++;
	var ml = new layer("Layer "+layer_counter);
	
	var to_chamberX = 0;//offsets the drawImage x,y such that chamber gets drawn only region under the brush
	var to_chamberY = 0;//perhaps faster than cutting out part of image with getImageData etc
	
	//set chamber dimensions to live_view 
	var w = live_view.width;
	var h = live_view.height;
	chamber.width = w;
	chamber.height = h;
	chamber_clipping_mask.width = w;
	chamber_clipping_mask.height = h;
	
	chamber_ctx.clearRect(0,0,w,h);
	chamber_ctx.globalCompositeOperation = "source-over";
	chamber_clipping_mask_ctx.clearRect(0,0,w,h);
	chamber_clipping_mask_ctx.globalCompositeOperation = "source-over";
	//start stacking
	var use_ctx = chamber_ctx;
	var gf_pos=0;
	var clip = -1;
	var current_obj = null;
	var current_clippingMask = null;
	for(var i=0;i<selected_layer_multi.length;i++){
		
		gf_pos = selected_layer_multi[i];
		current_obj = gf.contents[gf_pos];
		
		if(current_obj.clip > 0){
			//check clipping mask visibility
			if(current_obj.visible){

				clip = current_obj.clip;
				current_clippingMask = current_obj;
				use_ctx = chamber_clipping_mask_ctx;
				use_ctx.clearRect(0,0,w,h);
				
				use_ctx.globalCompositeOperation = "source-over";
				use_ctx.drawImage(current_obj.clippingMask,to_chamberX,to_chamberY);
				
			}else{
			//skip if not visible
				gf_pos += current_obj.clip;
				//fastforward/skip trough selected layers
				while(i < selected_layer_multi.length){
					if(selected_layer_multi[i] > gf_pos){
						i--;
						break;
					}
					i++;
				}
				//
			}
		}else{
			
			if(current_obj.visible){
				use_ctx.globalCompositeOperation = current_obj.blending;
				use_ctx.globalAlpha = current_obj.opacity;
				use_ctx.drawImage(current_obj.view,to_chamberX,to_chamberY);
				use_ctx.globalAlpha = 1.0;
				use_ctx.globalCompositeOperation = "source-over";
			}
		}
		
		//end of clipping mask, apply and draw to other chamber
		if(clip == 0 || 
			(clip > 0 && ( (selected_layer_multi[Math.min(selected_layer_multi.length-1,i+1)] - gf_pos) > clip
				|| i == selected_layer_multi.length-1) )){
			chamber_clipping_mask_ctx.globalCompositeOperation = "destination-in";
			chamber_clipping_mask_ctx.drawImage(current_clippingMask.view,to_chamberX,to_chamberY);
			chamber_clipping_mask_ctx.globalCompositeOperation = "source-over";
			
			use_ctx = chamber_ctx;
			
			use_ctx.globalAlpha = current_clippingMask.opacity;
			use_ctx.globalCompositeOperation = current_clippingMask.blending;
			use_ctx.drawImage(chamber_clipping_mask,0,0);
			use_ctx.globalAlpha = 1.0;
			use_ctx.globalCompositeOperation = "source-over";
			
			current_clippingMask = null;
			clip = -1;
		}
		
		//gf_pos++;
		clip--;
		
	}
	
	//complete live_view by replacing region with chamber
	ml.ctx.drawImage(chamber,0,0);
	ml.updateView();
	
	return ml;
}

//fill functions
function fillModule(){
	var fm = this;
	
	fm.config = {};
	fm.config.rgb_margin = 25;//0-255 color threshold
	fm.config.opacity_barrier = 100;//0-100 in percentage, what pixel opacity/alpha to count as barrier
	fm.config.raw_opacity_barrier = 255;
	fm.config.all_layers = true;//sample live view, or just selected layer
	fm.config.top_visible = false;//sample only top visible layer
	fm.config.basic_fill = false;//by default use transparency aware fill, when true uses fill_module.fillBasic
	fm.config.direct = false;//when true fill will alter selected layer directly, bypassing spree 
	fm.config.lasso_fill = false;
}


fillModule.prototype = {
	
	load : function(config){
		var fm = this;
		for(var config_name in config){
			fm.config[config_name] = config[config_name];
		}
	},
	
	setConfig : function(option,val){
	//generic internal for any config
		this.config[option] = val;
	},
	
	setConfigBucketTool : function(option,val){
	//same as generic, but does config notification
		this.config[option] = val;
		//
		uc_keeper.notifyGenUpdateNeeded("generalConfig","ToolOptionsBucketTool");
	},
	
	
	getConfig : function(option){
		return this.config[option];
	},
	
	
	setTolerance : function(val){
		this.config.rgb_margin = val;
	},
	setOpacityBarrier : function(val){
		this.config.opacity_barrier = val;
		this.config.raw_opacity_barrier = 255*val/10/10;
		//
		uc_keeper.notifyGenUpdateNeeded("generalConfig","ToolOptionsBucketTool");
	},
	setAllLayers : function(val){
		this.config.all_layers = val;
	},
	setBasicFill : function(val){
		this.config.basic_fill = val;
	},
	setDirect : function(val){
		this.config.direct = val;
	},
	
	
	updateUIFillConfig : function(){
		var fm = this;
		UI.fc_rgb_margin.value = fm.config.rgb_margin;
		UI.fc_opacity_barrier.value = fm.config.opacity_barrier;
		UI.fc_all_layers.checked = fm.config.all_layers;
		UI.fc_top_visible.checked = fm.config.top_visible;
		UI.fc_basic_fill.checked = fm.config.basic_fill;
		UI.fc_direct.checked = fm.config.direct;
		UI.fc_lasso_fill.checked = fm.config.lasso_fill;
	},
	getUIInfo : function(){
		var fm = this;
		fm.config.rgb_margin = parseInt(UI.fc_rgb_margin.value);
		fm.config.opacity_barrier = parseInt(UI.fc_opacity_barrier.value);
		fm.config.raw_opacity_barrier = 255*fm.config.opacity_barrier/10/10;
		fm.config.all_layers = UI.fc_all_layers.checked;
		fm.config.top_visible = UI.fc_top_visible.checked;
		fm.config.basic_fill = UI.fc_basic_fill.checked;
		fm.config.direct = UI.fc_direct.checked;
		fm.config.lasso_fill = UI.fc_lasso_fill.checked;
	},
	
	checkPixelSame : function(current, target){
		var fm = this;
		
		//var same = false;
		//var same_color = false;
		//var same_alpha = false;
		//var same_tone = false;
		//var same_background = false;
		
		var rgb_margin = fm.config.rgb_margin;
		var opacity_barrier = fm.config.raw_opacity_barrier;
		
		let current_alpha = parseInt(current[3]);
		let target_alpha = parseInt(target[3]);

		if( target_alpha === 0 && current_alpha < opacity_barrier ){
			return true;
		}else{
			
			if( !( (current_alpha > 0 && target_alpha > 0) || (current_alpha === 0 && target_alpha === 0) ) ){
				return false;
			}
			
			if( !( Math.abs(current[0]-target[0])<rgb_margin && Math.abs(current[1]-target[1])<rgb_margin && Math.abs(current[2]-target[2])<rgb_margin ) ){
				return false;
			}
			
			return true;
		}

		/* 
		//older not optimized/refactored version for reference
		same_color = Math.abs(current[0]-target[0])<rgb_margin&&Math.abs(current[1]-target[1])<rgb_margin&&Math.abs(current[2]-target[2])<rgb_margin;
		same_alpha = (current_alpha>0&&target_alpha>0) || (current_alpha==0&&target_alpha==0) || (target_alpha==0&&current_alpha<opacity_barrier);
		same_background = target_alpha==0&&current_alpha<opacity_barrier;
		
		same = (same_color&&same_alpha) || same_background;
		return same;
		*/
	},
	
	fillTransparent : function(c,ctx,e,c_fill,fill_ctx){
		var fm = this;
		
		var direct = fm.config.direct;
		
		var fill_val = [0,0,0,0];
		fill_val[0] = c_fill[0];
		fill_val[1] = c_fill[1];
		fill_val[2] = c_fill[2];
		
		var fill_style = 0;

		var c_rect = live_view.getBoundingClientRect();
		//note: floor seems to work more precise
		var x = Math.floor((e.x-c_rect.x)/canvas_view.current_zoom);
		var y = Math.floor((e.y-c_rect.y)/canvas_view.current_zoom);
		const width = c.width;
		const height = c.height;
		//width and height limits for indexing into array
		//(!) important: there is a difference between uses of width, height and index calculations and limits
		const w_limit = width-1;
		const h_limit = height-1;
		
		if(x<0 || x>w_limit || y<0 || y>h_limit)return;
		
		//cache selection
		const sm = selection_module;
		const selection_active = sm.selection_active;
		var selectionPixelData;
		if(selection_active){
			selectionPixelData = sm.selectionPixelData;
		}
		
		var i = (x+(y*width))*4;
		//map of filled pixels
		var fill_map_data = ctx.createImageData(width,height).data;

		var selection_alpha = 255;
		//starting points for horizontal walks of the fill
		//gets populated on the go
		var coords = [[x,y]];
		
		
		//canvas that gets sampled
		const area_data = ctx.getImageData(0,0, width,height).data;
		//canvas that gets filled
		var fill_area = fill_ctx.getImageData(0,0, width,height);
		var fill_area_data = fill_area.data;
		
		var same = true;
		var same_next = false;
		var opacity_barrier = fm.config.raw_opacity_barrier;
		//possible next pixel
		var p = [0,0,0,0];
		var p_i = 0;
		
		var d_x = 0;
		var target = [area_data[i],area_data[i+1],area_data[i+2],area_data[i+3]];
		//if needed lightness:
		//target.push( Math.round( (Math.max(area_data[i],area_data[i+1],area_data[i+2]) + Math.min(area_data[i],area_data[i+1],area_data[i+2])) / 2) );
		
		var trail_up = false;
		var trail_down = false;
		//pixel that is currently being sampled
		var current;
		var j = 0;
		while(j<coords.length){
			
			x=coords[j][0];
			y=coords[j][1];
			
			i = (x+(y*width))*4;
			trail_up = false;
			trail_down = false;
			current = [area_data[i],area_data[i+1],area_data[i+2],area_data[i+3]];
			
			//first go right
			d_x = 1;
			while(true){
			
				same = fm.checkPixelSame(current,target);
				
				if(selection_active){
					selection_alpha = selectionPixelData[i+3];
				}
				
				if(!same || fill_map_data[i+3]>0 || selection_alpha === 0){
					//console.log(same,current,target);
					break;
				}
				
				//to not go negative row
				//sample pixel from row up
				if(y>0){
					//position row up
					p_i = i-(width*4);
					p[0] = area_data[p_i];
					p[1] = area_data[p_i+1];
					p[2] = area_data[p_i+2];
					p[3] = area_data[p_i+3];
					
					same_next = fill_map_data[p_i+3]==0 && fm.checkPixelSame(p,target) && (!selection_active || selectionPixelData[p_i + 3]>0);
					
					if(trail_up == false && same_next){
						trail_up = true;
						coords.push([x,y-1]);
					}else if(trail_up == true && !same_next){
						trail_up = false;
					}
				}
				
				//to not go overboard row
				//sample pixel from row down
				if(y<h_limit){
					p_i = i+(width*4);
					p[0] = area_data[p_i];
					p[1] = area_data[p_i+1];
					p[2] = area_data[p_i+2];
					p[3] = area_data[p_i+3];
					
					same_next = fill_map_data[p_i+3]==0 && fm.checkPixelSame(p,target) && (!selection_active || selectionPixelData[p_i + 3]>0);
					
					if(trail_down == false && same_next){
						trail_down = true;
						coords.push([x,y+1]);
					}else if(trail_down == true && !same_next){
						trail_down = false;
					}
				}
				
				
				
				//set pixel
				fill_map_data[i+3] = 255;
				fill_style = 0;
				//deal with alpha first
				/*Formula references:
				outA = srcA + dstA * (1.0 - srcA)
				outRGB = (srcRGB * srcA + dstRGB * dstA * (1.0 - srcA)) / outA
				where Alpha is calculated out of 1, so 1/255*alpha
				*/
				if(area_data[i+3] < opacity_barrier && target[3] === 0){
					
					//filling through content present
					if(fill_area_data[i+3] > 0){
						fill_style = 1;
					}else{
						fill_style = 0;
					}
					
					//filling empty pixels including those that are under barrier
					fill_val[3] = 255*( (1/255*selection_alpha) + (1/255*fill_area_data[i+3])*(1.0 - 1/255*selection_alpha) );
					
				}else if(fill_area_data[i+3] == 0 && selection_alpha < 255){
				//fill area is empty
					fill_val[3] = selection_alpha;
					fill_style = 0;//no blend
				}else{
				//pixel has own fill
					if(selection_alpha < 255){
						fill_val[3] = 255*( (1/255*selection_alpha) + (1/255*fill_area_data[i+3])*(1.0 - 1/255*selection_alpha) );
						fill_style = 1;//blend
					}else{
						fill_val[3] = area_data[i+3];
						fill_style = 0;
					}
					
				}
				
				
				
				//deal with color
				//blend or just fill the color
				if(fill_style == 1){
				//fill under existing transparent pixels
					if(selection_alpha < 255){
						fill_area_data[i] = ( (fill_val[0]*(1/255*selection_alpha)) + fill_area_data[i]*(1/255*fill_area_data[i+3])*(1.0-(1/255*selection_alpha)) ) / (1/255*fill_val[3]);
						fill_area_data[i+1] = ( (fill_val[1]*(1/255*selection_alpha)) + fill_area_data[i+1]*(1/255*fill_area_data[i+3])*(1.0-(1/255*selection_alpha)) ) / (1/255*fill_val[3]);
						fill_area_data[i+2] = ( (fill_val[2]*(1/255*selection_alpha)) + fill_area_data[i+2]*(1/255*fill_area_data[i+3])*(1.0-(1/255*selection_alpha)) ) / (1/255*fill_val[3]);
					}else{
					
						//outRGB = srcRGB - dstA*(srcRGB - dstRGB)
						fill_area_data[i] = fill_val[0] - (1/255*fill_area_data[i+3])*(fill_val[0] - fill_area_data[i]);
						fill_area_data[i+1] = fill_val[1] - (1/255*fill_area_data[i+3])*(fill_val[1] - fill_area_data[i+1]);
						fill_area_data[i+2] = fill_val[2] - (1/255*fill_area_data[i+3])*(fill_val[2] - fill_area_data[i+2]);
					
					}
					
				}else{
					fill_area_data[i] = fill_val[0];
					fill_area_data[i+1] = fill_val[1];
					fill_area_data[i+2] = fill_val[2];
				}
				
				
				//when filling directly preserve alpha
				if(direct && fill_area_data[i+3] > 0 && selection_alpha < 255 && target[3] > 0){
					
				}else{
					fill_area_data[i+3] = fill_val[3];
				}
				
				//set pixel END

				
				//go to next pixel
				i+=4*d_x;
				x+=d_x;
				current = [area_data[i],area_data[i+1],area_data[i+2],area_data[i+3]];
				
				same = fm.checkPixelSame(current,target);
				
				//go left or end this row walk
				if(x>w_limit || fill_map_data[i+3]>0 || !same || (selection_active && selectionPixelData[i+3]==0) ){
				//console.log("going left");
					d_x = -1;
					x = coords[j][0]-1;
					if(x<0)break;
					i = (x+(y*width))*4;
					trail_up = false;
					trail_down = false;
					current = [area_data[i],area_data[i+1],area_data[i+2],area_data[i+3]];
				}else if(x<0){
					//console.log("exiting line");
					break;
				}
			
			}
			//
			
			j++;
		}
		//
		fill_ctx.putImageData(fill_area, 0,0);
	},

	//
	
	checkPixelSameBasic : function(current, target){
		return current[0]==target[0]&&current[1]==target[1]&&current[2]==target[2]&&current[3]==target[3];
	},
	
	fillBasic : function(c,ctx,e,c_fill,fill_ctx){
	//src_c,src_ctx, event,color, dest_ctx
		var fm = this;
		
		var fill_val = c_fill;

		var c_rect = live_view.getBoundingClientRect();
		//note: floor seems to work more precise
		var x = Math.floor((e.x-c_rect.x)/canvas_view.current_zoom);
		var y = Math.floor((e.y-c_rect.y)/canvas_view.current_zoom);
		const width = c.width;
		const height = c.height;
		//width and height limits for indexing into array
		//(!) important: there is a difference between uses of width, height and index calculations and limits
		const w_limit = width-1;
		const h_limit = height-1;
		
		if(x<0 || x>w_limit || y<0 || y>h_limit)return;
		
		//cache selection
		const sm = selection_module;
		const selection_active = sm.selection_active;
		var selectionPixelData;
		if(selection_active){
			selectionPixelData = sm.selectionPixelData;
		}
		
		var i = (x+(y*width))*4;
		//map of filled pixels
		var fill_map_data = ctx.createImageData(width,height).data;
		var selection_alpha = 255;
		//starting points for horizontal walks of the fill
		//gets populated on the go
		var coords = [[x,y]];
		
		
		//canvas that gets sampled
		var area_data = ctx.getImageData(0,0, width,height).data;
		//canvas that gets filled
		var fill_area = fill_ctx.getImageData(0,0, width,height);
		var fill_area_data = fill_area.data;
		var same = true;
		var same_next = false;
		//possible next pixel
		var p = [0,0,0,0];
		var p_i = 0;
		
		var d_x = 0;
		var target = [area_data[i],area_data[i+1],area_data[i+2],area_data[i+3]];
		
		//if needed lightness:
		//target.push( Math.round( (Math.max(area_data[i],area_data[i+1],area_data[i+2]) + Math.min(area_data[i],area_data[i+1],area_data[i+2])) / 2) );
		
		var trail_up = false;
		var trail_down = false;
		//pixel that is currently being sampled
		var current;
		var j = 0;
		while(j<coords.length){
			
			x=coords[j][0];
			y=coords[j][1];
			
			i = (x+(y*width))*4;
			trail_up = false;
			trail_down = false;
			current = [area_data[i],area_data[i+1],area_data[i+2],area_data[i+3]];
			
			//first go right
			d_x = 1;
			while(true){
			
				same = fm.checkPixelSameBasic(current,target);
				
				if(selection_active){
					selection_alpha = selectionPixelData[i+3];
				}
				
				if(!same || fill_map_data[i+3]>0 || selection_alpha==0){
					//console.log(same,current,target);
					break;
				}
				
				//to not go negative row
				//sample pixel from row up
				if(y>0){
					//position row up
					p_i = i-(width*4);
					p[0] = area_data[p_i];
					p[1] = area_data[p_i+1];
					p[2] = area_data[p_i+2];
					p[3] = area_data[p_i+3];
					
					same_next = fill_map_data[p_i+3]==0 && fm.checkPixelSameBasic(p,target) && (!selection_active || selectionPixelData[p_i + 3]>0);
					
					if(trail_up == false && same_next){
						trail_up = true;
						coords.push([x,y-1]);
					}else if(trail_up == true && !same_next){
						trail_up = false;
					}
				}
				
				//to not go overboard row
				//sample pixel from row down
				if(y<h_limit){
					p_i = i+(width*4);
					p[0] = area_data[p_i];
					p[1] = area_data[p_i+1];
					p[2] = area_data[p_i+2];
					p[3] = area_data[p_i+3];
					
					same_next = fill_map_data[p_i+3]==0 && fm.checkPixelSameBasic(p,target) && (!selection_active || selectionPixelData[p_i + 3]>0);
					
					if(trail_down == false && same_next){
						trail_down = true;
						coords.push([x,y+1]);
					}else if(trail_down == true && !same_next){
						trail_down = false;
					}
				}
				
				//set pixel
				fill_map_data[i+3] = 255;
				
				fill_area_data[i] = fill_val[0];
				fill_area_data[i+1] = fill_val[1];
				fill_area_data[i+2] = fill_val[2];
				if(area_data[i+3]==0){
					fill_area_data[i+3] = selection_alpha;
				}else{
					fill_area_data[i+3] = area_data[i+3];
				}
				
				//go to next pixel
				i+=4*d_x;
				x+=d_x;
				current = [area_data[i],area_data[i+1],area_data[i+2],area_data[i+3]];
				
				same = fm.checkPixelSameBasic(current,target);
				
				//go left or end this row walk
				if(x>w_limit || fill_map_data[i+3]>0 || !same || (selection_active && selectionPixelData[i+3]==0) ){
				//console.log("going left");
					d_x = -1;
					x = coords[j][0]-1;
					if(x<0)break;
					i = (x+(y*width))*4;
					trail_up = false;
					trail_down = false;
					current = [area_data[i],area_data[i+1],area_data[i+2],area_data[i+3]];
				}else if(x<0){
					//console.log("exiting line");
					break;
				}
			
			}
			//
			
			j++;
		}
		//
		fill_ctx.putImageData(fill_area, 0,0);
	}
}

var fill_module = new fillModule();
fill_module.updateUIFillConfig();

function invertColors(obj_c,obj_ctx){
	//modifies the object
	var imgData = obj_ctx.getImageData(0,0,obj_c.width,obj_c.height);
	var data = imgData.data;
	var selection_alpha = 255;
	var selectionPixelData;
	const selection_active = selection_module.selection_active;
	if(selection_active){
		selectionPixelData = selection_module.selectionPixelData;
	}
	
	for(var i=0,data_len=data.length;i<data_len;i+=4){
		
		if(selection_active){
			selection_alpha = selectionPixelData[i+3];
		}
		
		if(selection_alpha > 0){
		
			if(selection_alpha < 255){
				data[i] = ((255-data[i]) * 1/255*selection_alpha) + (data[i] * (1.0 - 1/255*selection_alpha));
				data[i+1] = ((255-data[i+1]) * 1/255*selection_alpha) + (data[i+1] * (1.0 - 1/255*selection_alpha));
				data[i+2] = ((255-data[i+2]) * 1/255*selection_alpha) + (data[i+2] * (1.0 - 1/255*selection_alpha));	
			}else{
				data[i] = 255-data[i];
				data[i+1] = 255-data[i+1];
				data[i+2] = 255-data[i+2];
			}
			
		}
		
	}
	obj_ctx.putImageData(imgData,0,0);
}



function BnWColors(obj_c,obj_ctx){
	//modifies the object
	var imgData = obj_ctx.getImageData(0,0,obj_c.width,obj_c.height);
	var data = imgData.data;
	var avg = 0;
	var selection_alpha = 255;
	var selectionPixelData;
	const selection_active = selection_module.selection_active;
	if(selection_active){
		selectionPixelData = selection_module.selectionPixelData;
	}
	
	for(var i=0,data_len=data.length;i<data_len;i+=4){
		
		if(selection_active){
			selection_alpha = selectionPixelData[i+3];
		}
		
		if(selection_alpha > 0){
			
			avg = Math.round(data[i]*0.3+data[i+1]*0.59+data[i+2]*0.11);
			
			if(selection_alpha < 255){
				data[i] = (avg * 1/255*selection_alpha) + (data[i] * (1.0 - 1/255*selection_alpha));
				data[i+1] = (avg * 1/255*selection_alpha) + (data[i+1] * (1.0 - 1/255*selection_alpha));
				data[i+2] = (avg * 1/255*selection_alpha) + (data[i+2] * (1.0 - 1/255*selection_alpha));	
			}else{
				data[i] = avg;
				data[i+1] = avg;
				data[i+2] = avg;
			}
		
		}
		
	}
	obj_ctx.putImageData(imgData,0,0);
}

function BnWAlpha(obj_c,obj_ctx){
	//modifies the object
	//turns luminosity into alpha, black pixel color, accounts for existing alpha
	//works with selection
	var imgData = obj_ctx.getImageData(0,0,obj_c.width,obj_c.height);
	var data = imgData.data;
	var avg = 0;
	var selection_alpha = 255;
	var selectionPixelData;
	const selection_active = selection_module.selection_active;
	if(selection_active){
		selectionPixelData = selection_module.selectionPixelData;
	}
	
	for(var i=0,data_len=data.length;i<data_len;i+=4){
		
		if(selection_active){
			selection_alpha = selectionPixelData[i+3];
		}
		
		if(selection_alpha > 0){
			
			if(data[i+3] > 0){
				avg = 255 - Math.round(data[i]*0.3+data[i+1]*0.59+data[i+2]*0.11);
				data[i] = 0;
				data[i+1] = 0;
				data[i+2] = 0;
				data[i+3] = data[i+3]*avg/255;
			}
		}
	}
	obj_ctx.putImageData(imgData,0,0);
}

function colorToAlphaWhite(obj_c,obj_ctx){
	//modifies the object
	//turns luminosity into alpha, white pixel color, accounts for existing alpha
	var imgData = obj_ctx.getImageData(0,0,obj_c.width,obj_c.height);
	var data = imgData.data;
	var avg = 0;
	for(var i=0,data_len=data.length;i<data_len;i+=4){
		if(data[i+3] > 0){
			avg = Math.round(data[i]*0.3+data[i+1]*0.59+data[i+2]*0.11);
			data[i] = 255;
			data[i+1] = 255;
			data[i+2] = 255;
			data[i+3] = data[i+3]*avg/255;
		}
	}
	obj_ctx.putImageData(imgData,0,0);
}

function colorToAlphaBlack(obj_c,obj_ctx){
	//modifies the object
	//turns luminosity into alpha, black pixel color, accounts for existing alpha
	var imgData = obj_ctx.getImageData(0,0,obj_c.width,obj_c.height);
	var data = imgData.data;
	var avg = 0;
	for(var i=0,data_len=data.length;i<data_len;i+=4){
		if(data[i+3] > 0){
			avg = 255 - Math.round(data[i]*0.3+data[i+1]*0.59+data[i+2]*0.11);
			data[i] = 0;
			data[i+1] = 0;
			data[i+2] = 0;
			data[i+3] = data[i+3]*avg/255;
		}
	}
	obj_ctx.putImageData(imgData,0,0);
}


function invertAlpha(obj_c,obj_ctx){
	//modifies the object, inverts alpha, intended to use for inverting masks
	//also for brush tips
	var original_composite = obj_ctx.globalCompositeOperation;
	obj_ctx.globalCompositeOperation = "xor";
	obj_ctx.fillStyle = "white";
	obj_ctx.fillRect(0,0,obj_c.width,obj_c.height);
	obj_ctx.globalCompositeOperation = original_composite;
}

function invertMask(obj_c,obj_ctx){
	const selection_active = selection_module.selection_active;
	if(selection_active == false){
		invertAlpha(obj_c,obj_ctx);
	}else{
		var imgData = obj_ctx.getImageData(0,0,obj_c.width,obj_c.height);
		var data = imgData.data;
		var selection_alpha = 255;
		var selectionPixelData;
		
		if(selection_active){
			selectionPixelData = selection_module.selectionPixelData;
		}
		
		for(var i=0,data_len=data.length;i<data_len;i+=4){
		
			if(selection_active){
				selection_alpha = selectionPixelData[i+3];
			}
			
			if(selection_alpha > 0){
			
				if(selection_alpha < 255){
					data[i+3] = ((255-data[i+3]) * 1/255*selection_alpha) + (data[i+3] * (1.0 - 1/255*selection_alpha));	
				}else{
					data[i+3] = 255-data[i+3];
				}
				
			}
			
		}
		obj_ctx.putImageData(imgData,0,0);
		//
		var original_composite = obj_ctx.globalCompositeOperation;
		obj_ctx.globalCompositeOperation = "source-atop";
		obj_ctx.fillStyle = "white";
		obj_ctx.fillRect(0,0, obj_c.width,obj_c.height);
		obj_ctx.globalCompositeOperation = original_composite;
	}
}

function desaturateAvgColors(obj_c,obj_ctx){
	//modifies the object
	var imgData = obj_ctx.getImageData(0,0,obj_c.width,obj_c.height);
	var data = imgData.data;
	var avg = 0;
	var selection_alpha = 255;
	var selectionPixelData;
	const selection_active = selection_module.selection_active;
	if(selection_active){
		selectionPixelData = selection_module.selectionPixelData;
	}
	
	for(var i=0,data_len=data.length;i<data_len;i+=4){
	
		if(selection_active){
			selection_alpha = selectionPixelData[i+3];
		}
		
		if(selection_alpha > 0){
			
			avg = Math.round((data[i]+data[i+1]+data[i+2])/3);
			
			if(selection_alpha < 255){
				data[i] = (avg * 1/255*selection_alpha) + (data[i] * (1.0 - 1/255*selection_alpha));
				data[i+1] = (avg * 1/255*selection_alpha) + (data[i+1] * (1.0 - 1/255*selection_alpha));
				data[i+2] = (avg * 1/255*selection_alpha) + (data[i+2] * (1.0 - 1/255*selection_alpha));	
			}else{
				data[i] = avg;
				data[i+1] = avg;
				data[i+2] = avg;
			}
		}
	}
	obj_ctx.putImageData(imgData,0,0);
}


function duplicateObj(obj){
	return JSON.parse(JSON.stringify(obj));
}

function duplicateLayer(layer_obj){
	layer_counter++;
	var dl = new layer(layer_obj.name+" copy");
	
	dl.ctx.drawImage(layer_obj.c,0,0);
	
	if(selection_module.selection_active){
	//duplicate only selected area
		dl.ctx.globalCompositeOperation = "destination-in";
		dl.ctx.drawImage(selection_module.selection,0,0);
		dl.ctx.globalCompositeOperation = "source-over";
	}
	
	if(layer_obj.mask != null){
		dl.mask = document.createElement("canvas");
		dl.mask_ctx = dl.mask.getContext("2d");
		dl.mask.width = drawingAreaWidth;
		dl.mask.height = drawingAreaHeight;
		dl.mask_ctx.drawImage(layer_obj.mask,0,0);
		
		dl.mask_enabled = layer_obj.mask_enabled;
	}
	dl.visible = layer_obj.visible;
	dl.opacity = layer_obj.opacity;
	
	dl.blending = layer_obj.blending;
	
	dl.updateView();
	
	return dl;
}

function deleteLayerMulti(){
	if(selected_layer_multi.length < gf.contents.length){
		gf.removeMultiple(selected_layer_multi);
	}
}


function solidifySpree(add_history){
	
	if(add_history == false){
	
	}else{
		history_keeper.store("solidifySpree",current_tool,toolset_mode,selected_layer_i);
	}
	
	//empty check is a bit slow
	//if(canvasIsEmpty(spree.ctx))return;
	
	let composite_mode = "source-over";
	//because solidifying eraser into a layer should erase :)
	if(toolset_mode == 2){
		selected_layer.ctx.globalCompositeOperation = "destination-out";
		composite_mode = "destination-out";
	}
	selected_layer.ctx.drawImage(spree.c,0,0);
	//reset to normal
	if(composite_mode != "source-over"){
		selected_layer.ctx.globalCompositeOperation = "source-over";
		composite_mode = "source-over";
	}
	
	spree.clear();
	
}

function discardSpree(){
	//history
	history_keeper.store("spree",current_tool,toolset_mode,selected_layer_i);
	//this needs layer.updateView to work, because 
	//spree is drawn directly into layer.view for layer blending
	spree.clear();
	selected_layer.updateView();
	if(selected_layer.clip > 0){
		selected_layer.updateClippingMask();
	}
	if(spree_mode != 0 && (current_tool == "brush_tool" || current_tool == "eraser_tool") ){
		setBrushSpreeMode(0);
		updateUIBayValues();
	}
	stackLiveView();
	
	
}

function spreeIndicatorSwitch(){
	if(selected_layer.target == "layer"){
	
		if(current_tool != "brush_tool" && current_tool != "eraser_tool"){
			changeTool("brush_tool");
		}
		toggleBrushSpreeMode();
		updateUIBayValues();
		canvas_view.drawCursor();
		
	}else if(selected_layer.target == "mask"){
		//spree is not used on mask, so change the tool to eraser
		if(current_tool == "eraser_tool"){
			changeTool("brush_tool");
		}else{
			changeTool("eraser_tool");
		}
	}
}

/////////////////////////////////////////////

var draw_count = 0;
var draw_stamp = 0;
var draw_active = false;
//var draw_stamp_elapsed_limit = 32;
var draw_stamp_elapsed_limit = 16;

function brushEventCoordinator(last_run){
	var bst = brushSpacing_tracker;

	if(draw_active == false){
		if(last_run == true){
			bst.process[bst.phase](bst.e_current,true);
		}
		return;
	}else{
		requestAnimationFrame(brushEventCoordinator);
	}
	
	if(Math.abs(bst.e_current.x - bst.e_previous.x)<1 && Math.abs(bst.e_current.y - bst.e_previous.y)<1){
		if(bst.same_e == false){
			bst.same_e = true;
			
			bst.e_current.x = bst.e_previous.x;
			bst.e_current.y = bst.e_previous.y;
			bst.e_current.pressure = bst.e_previous.pressure;
			
			bst.process[bst.phase](bst.e_current,true);
		}
		
	}else{
		bst.same_e = false;
		bst.process[bst.phase](bst.e_current);
		
		bst.e_previous.x = bst.e_current.x;
		bst.e_previous.y = bst.e_current.y;
		bst.e_previous.pressure = bst.e_current.pressure;
	}
	
	
}



function brushMark(){
//schedules brush drawing to canvas functions
//tries to optimize drawing time and responsiveness
	if(draw_active != true){
		draw_count = 0;
		return;
	}
	//
	requestAnimationFrame(brushMark);
	
	//
	if(draw_count < 1){
		draw_count = 3;
	}
	//
	var brush = current_brush;
	if(brush.blend_assist){
		draw_stamp_elapsed_limit = 30;
	}else{
		draw_stamp_elapsed_limit = 16;
	}
	//
	var compensate = true;
	var run_count = draw_count;
	var xyp = null;
	draw_stamp = performance.now();
	var time_elapsed = 0;
	while(compensate == true){
		while(draw_count > 0){
			
			xyp = brushTip_coords.next();
			if(xyp == null){
				draw_count = 0;
				return;
			}
			
			RunBrushOnCanvas(brush,xyp);
			--draw_count;
		}
		
		time_elapsed = performance.now() - draw_stamp;
		//estimate number of draws for next frame, minimum 1
		draw_count = Math.max(1, Math.floor(draw_stamp_elapsed_limit/( time_elapsed / run_count)));
		//
		//compensate
		compensate = false;
		if(time_elapsed < draw_stamp_elapsed_limit){
			if(draw_count - run_count > 0){
				draw_count -= run_count;
				run_count += draw_count;
				compensate = true;
			}
		}
	//
	}

//
}



function brushMarknostop(){

	var brush = current_brush;
	var xyp = brushTip_coords.next();
	
	while(xyp != null){
		RunBrushOnCanvas(brush,xyp);
		xyp = brushTip_coords.next();
	}
	
}

//-------------------------

//initially select layer 1 (second layer to not interfere with background)
selectLayer(1,"layer");
selected_layer_multi = [selected_layer_i];
stackLayersUI();
stackLiveView();


//init color picker
color_picker = new colorPicker(UI.color_id, 
					UI.cpf_hue_sb,UI.cpf_selector,UI.cpf_selector_cursor, 
					UI.cpf_hue_gradient,UI.cpf_hue_selector,UI.cpf_hue_selector_cursor, 
					UI.cp_sample);

//canvas mouse tool operation function binds

//tool call name : function binds for mouse up down move, or any other
var tool_mouse_down = {
	"brush_tool" : function(e){
	
		draw_active = true;
		
		brushSpacing_tracker.findRect();
		brushSpacing_tracker.storeEvent(e);
		
		//reset blend mix on new brush down
		if(current_brush.blend_assist){
			current_brush.blend_trail_active = false;
		}
		brushEventCoordinator();
		brushMark();
	},
	
	"eraser_tool" : function(e){
	
		draw_active = true;
		
		brushSpacing_tracker.findRect();
		brushSpacing_tracker.storeEvent(e);
		
		brushEventCoordinator();
		brushMark();
	},
	
	"bucket_tool" : function(e){
		return;
	},
	
	"select_tool" : function(e){
		selection_module.actionStart(e);
	},
	
	"lasso_tool" : function(e){
		selection_module.actionStart(e);
	},
	
	"auto_select_tool" : function(e){
		history_keeper.store("selection",current_tool,toolset_mode,selected_layer_i);
		selection_module.actionStart(e);
	},
	
	"move_tool" : function(e){
		move_module.actionStart(e);
	}
};

var tool_mouse_move = {
	"brush_tool" : function(e){
		brushSpacing_tracker.storeEvent(e);
	},
	
	"eraser_tool" : function(e){
		brushSpacing_tracker.storeEvent(e);
	},
	
	"bucket_tool": function(e){
		return;
	},
	
	"select_tool" : function(e){
		selection_module.actionDo(e);
	},
	
	"lasso_tool" : function(e){
		selection_module.actionDo(e);
	},
	
	"auto_select_tool" : function(e){
		selection_module.actionDo(e);
	},
	
	"move_tool" : function(e){
		move_module.actionDo(e);
	}
	
};

var tool_mouse_up = {
	"brush_tool" : function(e){
		draw_active = false;
		
		brushEventCoordinator(true);
		brushMarknostop();
		brushSpacing_tracker.reset();
		
		//
		if(selected_layer.target == "layer"){
			//spree
			history_keeper.lines.spree.target_area[0] = true;
			history_keeper.store("spree",current_tool,toolset_mode,selected_layer_i);
			
			spree.update();
		}else{
			//mask
			history_keeper.lines.mask.target_area[0] = true;
			history_keeper.store("mask",current_tool,toolset_mode,selected_layer_i);
		
			//snippet useful for making rgb version of drawing to mask
			//selected_layer.mask_ctx.globalCompositeOperation = "destination-over";
			//selected_layer.mask_ctx.fillRect(0,0, selected_layer.mask.width,selected_layer.mask.height);
			//selected_layer.mask_ctx.globalCompositeOperation = "source-over";
			selected_layer.mask_ctx.drawImage(brush_mediator_opacity,0,0);
			//colorToAlphaWhiteselected_layer.mask,selected_layer.mask_ctx);
		}
		
		brush_mediator_flow_ctx.clearRect(0,0,drawingAreaWidth,drawingAreaHeight);
		brush_mediator_opacity_ctx.clearRect(0,0,drawingAreaWidth,drawingAreaHeight);
		
	},
	
	"eraser_tool" : function(e){
		draw_active = false;
		
		brushEventCoordinator(true);
		brushMarknostop();
		brushSpacing_tracker.reset();
		
		//
		if(selected_layer.target == "layer"){
			//spree
			history_keeper.lines.spree.target_area[0] = true;
			history_keeper.store("spree",current_tool,toolset_mode,selected_layer_i);
		
			spree.update();
		}else{
			//mask
			history_keeper.lines.mask.target_area[0] = true;
			history_keeper.store("mask",current_tool,toolset_mode,selected_layer_i);
		
			selected_layer.mask_ctx.globalCompositeOperation = "destination-out";
			selected_layer.mask_ctx.drawImage(brush_mediator_opacity,0,0);
			selected_layer.mask_ctx.globalCompositeOperation = "source-over";
		}
		
		brush_mediator_flow_ctx.clearRect(0,0,drawingAreaWidth,drawingAreaHeight);
		brush_mediator_opacity_ctx.clearRect(0,0,drawingAreaWidth,drawingAreaHeight);
	
	},
	
	"bucket_tool" : function(e){
		//history
		if(fill_module.config.direct){
			history_keeper.store("layer",current_tool,toolset_mode,selected_layer_i);
		}else{
			history_keeper.store("spree",current_tool,toolset_mode,selected_layer_i);
		}
		//
		
		var src_c = null;
		var src_ctx = null;
		var dest_ctx = null;
		var found_visible = null;
		//
		if(fill_module.config.all_layers){
		//sample canvas view
			src_c = live_view;
			src_ctx = live_view_ctx;
		}else if(fill_module.config.top_visible){
		//find top visible to reference
			for(var i=gf.contents.length-1;i>-1;i--){
				if(gf.contents[i].visible == true){
					found_visible = gf.contents[i];
					break;
				}
			}
			if(found_visible != null){
				src_c = found_visible.view;
				src_ctx = found_visible.view_ctx;
			}else{
				src_c = live_view;
				src_ctx = live_view_ctx;
			}
			
		}else{
		//selected layer only
			src_c = selected_layer.view;
			src_ctx = selected_layer.view_ctx;
		}
		//
		
		if(fill_module.config.direct){
		//direct layer color replacement fill
			dest_ctx = selected_layer.ctx;
		}else{
		//to spree
			dest_ctx = spree.view_ctx;
		}
		
		//
		if(fill_module.config.basic_fill){
		//basic fill
			fill_module.fillBasic(src_c,src_ctx, e, color_picker.rgb, dest_ctx);
		}else{
		//transparency fill
			fill_module.fillTransparent(src_c,src_ctx, e, color_picker.rgb, dest_ctx);
		}
		
		spree.update();
		selected_layer.updateView();
		stackLiveView();
		
		
	},
	
	"select_tool" : function(e){
		//similar to lasso tool for responsiveness purposes
		//shifted history store from mouse_down to mouse_up
		history_keeper.store("selection",current_tool,toolset_mode,selected_layer_i);
		//check to deselect first, moved from actionStart
		const sm = selection_module;
		if(sm.drag_active == false && 
			sm.mode[1] == false && 
			sm.mode[2] == false){
			
			sm.deselectAll();
		}
		selection_module.actionEnd(e);
	},
	
	"lasso_tool" : function(e){
		const sm = selection_module;
		
		//for optimization/better user experience purposes:
		//shifted history store procedure from mouse_down to mouse_up
		//for better responsiveness when starting to draw lasso
		if(fill_module.getConfig("lasso_fill") == true){
		//make lasso fill to use a drawing toolset mode
			if(toolset_mode != 1){
				solidifySpree();
				toolset_mode = 1;
			}
			//
			
			if(selected_layer.target == "layer"){
				history_keeper.store("custom",current_tool,toolset_mode,selected_layer_i,["selection","spree"]);
			}else if(selected_layer.target == "mask"){
				history_keeper.store("custom",current_tool,toolset_mode,selected_layer_i,["selection","mask"]);
			}
		}else{
			history_keeper.store("selection",current_tool,toolset_mode,selected_layer_i);
		}
		
		//check to deselect first, moved from actionStart
		if(sm.drag_active == false && 
			sm.mode[1] == false && 
			sm.mode[2] == false){
			
			sm.deselectAll();
		}
		
		selection_module.actionEnd(e);
	},
	
	"auto_select_tool" : function(e){
		selection_module.actionEnd(e);
	},
	
	"move_tool" : function(e){
		move_module.actionEnd(e);
	}
	
};

//
function checkToolsetMode(){
	if(toolset_mode_map[current_tool] != null){
		if(toolset_mode != toolset_mode_map[current_tool]){ 
			solidifySpree();
			toolset_mode = toolset_mode_map[current_tool];
		}
	}
}

//call this like so, within mouse down event: tool_mouse_down[current_tool]();

//canvas mouse tool operations
var mouseIsDown = false;
c_view.addEventListener("click",function(e){e.preventDefault();},true);
c_view.addEventListener("dblclick",function(e){e.preventDefault();},true);

c_view.addEventListener("pointerdown", function(e){
	//
	if(document.activeElement.tagName == "INPUT"){
	//convenience to get out of input when starting to draw
		document.activeElement.blur();
	}
	
	this.setPointerCapture(e.pointerId);
	
	mouseIsDown = true;
	e.stopPropagation();
	try{
		checkToolsetMode();
		tool_agent.tool_mouse_down(e);
	}catch(err){
		console.log(err);
		alert("Error occured");
	}
	
});


c_view.addEventListener("pointermove", function(e){
	//draw cursor
	//if(canvas_view.cursor_pos_lock == 0){
	//have to repeat this same as in canvas_view.container event
	//because this cursor draw happens before parent catches new pos
		canvas_view.cursor_posX = e.x;
		canvas_view.cursor_posY = e.y;
	//}
	canvas_view.requestDrawCursor();
	
    if(mouseIsDown){
	
		try{
			tool_agent.tool_mouse_move(e);
		}catch(err){
			console.log(err);
			alert("Error occured");
		}
	}
	
    return false;
});

c_view.addEventListener("pointerup", function(e){
	if(mouseIsDown == false)return;
	
    mouseIsDown = false;
	e.stopPropagation();
	try{
		tool_agent.tool_mouse_up(e);
	}catch(err){
		console.log(err);
		alert("Error occured");
	}
});

c_view.addEventListener("pointerout", function(){
	//clear cursor
	requestAnimationFrame(function(){
		dynamic_ui_ctx.clearRect(0,0,dynamic_ui.width,dynamic_ui.height);
	});
});


c_view.addEventListener("pointerenter", function(){
	//clear cursor
	var activeElement = document.activeElement;
	var activeElementType = activeElement.getAttribute("type");
	
	if(activeElementType == "radio" || activeElementType == "checkbox" || activeElementType == "range"){
		//console.log("blurring");
		activeElement.blur();
		this.focus();
	}
	
});
//
c_view.addEventListener("touchend", function(){
//optional - resets cursor position to center if drawing with touch
	canvas_view.cursor_posX = Math.floor(c_view_rect_x + c_view.offsetWidth/2);
	canvas_view.cursor_posY = Math.floor(c_view_rect_y + c_view.offsetHeight/2);
});


canvas_view.container.addEventListener("pointermove", function(e){
	var cv = canvas_view;
	e.stopPropagation();
	//if(cv.cursor_pos_lock == 0){
		cv.cursor_posX = e.x;
		cv.cursor_posY = e.y;
	//}
});
canvas_view.container.addEventListener("wheel", function(e){
	if(keys[17]){//Ctrl / cmd
	//if(e.ctrlKey){
		e.preventDefault();
		e.stopPropagation();
		if(e.deltaY<0){
			canvas_view.zoomIn();
		}else{
			canvas_view.zoomOut();
		}
		canvas_view.makeCursor(current_tool,current_bay.size);
		canvas_view.drawCursor();
	}
});


//brush size screen
UI.brush_size_screen.addEventListener("pointermove", function(e){
	e.stopPropagation();
	var margin = 50;
	//for brush size
	var edx = e.x - canvas_view.cursor_posX;
	var edx_abs = Math.abs(edx);
	var dx = 0;
	if(edx != 0){
		dx = (Math.max(0 , edx_abs-margin) ) * (edx_abs / edx);
	}
	//brush size cursor
	if(current_tool == "brush_tool" || current_tool == "eraser_tool"){
		//need to use bay value instead of brush because of pressure running size changes
		var b_size = current_bay.getSize();
		let b_size_r = b_size/2;
		if(dx < 0){
		//reducing size as a percentage 
			b_size = Math.max(1, Math.round( 2*( b_size_r + (b_size_r/300*dx ) ) ) );
		}else if(dx > 0){
		//increasing size using zoom factor with actual pixels
			b_size = Math.max(1, Math.round( 2*( b_size_r + (dx/canvas_view.current_zoom) ) ) );
		}
		UI.bay_size_value.value = b_size;
		UI.bay_size_slider.value = baySizeUIVtoS(b_size);
		canvas_view.makeCursor(current_tool,b_size);
		canvas_view.drawCursor();
	}
});

//helper function for quick zoom knob
function timedQuickZoom(f_call,val){
	if(canvas_view.quick_zoom_active == true){
	
		canvas_view[f_call](val);
		canvas_view.makeCursor(current_tool,current_bay.size);
		canvas_view.drawCursor();
		
		setTimeout(function(){
			timedQuickZoom(f_call,val);
		},16);
	}
}
//quick zoom knob binds
UI.zoom_in_knob.addEventListener("pointerdown", function(e){
	this.setPointerCapture(e.pointerId);
	canvas_view.quick_zoom_active = true;
	timedQuickZoom("zoomIn", 1.025);
});

UI.zoom_in_knob.addEventListener("pointerup", function(e){
	canvas_view.quick_zoom_active = false;
});

UI.zoom_out_knob.addEventListener("pointerdown", function(e){
	this.setPointerCapture(e.pointerId);
	canvas_view.quick_zoom_active = true;
	timedQuickZoom("zoomOut", 1.025);
	
	if(selection_module.selection_active == true){
		selection_module.clearSelectionView();
	}
});

UI.zoom_out_knob.addEventListener("pointerup", function(e){
	canvas_view.quick_zoom_active = false;
	if(selection_module.selection_active == true){
		selection_module.makeSelectionOutline();
	}
});
//

//color picker active canvas
UI.cpf_selector.addEventListener("pointerdown", function(e){
	color_picker.mouseIsDown = true;
	UI.cp_bs_screen.style.display = "block";
	color_picker.selectSB(e.x,e.y);
});

UI.cp_bs_screen.addEventListener("pointermove", function(e){
	e.stopPropagation();
	if(!color_picker.mouseIsDown) return;
	color_picker.selectSB(e.x,e.y);
});

UI.cp_bs_screen.addEventListener("pointerup", function(){
	color_picker.mouseIsDown = false;
	UI.cp_bs_screen.style.display = "none";
	if(color_picker.auto_apply){
		applyColorPickerColor();
	}
});

UI.cpf_hue_selector.addEventListener("pointerdown", function(e){
	color_picker.mouseIsDown = true;
	UI.cp_hue_screen.style.display = "block";
	color_picker.selectHue(e.y);
});

UI.cp_hue_screen.addEventListener("pointermove", function(e){
	e.stopPropagation();
	if(!color_picker.mouseIsDown) return;
	color_picker.selectHue(e.y);
});

UI.cp_hue_screen.addEventListener("pointerup", function(){
	color_picker.mouseIsDown = false;
	UI.cp_hue_screen.style.display = "none";
	if(color_picker.auto_apply){
		applyColorPickerColor();
	}
});

UI.cp_sample.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	dragWindow["down"](UI.color_picker_menu,e);
});

UI.cp_drag_bar.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	dragWindow["down"](UI.color_picker_menu,e);
});

UI.dragWindow_screen.addEventListener("pointermove", function(e){
	e.stopPropagation();
	dragWindow["move"](e);
});

UI.dragWindow_screen.addEventListener("pointerup", function(e){
	e.stopPropagation();
	dragWindow["up"]();
});

//cp user input H S B and R G B Hex
UI.cp_r_input.addEventListener("change",function(){
	color_picker.processRGBInput([parseInt(UI.cp_r_input.value),parseInt(UI.cp_g_input.value),parseInt(UI.cp_b_input.value)]);
	if(color_picker.auto_apply){
		applyColorPickerColor();
	}
});
UI.cp_g_input.addEventListener("change",function(){
	color_picker.processRGBInput([parseInt(UI.cp_r_input.value),parseInt(UI.cp_g_input.value),parseInt(UI.cp_b_input.value)]);
	if(color_picker.auto_apply){
		applyColorPickerColor();
	}
});
UI.cp_b_input.addEventListener("change",function(){
	color_picker.processRGBInput([parseInt(UI.cp_r_input.value),parseInt(UI.cp_g_input.value),parseInt(UI.cp_b_input.value)]);
	if(color_picker.auto_apply){
		applyColorPickerColor();
	}
});
UI.cp_hex_input.addEventListener("change",function(){
	color_picker.processRGBInput(HextoRGB(UI.cp_hex_input.value));
	if(color_picker.auto_apply){
		applyColorPickerColor();
	}
});
UI.cp_hue_input.addEventListener("change",function(){
	color_picker.processHueInput(parseInt(UI.cp_hue_input.value));
	if(color_picker.auto_apply){
		applyColorPickerColor();
	}
});
UI.cp_saturation_input.addEventListener("change",function(){
	color_picker.processSInput(parseInt(UI.cp_saturation_input.value));
	if(color_picker.auto_apply){
		applyColorPickerColor();
	}
});
UI.cp_brightness_input.addEventListener("change",function(){
	color_picker.processBInput(parseInt(UI.cp_brightness_input.value));
	if(color_picker.auto_apply){
		applyColorPickerColor();
	}
});
UI.cp_dropper_mode.addEventListener("change", function(){
	if(UI.cp_dropper_mode.checked){
		color_picker.dropper_mode = "layer";
	}else{
		color_picker.dropper_mode = "view";
	}
});


document.addEventListener("fullscreenchange", function (event) {
    if (document.fullscreenElement) {
        // fullscreen is activated
		fullscreen_state = true;
		
		//UI fullscreen alterations
		//left toolbar
		/*
		UI.zoom_fit.classList.remove("tool-btn-mini");
		UI.zoom_scale_one.classList.remove("tool-btn-mini");
		UI.zoom_toggle.classList.remove("tool-btn-mini");
		*/
		//
    } else {
        // fullscreen is cancelled
		fullscreen_state = false;
		
		//UI fullscreen alterations
		//left toolbar
		/*
		UI.zoom_fit.classList.add("tool-btn-mini");
		UI.zoom_scale_one.classList.add("tool-btn-mini");
		UI.zoom_toggle.classList.add("tool-btn-mini");
		*/
		//
    }
});
//full screen toggler
UI.fullscreen_toggle.addEventListener("click", function(e){
	e.stopPropagation();
	if(fullscreen_state){
		closeFullscreen();
	}else{
		openFullscreen();
	}
});


//
//color filter UI bind 
UI.cf_apply_btn.addEventListener("click", function(e){e.stopPropagation();performColorFilterOptions("apply");});
UI.cf_cancel_btn.addEventListener("click", function(e){e.stopPropagation();performColorFilterOptions("cancel");});
UI.cf_reset_values_btn.addEventListener("click", function(e){e.stopPropagation();performColorFilterOptions("reset_values");});
UI.cf_reset_ranges_btn.addEventListener("click", function(e){e.stopPropagation();performColorFilterOptions("reset_ranges");});
UI.cf_preview.addEventListener("change", function(e){e.stopPropagation();colorFilter.setValue("preview_active",this.checked);performColorFilterOptions("toggle_preview");});
UI.cf_mem.addEventListener("change", function(e){e.stopPropagation();colorFilter.setValue("mem_active",this.checked);});

UI.cf_hue_value.addEventListener("change", function(e){e.stopPropagation();colorFilter.setValue("h_val",parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_hue_slider.addEventListener("input", function(e){e.stopPropagation();parseSlider(this,"cf_hue_value");});
UI.cf_hue_slider.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_hue_value");colorFilter.setValue("h_val",parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_desat_hue.addEventListener("change", function(e){e.stopPropagation();colorFilter.setValue("desat_hue",this.checked);performColorFilterOptions("preview");});
UI.cf_saturation_value.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_saturation_slider");colorFilter.setValue("s_val",parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_saturation_slider.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_saturation_value");colorFilter.setValue("s_val",parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_saturation_slider.addEventListener("input", function(e){parseSlider(this,"cf_saturation_value");});
UI.cf_brightness_value.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_brightness_slider");colorFilter.setValue("b_val",parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_brightness_slider.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_brightness_value");colorFilter.setValue("b_val",parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_brightness_slider.addEventListener("input", function(e){parseSlider(this,"cf_brightness_value");});
UI.cf_gamma_value.addEventListener("change", function(e){
	e.stopPropagation();
	UI.cf_gamma_slider.value = colorFilter.parseUIGammaInput(parseFloat(this.value),1);
	colorFilter.setValue("g_val",parseFloat(this.value));performColorFilterOptions("preview");
});
UI.cf_gamma_slider.addEventListener("change", function(e){
	e.stopPropagation();
	UI.cf_gamma_value.value = colorFilter.parseUIGammaInput(parseInt(this.value),0);
	colorFilter.setValue("g_val",parseFloat(UI.cf_gamma_value.value));performColorFilterOptions("preview");
});
UI.cf_gamma_slider.addEventListener("input", function(e){UI.cf_gamma_value.value = colorFilter.parseUIGammaInput(parseInt(this.value),0);});
UI.cf_softlight_value.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_softlight_slider");colorFilter.setValue("softlight_val",parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_softlight_slider.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_softlight_value");colorFilter.setValue("softlight_val",parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_softlight_slider.addEventListener("input", function(e){parseSlider(this,"cf_softlight_value");});
//UI.cf_hardlight_value.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_hardlight_slider");colorFilter.setValue("hardlight_val",parseInt(this.value));performColorFilterOptions("preview");});
//UI.cf_hardlight_slider.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_hardlight_value");colorFilter.setValue("hardlight_val",parseInt(this.value));performColorFilterOptions("preview");});
//UI.cf_hardlight_slider.addEventListener("input", function(e){parseSlider(this,"cf_hardlight_value");});
UI.cf_vibrance_value.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_vibrance_slider");colorFilter.setValue("vibrance_val",parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_vibrance_slider.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_vibrance_value");colorFilter.setValue("vibrance_val",parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_vibrance_slider.addEventListener("input", function(e){parseSlider(this,"cf_vibrance_value");});
UI.cf_contrast_value.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_contrast_slider");colorFilter.setValue("contrast_val",parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_contrast_slider.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_contrast_value");colorFilter.setValue("contrast_val",parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_contrast_slider.addEventListener("input", function(e){parseSlider(this,"cf_contrast_value");});


//limit
UI.cf_hue_limit_lower_value.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_hue_limit_lower_slider");colorFilter.setRange("h_range",0,parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_hue_limit_upper_value.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_hue_limit_upper_slider");colorFilter.setRange("h_range",1,parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_hue_limit_lower_slider.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_hue_limit_lower_value");colorFilter.setRange("h_range",0,parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_hue_limit_lower_slider.addEventListener("input", function(e){parseSlider(this,"cf_hue_limit_lower_value");});
UI.cf_hue_limit_upper_slider.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_hue_limit_upper_value");colorFilter.setRange("h_range",1,parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_hue_limit_upper_slider.addEventListener("input", function(e){parseSlider(this,"cf_hue_limit_upper_value");});

UI.cf_saturation_limit_lower_value.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_saturation_limit_lower_slider");colorFilter.setRange("s_range",0,parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_saturation_limit_upper_value.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_saturation_limit_upper_slider");colorFilter.setRange("s_range",1,parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_saturation_limit_lower_slider.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_saturation_limit_lower_value");colorFilter.setRange("s_range",0,parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_saturation_limit_lower_slider.addEventListener("input", function(e){parseSlider(this,"cf_saturation_limit_lower_value");});
UI.cf_saturation_limit_upper_slider.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_saturation_limit_upper_value");colorFilter.setRange("s_range",1,parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_saturation_limit_upper_slider.addEventListener("input", function(e){parseSlider(this,"cf_saturation_limit_upper_value");});

UI.cf_brightness_limit_lower_value.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_brightness_limit_lower_slider");colorFilter.setRange("b_range",0,parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_brightness_limit_upper_value.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_brightness_limit_upper_slider");colorFilter.setRange("b_range",1,parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_brightness_limit_lower_slider.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_brightness_limit_lower_value");colorFilter.setRange("b_range",0,parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_brightness_limit_lower_slider.addEventListener("input", function(e){parseSlider(this,"cf_brightness_limit_lower_value");});
UI.cf_brightness_limit_upper_slider.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"cf_brightness_limit_upper_value");colorFilter.setRange("b_range",1,parseInt(this.value));performColorFilterOptions("preview");});
UI.cf_brightness_limit_upper_slider.addEventListener("input", function(e){parseSlider(this,"cf_brightness_limit_upper_value");});

UI.cf_drag_bar.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	dragWindow["down"](UI.color_filter_menu,e);
});


// brush presets UI binds
UI.bpl_drag_bar.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	dragWindow["down"](UI.brush_preset_lib,e);
});

UI.brush_preset_config_name.addEventListener("change", function(e){
	e.stopPropagation();
	bp_keeper.setSelectedPresetValue("name",this.value);
	//check and update hover name on bay
	let preset = bp_keeper.selected_preset;
	let bay_index = bay_keeper.getBayIndexByBrushId(preset.id);
	if(bay_index !== null){
		UI["bay_"+bay_index].setAttribute("title",bay_keeper.getBay(bay_index).activeBrushPreset.name);
	}
	bp_keeper.updateUIPresetName();
});
//
UI.brush_preset_size_value.addEventListener("change", function(e){
	e.stopPropagation();
	UI.brush_preset_size_slider.value = baySizeUIVtoS(parseInt(this.value));
	bp_keeper.setSelectedPresetValue("size",parseInt(this.value));
	//update preset icon
	brushTipSampleImgMaker.updateBrushPresetIcon(bp_keeper.contents_preview_image[bp_keeper.selected_preset_i], 
												bp_keeper.selected_preset);
});
UI.brush_preset_size_slider.addEventListener("change", function(e){
	e.stopPropagation();
	bp_keeper.setSelectedPresetValue("size",parseInt(UI.brush_preset_size_value.value));
	//update preset icon
	brushTipSampleImgMaker.updateBrushPresetIcon(bp_keeper.contents_preview_image[bp_keeper.selected_preset_i], 
												bp_keeper.selected_preset);
});
UI.brush_preset_size_slider.addEventListener("input", function(e){UI.brush_preset_size_value.value = baySizeUIStoV(parseInt(this.value));});
//
UI.brush_preset_opacity_value.addEventListener("change", function(e){
	e.stopPropagation();
	parseSlider(this,"brush_preset_opacity_slider");
	bp_keeper.setSelectedPresetValue("opacity",parseInt(this.value)/100);
});
UI.brush_preset_opacity_slider.addEventListener("change", function(e){
	e.stopPropagation();
	bp_keeper.setSelectedPresetValue("opacity",parseInt(UI.brush_preset_opacity_value.value)/100);
});
UI.brush_preset_opacity_slider.addEventListener("input", function(e){parseSlider(this,"brush_preset_opacity_value");});
//
UI.brush_preset_flow_value.addEventListener("change", function(e){
	e.stopPropagation();
	parseSlider(this,"brush_preset_flow_slider");
	bp_keeper.setSelectedPresetValue("flow",parseInt(this.value)/100);
});
UI.brush_preset_flow_slider.addEventListener("change", function(e){
	e.stopPropagation();
	bp_keeper.setSelectedPresetValue("flow",parseInt(UI.brush_preset_flow_value.value)/100);
});
UI.brush_preset_flow_slider.addEventListener("input", function(e){parseSlider(this,"brush_preset_flow_value");});
//
UI.brush_preset_hardness_value.addEventListener("change", function(e){
	e.stopPropagation();
	parseSlider(this,"brush_preset_hardness_slider");
	bp_keeper.setSelectedPresetValue("hardness",parseInt(this.value)/100);
	//update preset icon
	if(bp_keeper.selected_preset.brush_type == "default"){
		brushTipSampleImgMaker.updateBrushPresetIcon(bp_keeper.contents_preview_image[bp_keeper.selected_preset_i], 
												bp_keeper.selected_preset);
		//alternative version with image replacement
		//bp_keeper.setPresetPreviewImg(bp_keeper.selected_preset_i);
		//bp_keeper.updateUIPresetPreviewImg(bp_keeper.selected_preset_i);
	}
});
UI.brush_preset_hardness_slider.addEventListener("change", function(e){
	e.stopPropagation();
	bp_keeper.setSelectedPresetValue("hardness",parseInt(UI.brush_preset_hardness_value.value)/100);
	//update preset icon
	if(bp_keeper.selected_preset.brush_type == "default"){
		brushTipSampleImgMaker.updateBrushPresetIcon(bp_keeper.contents_preview_image[bp_keeper.selected_preset_i], 
												bp_keeper.selected_preset);
		
		//bp_keeper.setPresetPreviewImg(bp_keeper.selected_preset_i);
		//bp_keeper.updateUIPresetPreviewImg(bp_keeper.selected_preset_i);
	}
});
UI.brush_preset_hardness_slider.addEventListener("input", function(e){parseSlider(this,"brush_preset_hardness_value");});
//
UI.brush_preset_spacing_value.addEventListener("change", function(e){
	e.stopPropagation();
	parseSlider(this,"brush_preset_spacing_slider");
	bp_keeper.setSelectedPresetValue("spacing",parseInt(this.value)/100);
});
UI.brush_preset_spacing_slider.addEventListener("change", function(e){
	e.stopPropagation();
	parseSlider(this,"brush_preset_spacing_value");
	bp_keeper.setSelectedPresetValue("spacing",parseInt(UI.brush_preset_spacing_value.value)/100);
});
UI.brush_preset_spacing_slider.addEventListener("input", function(e){parseSlider(this,"brush_preset_spacing_value");});
//
UI.brush_preset_direction.addEventListener("change", function(e){
	e.stopPropagation();
	bp_keeper.setSelectedPresetValue("directionEnabled",this.checked);
});
//
UI.brush_preset_size_pressure.addEventListener("change", function(e){
	e.stopPropagation();
	bp_keeper.setSelectedPresetValue("sizePressureEnabled",this.checked);
});
//
UI.brush_preset_size_pressure_min_d.addEventListener("change", function(e){
	e.stopPropagation();
	bp_keeper.setSelectedPresetValue("sizePressureMinDiameter",parseInt(this.value)/100);
});
//
UI.brush_preset_flow_pressure.addEventListener("change", function(e){
	e.stopPropagation();
	bp_keeper.setSelectedPresetValue("flowPressureEnabled",this.checked);
});
//
UI.brush_preset_brush_type_default.addEventListener("change", function(e){
	e.stopPropagation();
	bp_keeper.setSelectedPresetValue("brush_type",this.value);
	bp_keeper.setSelectedPresetValue("custom_tip",null);
	
	bp_keeper.setPresetPreviewImg(bp_keeper.selected_preset_i);
	bp_keeper.updateUIPresetPreviewImg(bp_keeper.selected_preset_i);
	
	UI.brush_preset_custom_tip_file.value = "";
	
	uc_keeper.notifyLibUpdateNeeded("brushPresetImgData",bp_keeper.selected_preset.id,2);
});
//
UI.brush_preset_brush_type_custom.addEventListener("change", function(e){
	e.stopPropagation();
	UI.brush_preset_custom_tip_file.click();
});
//
UI.brush_preset_custom_tip_file.addEventListener("change", function(e){
	var imgReader = encodeImageFileAsURL(this);
	imgReader.onload = function(){
		bp_keeper.setSelectedPresetCustomTip(imgReader.result);
	}
});
//
UI.brush_preset_blend_assist.addEventListener("change", function(e){
	e.stopPropagation();
	bp_keeper.setSelectedPresetValue("blend_assist",this.checked);
});
//
UI.brush_preset_flip_x_jitter.addEventListener("change", function(e){
	e.stopPropagation();
	bp_keeper.setSelectedPresetValue("flip_x_jitter",this.checked);
});
//
UI.brush_preset_flip_y_jitter.addEventListener("change", function(e){
	e.stopPropagation();
	bp_keeper.setSelectedPresetValue("flip_y_jitter",this.checked);
});
//
UI.brush_preset_angle_jitter.addEventListener("change", function(e){
	e.stopPropagation();
	bp_keeper.setSelectedPresetValue("angle_jitter",parseInt(this.value));
});
//
UI.brush_preset_scatter_distance.addEventListener("change", function(e){
	e.stopPropagation();
	bp_keeper.setSelectedPresetValue("scatter_distance",parseInt(this.value)/100);
});
//
UI.brush_preset_scatter_size_jitter.addEventListener("change", function(e){
	e.stopPropagation();
	bp_keeper.setSelectedPresetValue("scatter_size_jitter",parseInt(this.value)/100);
});
//
UI.brush_preset_roundness_jitter.addEventListener("change", function(e){
	e.stopPropagation();
	bp_keeper.setSelectedPresetValue("roundness_jitter",parseInt(this.value)/100);
});
//
UI.brush_preset_scatter_count.addEventListener("change", function(e){
	e.stopPropagation();
	bp_keeper.setSelectedPresetValue("scatter_count",parseInt(this.value));
});
//
UI.brush_preset_scatter_count_jitter.addEventListener("change", function(e){
	e.stopPropagation();
	bp_keeper.setSelectedPresetValue("scatter_count_jitter",parseInt(this.value));
});
// lower buttons panel
UI.bay_brush_select.addEventListener("click", function(e){
	e.stopPropagation();
	if(UI.brush_preset_lib.style.display != ""){
		db_keeper.updateDBLib();
	}
	toggleUIMenu(UI.brush_preset_lib);
});

UI.brush_preset_close_btn.addEventListener("click", function(e){
	e.stopPropagation();
	UI.brush_preset_lib.style.display = "";
	db_keeper.updateDBLib();
});
//
UI.brush_preset_new_btn.addEventListener("click", function(e){
	e.stopPropagation();
	bp_keeper.preset_id_counter++;
	bp_keeper.makeBlankPreset();
	//notify user config keeper about a change
	uc_keeper.notifyLibUpdateNeeded("brushPresetConfigData",bp_keeper.selected_preset.id,bp_keeper.selected_preset);
	uc_keeper.notifyGenUpdateNeeded("generalConfig","brushPresetOrder");
	
	bp_keeper.setPresetPreviewImg(bp_keeper.selected_preset_i);
	bp_keeper.stackBrushPresetsUI();
	bp_keeper.updateUIPresetConfigValues();
});
//
UI.brush_preset_duplicate_btn.addEventListener("click", function(e){
	e.stopPropagation();
	bp_keeper.duplicatePreset(bp_keeper.selected_preset);
	bp_keeper.setPresetPreviewImg(bp_keeper.selected_preset_i);
	bp_keeper.stackBrushPresetsUI();
	bp_keeper.updateUIPresetConfigValues();
});
//
UI.brush_preset_capture_bay_btn.addEventListener("click", function(e){
	e.stopPropagation();
	bp_keeper.captureBay();
	bp_keeper.setPresetPreviewImg(bp_keeper.selected_preset_i);
	bp_keeper.stackBrushPresetsUI();
	bp_keeper.updateUIPresetConfigValues();
});
//
UI.brush_preset_capture_layer_btn.addEventListener("click", function(e){
	e.stopPropagation();
	bp_keeper.captureLayer();
	bp_keeper.setPresetPreviewImg(bp_keeper.selected_preset_i);
	bp_keeper.stackBrushPresetsUI();
	bp_keeper.updateUIPresetConfigValues();
});
//
UI.brush_preset_delete_btn.addEventListener("click", function(e){
	e.stopPropagation();
	var preset = bp_keeper.deletePreset(bp_keeper.selected_preset_i);
	if(preset == null)return;
	//notify user config keeper about a change
	uc_keeper.notifyLibUpdateNeeded("brushPresetConfigData",preset.id,2);
	uc_keeper.notifyLibUpdateNeeded("brushPresetImgData",preset.id,2);
	uc_keeper.notifyGenUpdateNeeded("generalConfig","brushPresetOrder");
	
	bp_keeper.selectPreset(Math.max(0,bp_keeper.selected_preset_i-1));
	bp_keeper.stackBrushPresetsUI();
	bp_keeper.updateUIPresetConfigValues();
});
//
UI.brush_preset_use_btn.addEventListener("click", function(e){
	e.stopPropagation();
	current_bay.loadBrushPreset(bp_keeper.selected_preset);
	updateUIBayValues();
	canvas_view.makeCursor(current_tool,current_bay.size);
	//brush icon
	brushTipSampleImgMaker.updateBayIcon(UI["bay_"+bay_keeper.selected_bay_i+"_icon"],current_bay);
	UI["bay_"+bay_keeper.selected_bay_i].setAttribute("title",current_bay.activeBrushPreset.name);
	//
	if(current_bay.brush.blend_assist_default){
		touch_module.toggleTouchKeyOnUI("blend_assist_tool");
	}else{
		touch_module.toggleTouchKeyOffUI("blend_assist_tool");
	}
	//
	uc_keeper.notifyGenUpdateNeeded("generalConfig","bay_"+bay_keeper.selected_bay_i+"_config");
	uc_keeper.notifyGenUpdateNeeded("generalConfig","bay_"+bay_keeper.selected_bay_i+"_basic");
});
//
UI.brush_preset_import_btn.addEventListener("click", function(e){
	e.stopPropagation();
	UI.ts_brush_preset_import.click();
});
UI.ts_brush_preset_import.addEventListener("change", function(e){
	bp_keeper.importPreset(this);
});
//
UI.brush_preset_export_btn.addEventListener("click", function(e){
	e.stopPropagation();
	bp_keeper.exportPreset();
});






//Reference Layer Library binds / Palette library
UI.rlp_drag_bar.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	dragWindow["down"](UI.ref_layer_lib,e);
});
//
UI.ref_layer_preset_config_name.addEventListener("change", function(e){
	e.stopPropagation();
	rlp_keeper.setSelectedPresetValue("name",this.value);
	rlp_keeper.stackRefLayerPresetsUI();
});
//
UI.ref_layer_config_align_left.addEventListener("change", function(e){
	e.stopPropagation();
	rlp_keeper.setSelectedPresetValue("ref_image_align",this.value);
});
//
UI.ref_layer_config_align_center.addEventListener("change", function(e){
	e.stopPropagation();
	rlp_keeper.setSelectedPresetValue("ref_image_align",this.value);
});
//
UI.ref_layer_config_align_right.addEventListener("change", function(e){
	e.stopPropagation();
	rlp_keeper.setSelectedPresetValue("ref_image_align",this.value);
});
//
UI.ref_layer_preset_img_file.addEventListener("change", function(e){
	var imgReader = encodeImageFileAsURL(this);
	imgReader.onload = function(){
		rlp_keeper.setSelectedPresetImage(imgReader.result);
	}
});
//
UI.ref_layer_preset_close_btn.addEventListener("click", function(e){
	e.stopPropagation();
	hideUIElement(UI.ref_layer_lib);
	db_keeper.updateDBLib();
});
//
UI.ref_layer_preset_new_btn.addEventListener("click", function(e){
	e.stopPropagation();
	rlp_keeper.preset_id_counter++;
	rlp_keeper.makeBlankPreset();
	//notify user config keeper about a change
	uc_keeper.notifyLibUpdateNeeded("refPresetConfigData",rlp_keeper.selected_preset.id,rlp_keeper.selected_preset);
	uc_keeper.notifyGenUpdateNeeded("generalConfig","refPresetOrder");
	
	rlp_keeper.stackRefLayerPresetsUI();
	rlp_keeper.updateUIPresetConfigValues();
});
//
UI.ref_layer_preset_delete_btn.addEventListener("click", function(e){
	e.stopPropagation();
	var preset = rlp_keeper.deletePreset(rlp_keeper.selected_preset_i);
	if(preset == null)return;
	//notify user config keeper about a change
	uc_keeper.notifyLibUpdateNeeded("refPresetConfigData",preset.id,2);
	uc_keeper.notifyLibUpdateNeeded("refPresetImgData",preset.id,2);
	uc_keeper.notifyGenUpdateNeeded("generalConfig","refPresetOrder");
	
	rlp_keeper.selectPreset(Math.max(0,rlp_keeper.selected_preset_i-1));
	rlp_keeper.stackRefLayerPresetsUI();
	rlp_keeper.updateUIPresetConfigValues();
	//note: uc gets notified in rlp_keeper
});
//
UI.ref_layer_preset_capture_btn.addEventListener("click", function(e){
	e.stopPropagation();
	rlp_keeper.makeCapturePreset();
	rlp_keeper.stackRefLayerPresetsUI();
	rlp_keeper.updateUIPresetConfigValues();
	
	//notify user config keeper about a change
	uc_keeper.notifyLibUpdateNeeded("refPresetConfigData",rlp_keeper.selected_preset.id,rlp_keeper.selected_preset);
	uc_keeper.notifyLibUpdateNeeded("refPresetImgData",rlp_keeper.selected_preset.id,rlp_keeper.selected_preset);
	uc_keeper.notifyGenUpdateNeeded("generalConfig","refPresetOrder");
});
//
UI.ref_layer_preset_export_btn.addEventListener("click", function(e){
	e.stopPropagation();
	rlp_keeper.exportPresetImage();
});
//
UI.ref_layer_preset_fav_btn.addEventListener("click", function(e){
	e.stopPropagation();
	rlp_keeper.setPresetFav(rlp_keeper.selected_preset_i);
	rlp_keeper.selectPreset(0);
	//notify user config keeper about a change
	uc_keeper.notifyGenUpdateNeeded("generalConfig","refPresetOrder");
	//uc_keeper.notifyGenUpdateNeeded("generalConfig","refPresetFav");
	
	rlp_keeper.stackRefLayerPresetsUI();
});
//
UI.ref_layer_preset_use_btn.addEventListener("click", function(e){
	e.stopPropagation();
	rlp_keeper.usePreset(rlp_keeper.selected_preset_i);
});

//Canvas Size binds
UI.doc_cs_close_btn.addEventListener("click", function(e){e.stopPropagation();hideUIElement(UI.doc_canvas_size);});
//
UI.doc_cs_apply_btn.addEventListener("click", function(e){
	e.stopPropagation();
	if( !(parseInt(UI.doc_cs_width.value) > 0 && parseInt(UI.doc_cs_height.value) > 0) ){
		alert("Please provide Width and Height values of at least 1 pixel each");
		return;
	}
	solidifySpree();
	history_keeper.store("snapshot",current_tool,toolset_mode,selected_layer_i);
	resizeCanvas(Math.max(1,parseInt(UI.doc_cs_width.value)),Math.max(1,parseInt(UI.doc_cs_height.value)),parseInt(getRadioGroupValue("doc_cs_anchor_group")));
	hideUIElement(UI.doc_canvas_size);
	
	canvas_view.zoomFit();
	canvas_view.makeCursor(current_tool,current_bay.size);
	
	stackLiveView();
	stackLayersUI();
	selection_module.makeSelectionOutline();
});
//
UI.doc_cs_aspect_lock.addEventListener("change", function(e){
	e.stopPropagation();
	if(UI.doc_cs_aspect_lock.checked && parseInt(UI.doc_cs_width.value) > 0){
		UI.doc_cs_height.value = Math.max(1, Math.round( parseInt(UI.doc_cs_width.value) * drawingAreaHeight / drawingAreaWidth ) );
	}
});
//
UI.doc_cs_width.addEventListener("input", function(e){
	if(UI.doc_cs_aspect_lock.checked && parseInt(UI.doc_cs_width.value) > 0){
		UI.doc_cs_height.value = Math.max(1, Math.round( parseInt(UI.doc_cs_width.value) * drawingAreaHeight / drawingAreaWidth ) );
	}
});
//
UI.doc_cs_height.addEventListener("input", function(e){
	if(UI.doc_cs_aspect_lock.checked && parseInt(UI.doc_cs_height.value) > 0){
		UI.doc_cs_width.value = Math.max(1, Math.round( parseInt(UI.doc_cs_height.value) * drawingAreaWidth / drawingAreaHeight ) );
	}
});

//Image Size binds
UI.doc_imgs_close_btn.addEventListener("click", function(e){e.stopPropagation();hideUIElement(UI.doc_image_size);});
//
UI.doc_imgs_apply_btn.addEventListener("click", function(e){
	e.stopPropagation();
	solidifySpree();
	history_keeper.store("snapshot",current_tool,toolset_mode,selected_layer_i);
	resizeImage(Math.max(1,parseInt(UI.doc_imgs_width.value)),Math.max(1,parseInt(UI.doc_imgs_height.value)),UI.doc_imgs_antialias.checked);
	hideUIElement(UI.doc_image_size);
	
	
	canvas_view.zoomFit();
	canvas_view.makeCursor(current_tool,current_bay.size);
	stackLiveView();
	stackLayersUI();
	selection_module.makeSelectionOutline();
});
//
UI.doc_imgs_aspect_lock.addEventListener("change", function(e){
	e.stopPropagation();
	if(UI.doc_imgs_aspect_lock.checked && parseInt(UI.doc_imgs_width.value) > 0){
		UI.doc_imgs_height.value = Math.max(1, Math.round( parseInt(UI.doc_imgs_width.value) * drawingAreaHeight / drawingAreaWidth ) );
	}
});
//
UI.doc_imgs_width.addEventListener("input", function(e){
	if(UI.doc_imgs_aspect_lock.checked && parseInt(UI.doc_imgs_width.value) > 0){
		UI.doc_imgs_height.value = Math.max(1, Math.round( parseInt(UI.doc_imgs_width.value) * drawingAreaHeight / drawingAreaWidth ) );
	}
});
//
UI.doc_imgs_height.addEventListener("input", function(e){
	if(UI.doc_imgs_aspect_lock.checked && parseInt(UI.doc_imgs_height.value) > 0){
		UI.doc_imgs_width.value = Math.max(1, Math.round( parseInt(UI.doc_imgs_height.value) * drawingAreaWidth / drawingAreaHeight ) );
	}
});

//make new document binds
UI.doc_new_close_btn.addEventListener("click", function(e){
	e.stopPropagation();
	doc_config_keeper.closeMenu();
});
UI.doc_new_open_btn.addEventListener("click", function(e){
	e.stopPropagation();
	doc_config_keeper.closeMenu();
	general_menu_map["file"]["open"]();
});
UI.doc_new_create_btn.addEventListener("click", async function(e){
	e.stopPropagation();
	
	//
	if(gf.getOPIDStamp() != history_keeper.getOPID()){
	//saving project changes
	//using custom dialog box
		switch(await dialog_box.confirm('Save changes to the project "'+gf.proj_meta.name+'" ?', 
								[["Yes","yes"],["No","no"],["Cancel","cancel"]])){
			
			case "yes":
				//console.log("saving file");
				saveAsFile("project");
			break;
			//
			case "no":
			
			break;
			//
			case "cancel":
				return;
			break;
		}
	}
	//
	
	let w = doc_config_keeper.getConfig("w");
	let h = doc_config_keeper.getConfig("h");
	let units = doc_config_keeper.getConfig("units");
	let dpi = doc_config_keeper.getConfig("dpi");
	try{
		makeNewDocument(convertUnitsPxCmIn(w, units, "px", dpi), 
						convertUnitsPxCmIn(h, units, "px", dpi));
		//
		gf.proj_meta.name = doc_config_keeper.getConfig("name");
		//
		doc_config_keeper.addPrevPreset();
		doc_config_keeper.updateUIPrevPresets();
		//
		uc_keeper.notifyGenUpdateNeeded("generalConfig","DocNewPrevPresets");
	}catch(err){
		console.log(err);
		alert(err);
	}
	
	move_module.updateUIConfigMenu();
	move_module.updateUITransformControls();
	doc_config_keeper.closeMenu();
});
//
UI.doc_new_name.addEventListener("change", function(e){
	e.stopPropagation();
	doc_config_keeper.setConfig("name", this.value);
});
//
UI.doc_new_units_container.addEventListener("click", function(e){
	e.stopPropagation();
	if(e.target.checked != true) return false;
	
	var doc_new_units_value = e.target.value;
	var w = parseFloat(UI.doc_new_width.value);
	var h = parseFloat(UI.doc_new_height.value);
	w = convertUnitsPxCmIn(w, 
		doc_config_keeper.getUnits(), doc_new_units_value, 
		doc_config_keeper.getDPI());
	h = convertUnitsPxCmIn(h, 
		doc_config_keeper.getUnits(), doc_new_units_value, 
		doc_config_keeper.getDPI());
	
	if(doc_new_units_value != "px"){
	//make things pretty
		w = parseFloat( ( Math.round(w*1000) / 1000 ).toFixed(3) );
		h = parseFloat( ( Math.round(h*1000) / 1000 ).toFixed(3) );
	}
	UI.doc_new_width.value = w;
	UI.doc_new_height.value = h;
	
	doc_config_keeper.setUnits(doc_new_units_value);
	doc_config_keeper.setConfig("w", w);
	doc_config_keeper.setConfig("h", h);
});
//
UI.doc_new_width.addEventListener("change", function(e){
	e.stopPropagation();
	var w = parseFloat(UI.doc_new_width.value);
	if(w <= 0 
		|| (doc_config_keeper.config.units == "px" && w < 1) 
		|| isNaN(w)){
		w = 1;
		UI.doc_new_width.value = w;
	}
	doc_config_keeper.setConfig("w",w);
	// orientation monitoring
	doc_config_keeper.updateUIOrientation();
	
});
UI.doc_new_width.addEventListener("input", function(e){
	e.stopPropagation();
	if(doc_config_keeper.getConfig("units") == "px"){
		this.value = sanitizeInt(this.value);
	}else{
		this.value = sanitizeNumber(this.value);
	}
});
//
UI.doc_new_height.addEventListener("change", function(e){
	e.stopPropagation();
	var h = parseFloat(UI.doc_new_height.value);
	if(h <= 0 
		|| (doc_config_keeper.config.units == "px" && h < 1) 
		|| isNaN(h)){
		h = 1;
		UI.doc_new_height.value = h;
	}
	doc_config_keeper.setConfig("h",h);
	// orientation monitoring
	doc_config_keeper.updateUIOrientation();
	
});
UI.doc_new_height.addEventListener("input", function(e){
	e.stopPropagation();
	if(doc_config_keeper.getConfig("units") == "px"){
		this.value = sanitizeInt(this.value);
	}else{
		this.value = sanitizeNumber(this.value);
	}
});
//
UI.doc_new_orientation_landscape.addEventListener("click", function(e){
	e.stopPropagation();
	var min_value = Math.min(UI.doc_new_width.value, UI.doc_new_height.value);
	var max_value = Math.max(UI.doc_new_width.value, UI.doc_new_height.value);
	doc_config_keeper.setConfig("w", max_value);
	doc_config_keeper.setConfig("h", min_value);
	UI.doc_new_width.value = max_value;
	UI.doc_new_height.value = min_value;
});
UI.doc_new_orientation_portrait.addEventListener("click", function(e){
	e.stopPropagation();
	var min_value = Math.min(UI.doc_new_width.value, UI.doc_new_height.value);
	var max_value = Math.max(UI.doc_new_width.value, UI.doc_new_height.value);
	doc_config_keeper.setConfig("w", min_value);
	doc_config_keeper.setConfig("h", max_value);
	UI.doc_new_width.value = min_value;
	UI.doc_new_height.value = max_value;
});
//
UI.doc_new_dpi.addEventListener("change", function(e){
	e.stopPropagation();
	let dpi = parseInt(UI.doc_new_dpi.value);
	if(dpi <= 0 || isNaN(dpi)){
		dpi = 300;
		this.value = dpi;
	}
	doc_config_keeper.setConfig("dpi",dpi);
});
UI.doc_new_dpi.addEventListener("input", function(e){
	this.value = sanitizeInt(this.value);
});
//
UI.doc_new_presets.addEventListener("click", function(e){
//note: seems like there is something that triggers this twice
//perhaps once on capture and once on bubbling
//or maybe label wrap click delegation is throwing it off
	e.stopPropagation();
	//e.preventDefault();
	if(e.target.checked != true) return false;
	
	var preset_i = parseInt(e.target.value);
	
	doc_config_keeper.selectPreset(preset_i);
	doc_config_keeper.updateUIDocConfig();
	
},false);


//Save as file binds
UI.saf_menu_close_btn.addEventListener("click", function(e){e.stopPropagation();hideUIElement(UI.save_as_file_menu);});
//
UI.saf_menu_doc_name.addEventListener("change", function(e){
	e.stopPropagation();
	gf.proj_meta.name = this.value;
});
//
UI.saf_menu_option_png_btn.addEventListener("click", function(e){
	e.stopPropagation();
	hideUIElement(UI.save_as_file_menu);
	saveAsFile("png");
});
//
UI.saf_menu_option_jpg_btn.addEventListener("click", function(e){
	e.stopPropagation();
	hideUIElement(UI.save_as_file_menu);
	saveAsFile("jpg",[parseFloat(UI.saf_menu_option_jpg_quality_slider.value)]);
});
UI.saf_menu_option_jpg_quality_slider.addEventListener("change", function(e){
	e.stopPropagation();
	uc_keeper.notifyGenUpdateNeeded("generalConfig", "misc_0");
});
//
UI.saf_menu_option_project_btn.addEventListener("click", function(e){
	e.stopPropagation();
	hideUIElement(UI.save_as_file_menu);
	saveAsFile("project");
});
//


//Manual menu
UI.manual_menu_close_btn.addEventListener("click", function(e){e.stopPropagation();hideUIElement(UI.manual_menu);});
//
UI.manual_menu_drag_bar.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	dragWindow["down"](UI.manual_menu,e);
});
UI.manual_index_link_container.addEventListener("click", function(e){
	var page_id = e.target.dataset.page_id;
	if(page_id !== undefined){
		e.stopPropagation();
		manual_keeper.selectPageById(page_id);
	}
	
});
//
//About menu
UI.about_close_btn.addEventListener("click", function(e){e.stopPropagation();hideUIElement(UI.about);});
//


//Hotkeys list
UI.hk_list_close_btn.addEventListener("click", function(e){e.stopPropagation();hideUIElement(UI.hk_list);});
//
UI.hkl_drag_bar.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	dragWindow["down"](UI.hk_list,e);
});
//





//////////////////////////////////////////////////
//KEY PRESSES for SHORTCUTS
/*
TODO maybe re-code this using map and keybind style
*/
//////////////////////////////////////////////////
//-----------------------------------HotKeys structures
//init hotkeys
var hk_binds = {
	//note: expressions require [ ] around them
	//Alt modifier
	"downAlt18" : function(e){
		e.preventDefault();
		//no specific Alt binds atm
		//mod map handles modifiers
	},
	"up18" : function(e){
		e.preventDefault();
		//no specific Alt binds atm
		//mod map handles modifiers
	},
	//Shift modifier
	//down Shift - color picker dropper
	"downShift16" : function(e){
		e.preventDefault();
		if(current_tool == "move_tool"){
		//do not change to dropper
		
		}else{
			//use color picker by default
			color_picker.openToolDropperCanvas();
		}
	},
	//up Shift - tool toggler will handle switch back from dropper to previous tool
	"up16" : function(e){
		e.preventDefault();
		if(current_tool == "move_tool"){
		//nothing
		
		}else{
			//return from color picker
			color_picker.closeToolDropperCanvas();
		}
	},
	
	//Ctrl modifier
	//down Ctrl
	"downCtrl17" : function(e){
		e.preventDefault();
		//no specific Ctrl binds atm
		//mod map handles modifiers
	},
	//up Ctrl
	"up17" : function(e){
		e.preventDefault();
		//no specific Ctrl binds atm
		//mod map handles modifiers
	},
	
	//Space modifier
	//down Space
	"down32" : function(e){
		//e.preventDefault();
		//quickMenuManager("down");
		e.preventDefault();
		canvas_view.openToolHand();
	},
	//up Space
	"up32" : function(e){
		//e.preventDefault();
		//quickMenuManager("up");
		e.preventDefault();
		canvas_view.closeToolHand();
	},
	
	//Q - quick menu
	"down81" : function(e){e.preventDefault();quickMenuManager("down");},
	"up81" : function(e){e.preventDefault();quickMenuManager("up");},
	
	//C - ref layer color picker
	"down67" : function(e){e.preventDefault();color_picker.openToolDropperRefLayer();},
	"up67" : function(e){e.preventDefault();color_picker.closeToolDropperRefLayer();},
	
	//F - color picker menu
	"down70" : function(e){e.preventDefault();toggleUIMenu(UI.color_picker_menu);},
	
	//D - eyedropper
	"down68" : function(e){e.preventDefault();color_picker.openToolDropperCanvas();},
	"up68" : function(e){e.preventDefault();color_picker.closeToolDropperCanvas();},
	
	//Z - blend assist toggle
	"down90" : function(e){
		e.preventDefault();
		//auto switch to brush and spree draw mode
		if(current_tool != "brush_tool"){
			changeTool("brush_tool");
		}else if(spree_mode == 1){
			setBrushSpreeMode(0);
		}
		current_bay.toggleBlendAssist();
	},
	"up90" : function(e){e.preventDefault();current_bay.resetBlendAssist();},
	
	//down X - spree mode toggle
	"down88" : function(e){e.preventDefault();spreeIndicatorSwitch();},
	
	//down Ctrl+A - select content
	"downCtrl65" : function(e){
		e.preventDefault();
		general_menu_map["select"]["select content"]();
		/*
		if(current_tool == "move_tool"){
			move_module.updateUIConfigMenu();
			move_module.updateUITransformControls();
		}
		*/
	},
	
	//down Ctrl+D - toggle selection
	"downCtrl68" : function(e){
		e.preventDefault();
		general_menu_map["select"]["toggle selection"]();
		/*
		if(current_tool == "move_tool"){
			//move_module.defineBoundingBox();
			move_module.updateUIConfigMenu();
			move_module.updateUITransformControls();
		}
		*/
	},
	
	//down Ctrl+B - selection from spree
	"downCtrl66" : function(e){
		e.preventDefault();
		general_menu_map["select"]["from spree"]();
	},
	
	/* this does not seem to register
	//down Ctrl+T - transform
	"downCtrl84" : function(e){
		e.preventDefault();
		if(current_tool != "move_tool"){
			changeTool("move_tool");
		}
	},
	*/
	
	//down Ctrl+0 - zoom fit
	"downCtrl48" : function(e){
		e.preventDefault();
		canvas_view.zoomFit();
		canvas_view.makeCursor(current_tool,current_bay.size);
		canvas_view.drawCursor();
	},
	
	//down R - zoom toggle
	"down82" : function(e){
		e.preventDefault();
		canvas_view.zoomToggle();
		canvas_view.makeCursor(current_tool,current_bay.size);
		canvas_view.drawCursor();
	},
	
	//down Shift+S - solidify spree
	"downShift83" : function(e){e.preventDefault();solidifySpree();},
	
	//down Ctrl+S - Save As
	"downCtrl83" : function(e){e.preventDefault();general_menu_map["file"]["save"]();},
	
	//down Delete - delete selected area
	"down46" : function(e){
		e.preventDefault();
		if(selection_module.selection_active == false)return;
		if(selected_layer.target == "layer"){
			solidifySpree();
			history_keeper.store("layer",current_tool,toolset_mode,selected_layer_i);
			selection_module.deleteSelectedArea(selected_layer.ctx);
		}else if(selected_layer.target == "mask"){
			history_keeper.store("mask",current_tool,toolset_mode,selected_layer_i);
			selection_module.deleteSelectedArea(selected_layer.mask_ctx);
		}
		selected_layer.updateView();
		stackLiveView();
	},
	
	//down B - select brush tool
	"down66" : function(e){e.preventDefault();changeTool("brush_tool");canvas_view.drawCursor();},
	
	// Bay 1-8 binds
	"down49" : function(e){e.preventDefault();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(0);selectBay(0);},
	"down50" : function(e){e.preventDefault();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(0);selectBay(1);},
	"down51" : function(e){e.preventDefault();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(0);selectBay(2);},
	"down52" : function(e){e.preventDefault();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(0);selectBay(3);},
	"down53" : function(e){e.preventDefault();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(0);selectBay(4);},
	"down54" : function(e){e.preventDefault();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(0);selectBay(5);},
	"down55" : function(e){e.preventDefault();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(0);selectBay(6);},
	"down56" : function(e){e.preventDefault();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(0);selectBay(7);},
	
	//down E - select eraser tool
	"down69" : function(e){e.preventDefault();changeTool("eraser_tool");canvas_view.drawCursor();},
	
	//down G - select bucket tool
	"down71" : function(e){e.preventDefault();changeTool("bucket_tool");},
	
	//down W - select auto select tool
	"down87" : function(e){e.preventDefault();changeTool("auto_select_tool");},
	
	//down M - select select tool
	"down77" : function(e){e.preventDefault();changeTool("select_tool");},
	
	//down V - select move tool
	"down86" : function(e){e.preventDefault();changeTool("move_tool");},
	
	//down L - select lasso tool
	"down76" : function(e){e.preventDefault();changeTool("lasso_tool");},
	
	//down H - hand/pan tool
	"down72" : function(e){
		e.preventDefault();
		canvas_view.openToolHand();
	},
	"up72" : function(e){
		e.preventDefault();
		canvas_view.closeToolHand();
	},
	
	//down O - brush clone sample
	"down79" : function(e){
		e.preventDefault();
		makeBrushCloneSample(canvas_view.cursor_posX, canvas_view.cursor_posY);
		toggleBayCloneMode(true);
		updateUIBayValues();
	},
	
	//Ctrl+U - open adjustments menu
	"downCtrl85" : function(e){
		e.preventDefault();
		general_menu_map["image"]["adjustments"]();
	},
	
	//Ctrl+Q - switch between recent tools - changed to ` 
	"down192" : function(e){
		e.preventDefault();
		changeTool(current_tool);
	},
	
	//Ctrl+I - invert colors
	"downCtrl73" : function(e){
		e.preventDefault();
		general_menu_map["filter"]["invert colors"]();
	},
	
	//Ctrl+Shift+U - turn black and white using green-weighed formula
	"downCtrlShift85" : function(e){
		e.preventDefault();
		general_menu_map["filter"]["bnw"]();
	},
	
	//Ctrl+Shift+O - desaturate by average
	"downCtrlShift79" : function(e){
		e.preventDefault();
		general_menu_map["filter"]["desaturate avg"]();
	},
	
	//Ctrl+J - duplicate layer
	"downCtrl74" : function(e){
		e.preventDefault();
		if(selected_layer_multi.length < 2){
		//duplicate selected layer
			performLayersOptionsMenu("duplicate");
		}else{
		//merge create when multiple layers are selected
			performLayersOptionsMenu("merge create");
		}
	},
	
	//note: copy, cut, paste are handled in system event
	//these are just to satisfy unknown bind filter
	//Ctrl+C - copy 
	"downCtrl67" : function(e){
		//e.preventDefault();
	},
	
	//Ctrl+X - cut 
	"downCtrl88" : function(e){
		//e.preventDefault();
	},
	
	//Ctrl+V - paste 
	"downCtrl86" : function(e){
		//e.preventDefault();
	},
	//
	
	//Ctrl+Z - undo
	"downCtrl90" : function(e){
		e.preventDefault();
		history_keeper.undo();
	},
	
	//Ctrl+Shift+Z - redo
	"downCtrlShift90" : function(e){
		e.preventDefault();
		history_keeper.redo();
	},
	
	//Ctrl+M - flip canvas horizontally / mirror
	"downCtrl77" : function(e){
		e.preventDefault();
		general_menu_map["image"]["fc horizontal"]();
	},
	
	// [ ] keys for increase and decrease brush size
	// ] - increase brush size
	"down221" : function(e){
		e.preventDefault();
		bay_keeper.quick_brush_size_active = true;
		timedQuickBrushSize(1.02);
	},
	"up221" : function(e){
		e.preventDefault();
		bay_keeper.quick_brush_size_active = false;
	},
	// [ - reduce brush size
	"down219" : function(e){
		e.preventDefault();
		bay_keeper.quick_brush_size_active = true;
		timedQuickBrushSize(0.98);
	},
	"up219" : function(e){
		e.preventDefault();
		bay_keeper.quick_brush_size_active = false;
	},
	
	//ARROW KEYS
	//note: arrow keys are excepted to have repeat key down events sent
	//ARROWS DOWN EVENTS
	//arrow LEFT
	"down37" : function(e){
		e.preventDefault();
		if(current_tool == "move_tool"){
			if(selection_module.selection_active == true)selection_module.clearSelectionView();
		
			move_module.nudgeDo(1);
		}else if(current_tool == "select_tool" || current_tool == "lasso_tool"){
			selection_module.nudgeDo(1);
		}
		//console.log("LEFT arrow");
	},
	//arrow UP
	"down38" : function(e){
		e.preventDefault();
		if(current_tool == "move_tool"){
			if(selection_module.selection_active == true)selection_module.clearSelectionView();
		
			move_module.nudgeDo(2);
		}else if(current_tool == "select_tool" || current_tool == "lasso_tool"){
			selection_module.nudgeDo(2);
		}
	},
	//arrow RIGHT
	"down39" : function(e){
		e.preventDefault();
		if(current_tool == "move_tool"){
			if(selection_module.selection_active == true)selection_module.clearSelectionView();
		
			move_module.nudgeDo(3);
		}else if(current_tool == "select_tool" || current_tool == "lasso_tool"){
			selection_module.nudgeDo(3);
		}
		//console.log("RIGHT arrow");
	},
	//arrow DOWN
	"down40" : function(e){
		e.preventDefault();
		if(current_tool == "move_tool"){
			if(selection_module.selection_active == true)selection_module.clearSelectionView();
			
			move_module.nudgeDo(4);
		}else if(current_tool == "select_tool" || current_tool == "lasso_tool"){
			selection_module.nudgeDo(4);
		}
		//console.log("DOWN arrow");
	},
	//ARROWS UP EVENTS
	//arrow LEFT
	"up37" : function(e){
		e.preventDefault();
		if(current_tool == "move_tool"){
			move_module.nudgeEnd();
		}else if(current_tool == "select_tool" || current_tool == "lasso_tool"){
			selection_module.nudgeEnd();
		}
		//console.log("LEFT arrow");
	},
	//arrow UP
	"up38" : function(e){
		e.preventDefault();
		if(current_tool == "move_tool"){
			move_module.nudgeEnd();
		}else if(current_tool == "select_tool" || current_tool == "lasso_tool"){
			selection_module.nudgeEnd();
		}
		//console.log("UP arrow");
	},
	//arrow RIGHT
	"up39" : function(e){
		e.preventDefault();
		if(current_tool == "move_tool"){
			move_module.nudgeEnd();
		}else if(current_tool == "select_tool" || current_tool == "lasso_tool"){
			selection_module.nudgeEnd();
		}
		//console.log("RIGHT arrow");
	},
	//arrow DOWN
	"up40" : function(e){
		e.preventDefault();
		if(current_tool == "move_tool"){
			move_module.nudgeEnd();
		}else if(current_tool == "select_tool" || current_tool == "lasso_tool"){
			selection_module.nudgeEnd();
		}
		//console.log("DOWN arrow");
	}
};
//---

var hk_tool_mod_map = {
//tool modifier key map
//tool name : [key_mode0, key_mode1, key_mode2, ... ] 
//note: any key can be a modifier key for a tool
	"move_tool" : [16, 17, 18],//Shift, Ctrl, Alt
	"auto_select_tool" : [16, 17, 18],//Shift, Ctrl, Alt
	"select_tool" : [16, 17, 18],//Shift, Ctrl, Alt
	"lasso_tool" : [16, 17, 18],//Shift, Ctrl, Alt
	
	//default generic order map: Shift, Ctrl, Alt
	"generic" : [16, 17, 18]//do not remove, generic is used when no tool name found
}

function hotKeys(){
	var hotk = this;
	hotk.binds = null;
	hotk.tool_mod_map = null;
	//used as counter for locking all hotkeys
	hotk.lock = 0;
}

hotKeys.prototype = {
	loadBinds : function(binds){
		var hotk = this;
		hotk.binds = binds;
	},
	
	loadToolModMap : function(tool_mod_map){
		var hotk = this;
		hotk.tool_mod_map = tool_mod_map;
	},
	
	process : function(ek,action){
		var hotk = this;
		if(hotk.lock > 0){
			ek.preventDefault();
			return 1;
		}
		
		var trigger = "";
		
		if(ek.altKey) trigger += "Alt";
		//treat cmd/meta like ctrl
		/* example on picking up both down and up
		// also note: perhaps can do just event.code
		if(ek.ctrlKey || ek.code == "ControlLeft" 
			|| ek.metaKey || ek.code == "MetaLeft") {
				trigger += "Ctrl";
		}
		*/
		if(ek.ctrlKey || ek.metaKey) trigger += "Ctrl";
		if(ek.shiftKey) trigger += "Shift";
		
		//distinguish order
		//has a bug related to action being up or down
		/*
		if(keys[ek.keyCode]){
			trigger += ek.keyCode;
		}else{
			trigger = ek.keyCode + trigger;
		}
		*/
		if(ek.code == "MetaLeft"){
		//handle cmd/meta as ctrl
			trigger += 17;
		}else{
			trigger += ek.keyCode;
		}
		trigger = action + trigger;
		
		//console.log(trigger);
		try{
			if(hotk.binds[trigger] !== undefined){
				hotk.binds[trigger](ek);
			}else{
			// disable all non-recognized default browser shortcuts
				ek.preventDefault();
				ek.stopPropagation();
			}
		}catch(err){
			alert(err);
		}
		
	},
	
	getToolModState : function(toolName){
		var hotk = this;
		var key_state_map = keys;//global key state tracking map
		
		if(toolName == null || hotk.tool_mod_map[toolName] === undefined){
			var tool_name = "generic";
		}else{
			var tool_name = toolName;
		}
		
		var tool_mod_state = [];
		for(let i=0; i < hotk.tool_mod_map[tool_name].length; i++){
			//keys[] lookup can have undefined
			/*
			if(key_state_map[ hotk.tool_mod_map[tool_name][i] ] == true){
				tool_mod_state.push(true);
			}else{
				tool_mod_state.push(false);
			}
			*/
			//shorter, possibly faster version:
			tool_mod_state.push(key_state_map[ hotk.tool_mod_map[tool_name][i] ] == true);
		}
		
		return tool_mod_state;
	},
	
	requestLock : function(){
		var denied = 0;//
		this.lock++;
		return denied;
	},
	
	requestUnlock : function(){
		var denied = 0;//
		this.lock = Math.max(0, this.lock-1);
		return denied;
	},
	
	setUnlock : function(){
		this.lock = 0;
	}
}

var hk = new hotKeys();
hk.loadBinds(hk_binds);
hk.loadToolModMap(hk_tool_mod_map);

const exceptedKeyDownRepeatList = {
	//arrow keys
	37 : true,//left
	38 : true,//top
	39 : true,//right
	40 : true//down
}
window.addEventListener("keydown",function(e){
	if(keys[e.keyCode] && exceptedKeyDownRepeatList[e.keyCode] != true){
		e.preventDefault();//to prevent repeated signals to pass, like spacebar scroll in chrome when held
		return;//prevent duplicated entries
	}
	if(document.activeElement.tagName != "INPUT"){//filter input field hotkey interaction
		
		//handle cmd key and additionally equal it to Ctrl for Mac
		if(e.metaKey == true)keys[17] = true;
		//
		keys[e.keyCode] = true;
		hk.process(e,"down");
	}else if(e.keyCode == 13){
		//deal with Enter key used in input field, blur the focus of element
		//to make way for hotkeys
		document.activeElement.blur();
	}
});

window.addEventListener("keyup",function(e){
	if(keys[e.keyCode]){//to prevent some interactions with input field filtering
		if(document.activeElement.tagName != "INPUT"){//filter input field hotkey interaction
			
			//handle cmd key and additionally equal it to Ctrl for Mac
			if(e.code == "MetaLeft" && e.ctrlKey == false)keys[17] = false;
			//
			keys[e.keyCode] = false;
			hk.process(e,"up");
		}
	}
});
//-----------------------------------HotKeys structures END

/* touch module / touch keys and gestures */

function touchModule(){
	var tm = this;
	
	//list of toggle touch keys, used for making keys state tracking
	//these correspond to id naming stored in UI
	tm.touch_keys_list = ["blend_assist_tool","color_palette_tool",
							"hand_tool","cp_dropper_tool",
							"tk_shift","tk_ctrl","tk_alt"];
	
	//toggle state tracker, 1 - active, 0 - inactive, similar to toggle on element
	tm.touch_keys_state = {};
	for(let i=0,len=tm.touch_keys_list.length; i<len; ++i){
		tm.touch_keys_state[ tm.touch_keys_list[i] ] = 0;
	}

	//touch key object that can be passed in place of a keyboard event for processing
	//also stores modifiers from one processing to the other
	//note: this way key combinations are also possible
	tm.touch_key_e = {};
	tm.touch_key_e.altKey = false;
	tm.touch_key_e.shiftKey = false;
	tm.touch_key_e.ctrlKey = false;
	tm.touch_key_e.metaKey = false;
	tm.touch_key_e.code = "";
	tm.touch_key_e.keyCode = "";
	tm.touch_key_e.preventDefault = function(){return};
	tm.touch_key_e.stopPropagation = function(){return};
	
	//gesture vars
	tm.gesture = {
		pan_zoom : {
			active : false,
			midpoint : {x:0,y:0},//used as anchor panX and panY
			dist : 0 //distance between two touch points
		}
	
	};
}

touchModule.prototype = {

	getTouchKeyToggleState : function(key_id){
		return this.touch_keys_state[key_id];
	},
	
	checkTouchKeyExists : function(key_id){
		//helper, checks UI and touch keys state tracker to make sure both exist
		return (key_id in UI) && (key_id in this.touch_keys_state);
	},
	
	toggleTouchKeyUI : function(key_id){
		var tm = this;
		
		var elem = UI[key_id];
		tm.touch_keys_state[key_id] = 1 - tm.touch_keys_state[key_id];
		elem.dataset.toggle = tm.touch_keys_state[key_id];
		
		return tm.touch_keys_state[key_id];
	},
	
	toggleTouchKeyOnUI : function(key_id){
		var tm = this;
		if(tm.touch_keys_state[key_id] == 1)return;
		
		var elem = UI[key_id];
		tm.touch_keys_state[key_id] = 1;
		elem.dataset.toggle = tm.touch_keys_state[key_id];
	},
	
	toggleTouchKeyOffUI : function(key_id){
		var tm = this;
		if(tm.touch_keys_state[key_id] == 0)return;
		
		var elem = UI[key_id];
		tm.touch_keys_state[key_id] = 0;
		elem.dataset.toggle = tm.touch_keys_state[key_id];
	},
	
	setTouchKeyToggleUI : function(key_id, val){
		var tm = this;
		if(tm.touch_keys_state[key_id] == val)return;
		
		var elem = UI[key_id];
		tm.touch_keys_state[key_id] = val;
		elem.dataset.toggle = tm.touch_keys_state[key_id];
	},
	
	toggleModKeyOn : function(key_id){
		var tm = this;
		
		//mutually exclusive
		tm.clearModKeys();
		
		tm.toggleTouchKeyOnUI(key_id);
		
		switch(key_id){
			case "tk_shift":
				keys[16] = true;
			break;
			//
			case "tk_ctrl":
				keys[17] = true;
			break;
			//
			case "tk_alt":
				keys[18] = true;
			break;
		}
	},
	
	toggleModKeyOff : function(key_id){
		var tm = this;
		
		tm.toggleTouchKeyOffUI(key_id);
		
		switch(key_id){
			case "tk_shift":
				keys[16] = false;
			break;
			//
			case "tk_ctrl":
				keys[17] = false;
			break;
			//
			case "tk_alt":
				keys[18] = false;
			break;
		}
	},
	
	clearModKeys : function(){
		var tm = this;
		
		tm.toggleTouchKeyOffUI("tk_shift");
		tm.toggleTouchKeyOffUI("tk_ctrl");
		tm.toggleTouchKeyOffUI("tk_alt");
		keys[16] = false;
		keys[17] = false;
		keys[18] = false;
	},
	
	invokeKeyCmd : function(key_cmd){
		//TODO
	}
}

var touch_module = new touchModule();

UI.tk_ctrl.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	let key_id = "tk_ctrl";
	if(touch_module.getTouchKeyToggleState(key_id) == 0){
		touch_module.toggleModKeyOn(key_id);
	}else{
		touch_module.toggleModKeyOff(key_id);
		//touch_module.toggleTouchKeyOffUI("hand_tool");
	}
	
	//auto close hand tool
	if(touch_module.getTouchKeyToggleState("hand_tool") == 1){
		setTimeout(function(){
			canvas_view.closeToolHand();
			touch_module.toggleTouchKeyOffUI("hand_tool");
		}, 300);
	}
});
UI.tk_alt.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	let key_id = "tk_alt";
	if(touch_module.getTouchKeyToggleState(key_id) == 0){
		touch_module.toggleModKeyOn(key_id);
	}else{
		touch_module.toggleModKeyOff(key_id);
		//touch_module.toggleTouchKeyOffUI("hand_tool");
	}
	
	//auto close hand tool
	if(touch_module.getTouchKeyToggleState("hand_tool") == 1){
		setTimeout(function(){
			canvas_view.closeToolHand();
			touch_module.toggleTouchKeyOffUI("hand_tool");
		}, 300);
	}
});
UI.tk_shift.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	let key_id = "tk_shift";
	if(touch_module.getTouchKeyToggleState(key_id) == 0){
		touch_module.toggleModKeyOn(key_id);
	}else{
		touch_module.toggleModKeyOff(key_id);
		//touch_module.toggleTouchKeyOffUI("hand_tool");
	}
	
	//auto close hand tool
	if(touch_module.getTouchKeyToggleState("hand_tool") == 1){
		setTimeout(function(){
			canvas_view.closeToolHand();
			touch_module.toggleTouchKeyOffUI("hand_tool");
		}, 300);
	}
});
// pan screen touch binds / gesture

canvas_view.pan_screen.addEventListener("touchstart", function(e){
	e.preventDefault();
	e.stopPropagation();
	
	const g = touch_module.gesture.pan_zoom;
	
	if(e.targetTouches.length == 1){
		g.active = true;
		g.midpoint.x = e.targetTouches[0].pageX;
		g.midpoint.y = e.targetTouches[0].pageY;
		canvas_view.panStart(g.midpoint);
		
	}else if(e.targetTouches.length > 1){
		g.active = true;
		var point_a = e.targetTouches[0];
		var point_b = e.targetTouches[1];
		
		g.midpoint.x = point_a.pageX + (point_b.pageX - point_a.pageX)/2;
		g.midpoint.y = point_a.pageY + (point_b.pageY - point_a.pageY)/2;
		canvas_view.panStart(g.midpoint);
		
		let diffX = point_b.pageX - point_a.pageX;
		let diffY = point_b.pageY - point_a.pageY;
		g.midpoint.dist = Math.sqrt( diffX*diffX + diffY*diffY );
		
	}
	
	
});
canvas_view.pan_screen.addEventListener("touchmove", function(e){
	e.preventDefault();
	e.stopPropagation();
	
	const g = touch_module.gesture.pan_zoom;
	const cv = canvas_view;
	
	if(e.targetTouches.length == 1){
	//pan 1 finger
		g.midpoint.x = e.targetTouches[0].pageX;
		g.midpoint.y = e.targetTouches[0].pageY;
		
		cv.panDo(g.midpoint);
		
	}else if(e.targetTouches.length > 1){
	//pan 2 fingers
		var point_a = e.targetTouches[0];
		var point_b = e.targetTouches[1];

		g.midpoint.x = point_a.pageX + (point_b.pageX - point_a.pageX)/2;
		g.midpoint.y = point_a.pageY + (point_b.pageY - point_a.pageY)/2;
		
		cv.panDo(g.midpoint);
		
		//pinch zoom

		let diffX = point_b.pageX - point_a.pageX;
		let diffY = point_b.pageY - point_a.pageY;
		let dist = Math.sqrt( diffX*diffX + diffY*diffY );
		
		let old_zoom = cv.current_zoom;
		//new zoom value
		let zoom = cv.current_zoom / g.midpoint.dist * dist;
		cv.setZoom(zoom)
		var c_rect = cv.content.getBoundingClientRect();
		cv.container.scrollLeft += Math.round((g.midpoint.x-c_rect.x)*cv.current_zoom/old_zoom - (g.midpoint.x-c_rect.x));
		cv.container.scrollTop += Math.round((g.midpoint.y-c_rect.y)*cv.current_zoom/old_zoom - (g.midpoint.y-c_rect.y));

		//
		g.midpoint.dist = dist;

	}
	
});
canvas_view.pan_screen.addEventListener("touchend", function(e){
	e.preventDefault();
	e.stopPropagation();
	const g = touch_module.gesture.pan_zoom;
	if(e.targetTouches.length == 1){
		g.midpoint.x = e.targetTouches[0].pageX;
		g.midpoint.y = e.targetTouches[0].pageY;
		canvas_view.panX = g.midpoint.x;
		canvas_view.panY = g.midpoint.y;
		
	}else if(e.targetTouches.length < 1){
		g.active = false;
		canvas_view.pan_active = false;
		canvas_view.pan_screen.style.cursor = "grab";
		touch_module.gesture.pan_zoom.active = false;
		
		canvas_view.makeCursor(current_tool,current_bay.size);
	}
});
/* touch module end */


/////////////////////////////////////////////UI SECTION
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

var dialog_box = {
//custom dialog box
//note: possible to expand to not just buttons for options
//note: also maybe add ability to set position of dialog window
//note: currently supports one dialog box active at a time
	init : function(){
		var dbox = this;
		
		//connect to UI
		dbox.UI = {
			box : UI.dialog_box,
			text : UI.dialog_box_text,
			options : UI.dialog_box_options,
		};
		
		dbox.result = null;//promise flag
	
		//bind dialog key processing
		dbox.UI.options.addEventListener("click", function(e){
			e.stopPropagation();
			var option_value = e.target.dataset.optionValue;
			if(option_value != undefined){
				dialog_box.result.resolve(option_value);
				hideUIElement(dialog_box.UI.box);
				dialog_box.result = null;//good to null previous promise reference
			}
		});
		
		dbox.btn_pool = [];
		dbox.parseButtonPool();
		
	},
	
	parseButtonPool : function(){
		var dbox = this;
		var contents = dbox.UI.options.children;
		var item;
		while(contents.length > 0){
			
			try{
				item = dbox.UI.options.removeChild(contents[0]);
			}catch(err){
				console.log(err);
				continue;
			}
			
			dbox.btn_pool.push(item);
		}
	},
	
	confirm : async function(prompt, buttons, blocking){
	//prompt - string representing text dialog
	//buttons - [ [btn_label, btn_value], ... ]
	//blocking - if true will block screen and keyboard TODO
		var dbox = this;
		if(dbox.result != null){
		//if there is another active dialog
			dbox.result.resolve("cancel");
			hideUIElement(dialog_box.UI.box);
		}
		
		dbox.setupDialog(prompt, buttons);
		showUIElement(dbox.UI.box);
		dbox.result = makePromiseFlag();

		return dbox.result;
	},
	
	setupDialog : function(prompt, buttons){
		var dbox = this;
		dbox.UI.text.textContent = prompt;
		dbox.UI.options.innerHTML = "";
		var btn;
		if(buttons == null || buttons.length < 1){
		//add close button
			btn = dbox.btn_pool[0];
			
			btn.textContent = "Ok";
			btn.dataset.optionValue = "ok";
			
			dbox.UI.options.append(btn);
		}else{
			var btn_num = Math.min(10,buttons.length);
			for(var i=0; i<btn_num; i++){
				btn = dbox.btn_pool[i];
				//
				try{
				
					btn.textContent = buttons[i][0];
					btn.dataset.optionValue = buttons[i][1];
					
					dbox.UI.options.append(btn);
					dbox.UI.options.append(" ");
				
				}catch(err){
					console.log(err);
					continue;
				}
				//
			}
		}
	}
}
dialog_box.init();
UI.dialog_box_drag_bar.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	dragWindow["down"](dialog_box.UI.box,e);
});


function attentionToElementAdd(elem, style){
//style - string class name
	if(!elem.classList.contains(style)){
		elem.classList.add(style);
	}
}
function attentionToElementRemove(elem, style){
	if(elem.classList.contains(style)){
		elem.classList.remove(style);
	}
}


var manual_keeper = {
	//
	page_id_map : {},// {page_id : page_node, ...}
	page_link_id_map : {},// {page_id : link_node, ...}
	page_index_map : [],//page nodes in order as they come
	
	selected_page : null,//page node
	selected_page_id : "",
	selected_page_link : null,//corresponding link node
	//
	manual_index_link_container : UI.manual_index_link_container,
	manual_page_container : UI.manual_page_container,
	manual_page_view : UI.manual_page_view,
	//
	
	parseUIManualPagePool : function(page_pool){
	//note: will empty and remove page_pool from DOM
		var mk = this;
		//note: auto_id is given when item has no id, but should have
		//like a page
		var link_container = document.createDocumentFragment();
		var elem;
		var m = [];
		//
		var item;
		var item_type;
		var item_id;
		var item_name;
		
		var auto_id_counter = 0;
		
		var contents = page_pool.children;
		
		while(contents.length > 0){
		//note: contents, being a live node collection, 
		//gets modified by node operations
			try{
			//node.removeChild will throw exception if something goes wrong
				item = page_pool.removeChild(contents[0]);
			}catch(err){
				console.log(err);
				continue;
			}
			
			item_type = item.dataset.item_type;
			
			switch(item_type){
				case "page":
					
					item_name = item.dataset.item_name;
					item_id = item.dataset.item_id;
					
					if( !(item_id.length > 0) ){
					//no id, give auto_id to a page
						item_id = auto_id_counter++;
						item.dataset.item_id = "auto_" + item_id;
					}
					
					mk.page_id_map[item_id] = item;
					mk.page_index_map.push(item);
					//
					elem = document.createElement("li");
					elem.className = "manual-index-link";
					elem.dataset.page_id = item_id;
					elem.dataset.selected = "0";
					elem.textContent = item_name;
					
					link_container.appendChild(elem);
					//
					mk.page_link_id_map[item_id] = elem;
					
				break;
				//
				case "spacer":
				
					elem = document.createElement("span");
					elem.className = "manual-index-spacer";
					
					link_container.appendChild(elem);
					
				break;
				//
				case "category":
				
					elem = document.createElement("span");
					elem.className = "manual-index-category";
					elem.textContent = item.textContent;
					
					link_container.appendChild(elem);
				
				break;
			}
			
			
		}
		//
		mk.manual_index_link_container.innerHTML = "";
		mk.manual_index_link_container.appendChild(link_container);
		//
		item = mk.page_index_map[0];
		mk.selected_page = item
		mk.selected_page_id = item.dataset.item_id;
		mk.selected_page_link = mk.page_link_id_map[ mk.selected_page_id ];
		//
		page_pool.remove();//remove page pool from DOM
	},
	
	selectPageById : function(page_id){
		var mk = this;
		
		if(mk.page_id_map[page_id] === undefined)return;
		
		mk.selected_page_link.dataset.selected = "0";
		mk.selected_page_link = mk.page_link_id_map[page_id];
		mk.selected_page_link.dataset.selected = "1";
		
		mk.manual_page_container.innerHTML = "";
		mk.manual_page_container.appendChild( mk.page_id_map[page_id] );
		//scroll to top, note that it's available only when menu is displayed
		mk.manual_page_view.scrollTop = 0;
		
		mk.pageFadeIn();
	},
	
	selectPageByIndex : function(page_i){
		var mk = this;
		
		if(page_i < 0 || page_i >= mk.page_index_map.length)return 1;
		
		var page_id = mk.page_index_map[page_i].dataset.item_id;
		
		mk.selected_page_link.dataset.selected = "0";
		mk.selected_page_link = mk.page_link_id_map[page_id];
		mk.selected_page_link.dataset.selected = "1";
		
		mk.manual_page_container.innerHTML = "";
		mk.manual_page_container.appendChild( mk.page_id_map[page_id] );
		//scroll to top, note that it's available only when menu is displayed
		mk.manual_page_view.scrollTop = 0;
		
		mk.pageFadeIn();
	},
	
	pageFadeIn : function(){
		var mk = this;
		//make things pretty
		mk.manual_page_container.classList.toggle("general-fade-transition");
		mk.manual_page_container.style.opacity = 0;
		void mk.manual_page_container.clientWidth;
		mk.manual_page_container.classList.toggle("general-fade-transition");
		mk.manual_page_container.style.opacity = 1;
	
	},
	
	demoToolOptions : function(n){
		
		switch(n){
			case 1:
				attentionToElementAdd(UI.tool_config_menu_btn, "element-attention-pulse");
				changeTool("bucket_tool");
				UI.tool_config_menu_toggler.checked = true;
			break;
			//
			case 2:
				changeTool("brush_tool");
			break;
			//
			case 3:
				changeTool("lasso_tool");
			break;
			//
			case 4:
				changeTool("select_tool");
			break;
			//
			case 5:
				changeTool("auto_select_tool");
			break;
			//
			case 6:
				changeTool("move_tool");
			break;
			//
			default:
				manual_keeper.selectPageById("tool_options");
				showUIElement(UI.manual_menu);
				setTimeout(function(){
					attentionToElementRemove(UI.tool_config_menu_btn, "element-attention-pulse");
				}, 900);
				return;
		}
		setTimeout( function(){manual_keeper.demoToolOptions(n+1)} , 1000);
	}

}

manual_keeper.parseUIManualPagePool(UI.manual_page_pool);
manual_keeper.selectPageById("welcome");//for release
//

function openFullscreen(){
	var elem = document.documentElement;
	if(elem.requestFullscreen){
		elem.requestFullscreen();
	}else if(elem.mozRequestFullScreen){ /* Firefox */
		elem.mozRequestFullScreen();
	}else if(elem.webkitRequestFullscreen){ /* Chrome, Safari and Opera */
		elem.webkitRequestFullscreen();
	}else if(elem.msRequestFullscreen){ /* IE/Edge */
		elem.msRequestFullscreen();
	}
}

function closeFullscreen(){
	var elem = document.documentElement;
	if(document.exitFullscreen){
		document.exitFullscreen();
	}else if(document.mozCancelFullScreen){ /* Firefox */
		document.mozCancelFullScreen();
	}else if(document.webkitExitFullscreen){ /* Chrome, Safari and Opera */
		document.webkitExitFullscreen();
	}else if(document.msExitFullscreen){ /* IE/Edge */
		document.msExitFullscreen();
	}
}

function quickMenuManager(btn_state){
//btn_state - down or up
	if(btn_state == "down"){
		
		if(!canvas_view.container.matches(':hover')){
		//make menu appear in center if there is no hover over canvas view
			canvas_view.cursor_posX = Math.floor(c_view_rect_x + c_view.offsetWidth/2);
			canvas_view.cursor_posY = Math.floor(c_view_rect_y + c_view.offsetHeight/2);
			if(current_tool == "brush_tool" || current_tool == "eraser_tool"){
				canvas_view.drawCursor();
			}
		}
		
		UI.brush_size_screen.style.display = "block";
		
		var c_rect = UI.brush_size_screen.getBoundingClientRect();
		UI.quick_zoom_panel.style.left = (canvas_view.cursor_posX-c_rect.x-50) + "px";
		UI.quick_zoom_panel.style.top = (canvas_view.cursor_posY-c_rect.y-50) + "px";
		
	}else if(btn_state == "up"){
		//canvas_view.requestCursorPosLock(false);
		UI.brush_size_screen.style.display = "none";
		
		if(current_tool == "brush_tool" || current_tool == "eraser_tool"){
			
			var b_size = parseInt(UI.bay_size_value.value);
			if(b_size != current_bay.size){
				setBaySize(b_size);
				//to deal with buggy fade:
				UI.bay_size_value.value = b_size;
				UI.bay_size_slider.value = baySizeUIVtoS(b_size);
				canvas_view.drawCursor();
				
				//brush icon
				brushTipSampleImgMaker.updateBayIcon(UI["bay_"+bay_keeper.selected_bay_i+"_icon"],current_bay);
			}
			
		}
	}//
}


//Layers UI functions/operations
function makeUILayerItem(layer_i,clippingMask_active){
	var elem = document.createElement('li');
	elem.className = 'layers-item';
	elem.dataset.layer_i = layer_i;
	
	elem.addEventListener("click",function(e){
		e.stopPropagation();
		var data_layer_i = parseInt(this.dataset.layer_i);
		if(keys[17]){//Ctrl / cmd
		//if(e.ctrlKey){
			if(selected_layer_i == data_layer_i)return;
			//check if item is already selected in multiple layer selection
			if(selected_layer_multi.includes(data_layer_i)){
				removeUILayerSelectionMulti(data_layer_i);
				removeLayerSelectionMulti(data_layer_i);
			}else{
				this.className+= " layers-item-selected-multi";
				addLayerSelectionMulti(data_layer_i);
			}
		}else if(keys[16]){
		//}else if(e.shiftKey){
			if(selected_layer_i == data_layer_i)return;
			resetLayerSelectionMulti();
			selected_layer_multi = [];
			
			if(selected_layer_i > data_layer_i){
				for(var k=selected_layer_i;k>data_layer_i-1;k--){
					addLayerSelectionMulti(k);
				}
			}else{
				for(var k=selected_layer_i;k<data_layer_i+1;k++){
					addLayerSelectionMulti(k);
				}
			}
			//show multi selection in UI
			addUILayerSelectionMulti();
			
		
		}else{
			solidifySpree();
			removeUILayerSelection();
			
			selectLayer(data_layer_i,"layer");
			
			//small optimization for consecutive single layer selections
			if(selected_layer_multi.length == 1){
				selected_layer_multi[0] = selected_layer_i;
			}else{
				//resetting multiple layer selection
				resetLayerSelectionMulti();
			}
			addUILayerSelection();
			updateUILayerSelection();
			
			stackLiveView();//to properly handle live_view_limited
		}
	});
	
	var m = [];
	//Eye
	m0 = document.createElement('span');
	m0.className = "layers-item-eye-container";
	elem.appendChild(m0);
	m0.addEventListener("click", function(e){e.stopPropagation();});
	
	m1 = document.createElement("label");
	m0.appendChild(m1);
	
	m2 = document.createElement("input");
	m2.setAttribute("type","checkbox");
	m2.className = "layers-item-eye-toggler hidden-toggler";
	m2.checked = gf.contents[layer_i].visible;
	m1.appendChild(m2);
	//adding layer number to children to avoid parent lookup
	m2.dataset.layer_i = layer_i;
	m2.addEventListener("change",function(e){
		e.stopPropagation();
		setLayerVisibility(this.dataset.layer_i, this.checked);
	});
	
	
	m3 = document.createElement('span');
	m3.className = "layers-item-eye icon-layers_eye"
	m1.appendChild(m3);
	
	m = [];//reset m for convenience
	//Clipping mask arrow
	if(clippingMask_active){
		m0 = document.createElement('span');
		m0.className = "layers-item-clipping-mask";
		elem.appendChild(m0);
	}
	
	//Layer Preview
	m0 = document.createElement('span');
	m0.className = "layer-preview";
	elem.appendChild(m0);
	
	m0.dataset.layer_i = layer_i;
	m0.addEventListener("click", function(e){
		if(keys[17]){//Ctrl / cmd
		//if(e.ctrlKey){
		//Ctrl+Click layer
			e.stopPropagation();
			//selection from layer view
			history_keeper.store("selection",current_tool,toolset_mode,selected_layer_i);
			selection_module.selectionFromLayer(this.dataset.layer_i);
			
			//
			if(current_tool == "move_tool"){
				move_module.updateUIConfigMenu();
				move_module.updateUITransformControls();
			}
		}
	});
	
	m1 = document.createElement('span');
	m1.className = "layers-item-canvas-align";
	m0.appendChild(m1);
	//append layer canvas
	m2 = gf.contents[layer_i].c;
	m2.className = "layers-item-canvas bg-checkerboard-small";
	m1.appendChild(m2);
	
	
	//Mask
	m0 = document.createElement('span');
	m0.className = "layers-item-mask";
	elem.appendChild(m0);
	m0.dataset.layer_i = layer_i;
	m0.addEventListener("click",function(e){
	
		e.stopPropagation();
		var data_layer_i = parseInt(this.dataset.layer_i);
		//Shift + Click - toggle layer mask
		if(keys[16]){
		//if(e.shiftKey){
			e.preventDefault();
			gf.contents[data_layer_i].toggleMask();
			toggleUILayerMaskEnabled(this,data_layer_i);
			
			stackLiveView();
		}else{
			solidifySpree();
			removeUILayerSelection();
			selectLayer(data_layer_i,"mask");
			resetLayerSelectionMulti();
			addUILayerSelection();
			updateUILayerSelection();
			
			stackLiveView();//to properly handle live_view_limited
		}
	});
	if(gf.contents[layer_i].mask == null){
		m0.style.visibility="hidden";
	}else{
		m1 = document.createElement('span');
		m1.className = "layers-item-canvas-align";
		m0.appendChild(m1);
		
		m2 = gf.contents[layer_i].mask;
		m2.className = "layers-item-canvas bg-black";
		m1.appendChild(m2);
		
		//disabled
		if(!gf.contents[layer_i].mask_enabled){
			m3 = document.createElement('span');
			m3.className = "layers-item-mask-disabled";
			m0.appendChild(m3);
		}
		
		
	}
	//mask move from one layer to another by drag
	//custom drag and drop
	elem.addEventListener("pointerdown",function(e){
		e.stopPropagation();
		if(e.pointerType == "touch"){
			clearTimeout(gf.drag_timeout);
			gf.drag_timeout = setTimeout(function(){
				gf.drag_mouseIsDown = true;
				gf.drag_timeout = null;
			},400);
		}else{
			gf.drag_mouseIsDown = true;
		}
	});
	//to prevent pointercancel and handle touch 
	elem.addEventListener("touchmove", function(e){
		if(gf.drag_mouseIsDown == true){
			e.preventDefault();
		}else{
			clearTimeout(gf.drag_timeout);
			gf.drag_timeout = null;
		}
	},true);
	elem.addEventListener("touchend", function(e){
		if(gf.drag_timeout != null){
			clearTimeout(gf.drag_timeout);
			gf.drag_timeout = null;
		}
	},true);

	
	elem.addEventListener("pointerenter", function(e){
		e.stopPropagation();
		if(gf.drag_drop_active == true && gf.drag_mouseIsDown == true){
			elem.classList.add("layers-item-dnd-drop");
		}
	});
	elem.addEventListener("pointerout", function(e){
		e.stopPropagation();
		if(gf.drag_mouseIsDown == true && gf.drag_drop_active == false){
			gf.drag_drop_active = true;
			gf.drag_obj_type = "layer";
			gf.drag_layer_i = parseInt(this.dataset.layer_i);
			this.classList.add("layers-item-dnd-drag");
			addUILayerDNDZoneCover();
		}
		if(gf.drag_drop_active == true && gf.drag_mouseIsDown == true){
			elem.classList.remove("layers-item-dnd-drop");
		}
	});
	elem.addEventListener("pointerup",function(e){
		e.stopPropagation();
		if(gf.drag_drop_active == true){
			removeUILayerDNDZoneCover();
			elem.classList.remove("layers-item-dnd-drag");
			elem.classList.remove("layers-item-dnd-drop");
			switch(gf.drag_obj_type){
				case "layer":
					performLayersOptionsMoveLayer(parseInt(this.dataset.layer_i));
				break;
				//
				case "mask":
					performLayersOptionsMoveMask(parseInt(this.dataset.layer_i), keys[17]);
				break;
			}
			gf.drag_drop_active = false;
		}
		if(gf.drag_mouseIsDown == true){
			gf.drag_mouseIsDown = false;
		}
	});
	//
	m0.addEventListener("pointerdown",function(e){
		e.stopPropagation();
		gf.drag_mouseIsDown = true;
	});
	m0.addEventListener("pointerout",function(e){
		e.stopPropagation();
		if(gf.drag_mouseIsDown == true && gf.drag_drop_active == false){
			gf.drag_drop_active = true;
			gf.drag_obj_type = "mask";
			gf.drag_layer_i = parseInt(this.dataset.layer_i);
			addUILayerDNDZoneCover();
		}
	});
	

	//custom drag and drop end
	
	
	//Name
	m0 = document.createElement('span');
	m0.className = "layers-item-name";
	m0.textContent = gf.contents[layer_i].name;
	m0.dataset.layer_i = layer_i;
	elem.appendChild(m0);
	m0.addEventListener("dblclick",function(e){
		var new_name = prompt("Layer Name",this.textContent);
		if(new_name != null){
			history_keeper.store("layerName",current_tool,toolset_mode,selected_layer_i);
			this.textContent = new_name;
			gf.contents[parseInt(this.dataset.layer_i)].setName(new_name);
		}
	});
	
	
	return elem;
}

function stackLayersUI(){
	var layers_ui = document.createDocumentFragment();
	var ls = [];//string stack 
	var clip_i = 0;
	for(var i=0;i<gf.contents.length;i++){
		if(clip_i > 0){
			clip_i--;
			ls.push(makeUILayerItem(i,true));
		}else{
			clip_i = gf.contents[i].clip;
			ls.push(makeUILayerItem(i,false));
		}
		
	}
	
	for(i=ls.length-1;i>-1;i--){
		layers_ui.appendChild(ls[i]);
	}
	//replace existing contents with new
	UI.layers_item_container.innerHTML = "";
	UI.layers_item_container.appendChild(layers_ui);
	addUILayerSelection();
	updateUILayerSelection();
	//reset multi layer selection to reflect UI
	selected_layer_multi = [selected_layer_i];
	//reset flags, maybe will help with some sticking
	gf.drag_mouseIsDown = false;
	gf.drag_drop_active = false;
	gf.drag_obj_type = "layer";
}

function updateUILayerEye(layer_i){
	//updates the eye icon single given layer index or all layers
	//note: relies on 1:1 UI layer child to layer index in bookKeeper
	var current_layer = null;
	//note: looks like UI layers and bookKeeper contents are in reverse order to each other
	if(layer_i != null){
		for(var i=0;i<UI.layers_item_container.children.length;i++){
			current_layer = UI.layers_item_container.children[i];
			if(parseInt(current_layer.dataset.layer_i) == layer_i){
				current_layer.getElementsByTagName("input")[0].checked = gf.contents[layer_i].visible;
				break;
			}
		}
	}else{
		for(var i=0;i<UI.layers_item_container.children.length;i++){
			current_layer = UI.layers_item_container.children[i];
			current_layer.getElementsByTagName("input")[0].checked = gf.contents[gf.contents.length-1-i].visible;
		}
	}
}

function setLayerVisibility(layer_i,val){
	gf.contents[layer_i].setVisibility(val);
	stackLiveView();
}

function toggleLayerVisibility(layer_i){
	gf.contents[layer_i].toggleVisibility();
	stackLiveView();
}

function removeUILayerSelection(){
	var layer_item = UI.layers_item_container.children[gf.contents.length-1-selected_layer_i];
	layer_item.classList.remove("layers-item-selected");
	layer_item.getElementsByClassName('layer-preview')[0].classList.remove("layers-item-target-selected");
	layer_item.getElementsByClassName('layers-item-mask')[0].classList.remove("layers-item-target-selected");
}

function removeUILayerSelectionMulti(layer_i){
	UI.layers_item_container.children[gf.contents.length-1-layer_i].classList.remove("layers-item-selected-multi");
}

function removeLayerSelectionMulti(layer_i){
	for(var i=0;i<selected_layer_multi.length;i++){
		if(selected_layer_multi[i] == layer_i){
			selected_layer_multi.splice(i,1);
			return;
		}
	}
}

function addLayerSelectionMulti(layer_i){
//in ascending order
	layer_i = parseInt(layer_i);
	start = selected_layer_multi[0];
	var i = 0;
	while(selected_layer_multi[i] < layer_i){
		i++;
	}
	selected_layer_multi.splice(i,0,layer_i);
}

function resetLayerSelectionMulti(){
	for(var i=0;i<selected_layer_multi.length;i++){
		removeUILayerSelectionMulti(selected_layer_multi[i]);
	}
	selected_layer_multi = [selected_layer_i];
}

function addUILayerSelection(){
	var layer_item = UI.layers_item_container.children[gf.contents.length-1-selected_layer_i];
	layer_item.className += " layers-item-selected";
	if(selected_layer.target == "layer"){
		layer_item.getElementsByClassName('layer-preview')[0].classList.add("layers-item-target-selected");
	}else if(selected_layer.target == "mask"){
		layer_item.getElementsByClassName('layers-item-mask')[0].classList.add("layers-item-target-selected");
	}
}

function addUILayerSelectionMulti(){
	for(var i=0;i<selected_layer_multi.length;i++){
		if(selected_layer_i != selected_layer_multi[i]){
			UI.layers_item_container.children[gf.contents.length-1-selected_layer_multi[i]].className += " layers-item-selected-multi";
		}
	}
}

function toggleUILayerMaskEnabled(mask_elem,layer_i){
	if(gf.contents[layer_i].mask_enabled){
		mask_elem.getElementsByClassName("layers-item-mask-disabled")[0].remove();
	}else{
		var m = document.createElement('span');
		m.className = "layers-item-mask-disabled";
		mask_elem.appendChild(m);
	}
}

function addUILayerDNDZoneCover(){
	//prepare drop zone of every layer
	let layers_item_list = UI.layers_item_container.getElementsByClassName("layers-item");
	for(let li=0;li<layers_item_list.length;li++){
		layers_item_list[li].classList.add("layers-item-dnd-zone-cover");
	}
}

function removeUILayerDNDZoneCover(){
	//prepare drop zone of every layer
	let layers_item_list = UI.layers_item_container.getElementsByClassName("layers-item");
	for(let li=0;li<layers_item_list.length;li++){
		layers_item_list[li].classList.remove("layers-item-dnd-zone-cover");
	}
}

//updates UI elements for layer like opacity and blending
function updateUILayerSelection(){
	UI.layer_opacity_value.value = Math.round(selected_layer.opacity*10*10);
	UI.layer_opacity_slider.value = UI.layer_opacity_value.value;
	UI.layer_blending.value = selected_layer.blending;
}


function performLayersOptions(option){

	//console.log(option);

	if(option == "mask"){
		solidifySpree();
		
		if(selected_layer.mask == null){
			history_keeper.store("arrangeMasks",current_tool,toolset_mode,selected_layer_i);
		}else{
			history_keeper.store("mask",current_tool,toolset_mode,selected_layer_i);
		}
		
		if(selection_module.selection_active){
		//embed selection into a mask
			selected_layer.addMask(true);
			selected_layer.mask_ctx.drawImage(selection_module.selection,0,0);
			selected_layer.mask_ctx.globalCompositeOperation = "source-atop";
			selected_layer.mask_ctx.fillStyle = "white";
			selected_layer.mask_ctx.fillRect(0,0, selected_layer.mask.width,selected_layer.mask.height);
			selected_layer.mask_ctx.globalCompositeOperation = "source-over";
			selected_layer.updateView();
			stackLiveView();
		}else{
			selected_layer.addMask();
		}
		//select mask upon creation
		selectLayer(selected_layer_i,"mask");
		//resetting multi-layer selection
		selected_layer_multi = [selected_layer_i];
		gf.updateIdMaskMap();
		stackLayersUI();
		
	}else if(option == "delete"){
		solidifySpree();
		if(selected_layer.target == "mask"){
		
			history_keeper.store("arrangeMasks",current_tool,toolset_mode,selected_layer_i);
			
			selected_layer.removeMask();
			selectLayer(selected_layer_i,"layer");
			//check if clip holder
			if(selected_layer.clip > 0){
				selected_layer.updateClippingMask();
			}
			
			gf.updateIdMaskMap();
			stackLayersUI();
			stackLiveView();
		}else if(selected_layer.target == "layer"){
		
			history_keeper.store("layerList",current_tool,toolset_mode,selected_layer_i);
			gf.makeNewLayerList();
			
			//delete multiple layers
			if(selected_layer_multi.length > 1){
				//first unclip each
				unclipMultiLayerCount(selected_layer_multi);
				
				deleteLayerMulti();
				selected_layer_i = selected_layer_multi[0]-1;
				if(selected_layer_i < 0)selected_layer_i = 0;
				selectLayer(selected_layer_i,"layer");
				//reset 
				selected_layer_multi = [selected_layer_i];
			}else{
			//delete single layer
				if(clipCheckLayer(selected_layer,selected_layer_i)[0])unclipSingleLayer(selected_layer,selected_layer_i);
				gf.removeAtIndex(selected_layer_i);
				selected_layer_i--;
				if(selected_layer_i < 0)selected_layer_i = 0;
				selectLayer(selected_layer_i,"layer");
			}
			
			gf.updateIdIndexMap();
			gf.updateClipMap();
			
			stackLayersUI();
			stackLiveView();
		}
	}else if(option == "layer"){
		solidifySpree();
		
		history_keeper.store("layerList",current_tool,toolset_mode,selected_layer_i);
		gf.makeNewLayerList();
		
		let clip_new_layer = clipCheckLayer(selected_layer,selected_layer_i);
		
		selected_layer_i++;
		layer_counter++;
		gf.addAtIndex(new layer("Layer "+layer_counter),selected_layer_i);
		selectLayer(selected_layer_i,"layer");
		
		if(clip_new_layer[0])clipSelectedLayer();
		
		//resetting multi-layer selection
		selected_layer_multi = [selected_layer_i];
		
		gf.updateIdIndexMap();
		gf.updateClipMap();
		
		stackLayersUI();
	}else if(option == "cl"){
		
		if(selected_layer.target == "layer"){
			solidifySpree();
			history_keeper.store("layer",current_tool,toolset_mode,selected_layer_i);
			selected_layer.clearTargetContent();
		}else if(selected_layer.target == "mask"){
			
			history_keeper.store("mask",current_tool,toolset_mode,selected_layer_i);
			
			if(canvasIsEmpty(selected_layer.mask_ctx)){
				selected_layer.fillMask("white");
			}else{
				selected_layer.clearTargetContent();
			}
		}
		
		
		stackLiveView();
	}else if(option == "vis"){
		gf.toggleVisibilityMultiple();
		updateUILayerEye();
		stackLiveView();
	}
	
}

function performLayersOptionsMenu(val){
	//console.log(val);
	
	switch(val){
	
		case "duplicate"://same as Ctrl+J bind
			solidifySpree();
			
			history_keeper.store("layerList",current_tool,toolset_mode,selected_layer_i);
			gf.makeNewLayerList();
			
			var clip_new_layer = clipCheckLayer(selected_layer,selected_layer_i);
			
			selected_layer_i++;
			gf.addAtIndex(duplicateLayer(selected_layer),selected_layer_i);
			selectLayer(selected_layer_i,"layer");
			selected_layer_multi = [selected_layer_i];
			if(clip_new_layer[0])clipSelectedLayer();
			//console.log(clip_new_layer);
			gf.updateClipMap();
			gf.updateIdIndexMap();
			
			stackLayersUI();
			stackLiveView();
		break;
		//
		case "clip":
			
			history_keeper.store("arrangeClip",current_tool,toolset_mode,selected_layer_i);
			
			if(selected_layer_multi.length > 1){
				for(var j=0;j<selected_layer_multi.length;j++){
					if(!clipCheckLayer(gf.getAtIndex(selected_layer_multi[j]),selected_layer_multi[j])[0]){
						clipSingleLayer(gf.getAtIndex(selected_layer_multi[j]),selected_layer_multi[j]);
					}
				}
			}else{
				if(!clipCheckLayer(selected_layer,selected_layer_i)[0]){
					clipSelectedLayer();
				}
			}
			
			gf.updateClipMap();
			
			selected_layer_multi = [selected_layer_i];
			stackLayersUI();
			stackLiveView();
		break;
		//
		case "unclip":
		
			history_keeper.store("arrangeClip",current_tool,toolset_mode,selected_layer_i);
			
			if(selected_layer_multi.length > 1){
				unclipMultiLayer(selected_layer_multi);
			}else{
				unclipSelectedLayer();
			}
			
			gf.updateClipMap();
			
			selected_layer_multi = [selected_layer_i];
			stackLayersUI();
			stackLiveView();
		break;
		//
		case "apply mask":
			solidifySpree();
			
			history_keeper.store("layerMaskApply",current_tool,toolset_mode,selected_layer_i);
			
			selected_layer.applyMask();
			selectLayer(selected_layer_i,"layer");
			gf.updateIdMaskMap();
			stackLayersUI();
		break;
		//
		case "merge create":
			solidifySpree();
			
			history_keeper.store("layerList",current_tool,toolset_mode,selected_layer_i);
			gf.makeNewLayerList();
			
			var clip_after = clipCheckLayer(gf.contents[ selected_layer_multi[selected_layer_multi.length-1] ], selected_layer_multi[selected_layer_multi.length-1]);
			if(clip_after[0] == true){
			//console.log("clipped");
				clip_after[1].clip++;
			}
			
			gf.addAtIndex(mergeLayers(selected_layer_multi),selected_layer_multi[selected_layer_multi.length-1]+1);
			selectLayer(selected_layer_multi[selected_layer_multi.length-1]+1,"layer");
			selected_layer_multi = [selected_layer_i];
			
			
			gf.updateClipMap();
			gf.updateIdIndexMap();
			
			stackLayersUI();
			stackLiveView();
		break;
		//
		case "merge":
			if(selected_layer_multi.length == gf.contents.length){
				
				performLayersOptionsMenu("flatten");
				
			}else if(selected_layer_multi.length > 1){
				solidifySpree();
				
				history_keeper.store("layerList",current_tool,toolset_mode,selected_layer_i);
				gf.makeNewLayerList();
				
				var merged_layer = mergeLayers(selected_layer_multi);
				var clip_after = clipCheckLayer(gf.contents[selected_layer_multi[0]],selected_layer_multi[0]);
				
				unclipMultiLayerCount(selected_layer_multi);
				deleteLayerMulti();
				
				gf.addAtIndex(merged_layer,selected_layer_multi[0]);
				if(clip_after[0] == true){
					clip_after[1].clip++;
				}
				
				selectLayer(selected_layer_multi[0],"layer");
				selected_layer_multi = [selected_layer_i];
				
				gf.updateClipMap();
				gf.updateIdIndexMap();
				
				stackLayersUI();
				stackLiveView();
			}
		break;
		//
		case "ref":
			rlp_keeper.addSelectedLayerToRef();
		break;
		//
		case "flatten":
			solidifySpree();
			
			history_keeper.store("snapshot",current_tool,toolset_mode,selected_layer_i);
			
			gf.flatten();
			selectLayer(0,"layer");
			selected_layer_multi = [selected_layer_i];
			
			gf.updateClipMap();
			gf.updateIdIndexMap();
			
			stackLayersUI();
			stackLiveView();
		break;
		//
	}

}

function performLayersOptionsMoveLayer(to_index){
	var from_index = gf.drag_layer_i;
	
	if(to_index == from_index)return;
	
	solidifySpree();
	
	gf.updateIdIndexMap();
	gf.updateClipMap();
	
	history_keeper.store("arrangeLayers",current_tool,toolset_mode,selected_layer_i);
	
	var clip_at_destination = false;
	
	var layer_src = gf.getAtIndex(from_index);
	var layer_dest = gf.getAtIndex(to_index);
	var clip_check_src = clipCheckLayer(layer_src,from_index);
	var clip_check_dest = clipCheckLayer(layer_dest,to_index);
	//relies on clipCheckLayer returning [true,clipperObj] or [false,null]
	if(clip_check_dest[0] && clip_check_dest[1] != clip_check_src[1]){
		clip_at_destination = true;
	}
	
	if(layer_src.clip > 0 || 
		(clip_check_src[0] && 
		(clip_check_src[1] != clip_check_dest[1] || layer_dest.clip>0) )){
		unclipSingleLayer(layer_src,from_index);
	}
	
	//adjust destination index
	if(from_index-to_index>1){
		to_index++;
	}
	
	gf.move(from_index,to_index);
	if(selected_layer_i == from_index){
		selectLayer(to_index,selected_layer.target);
	}else if(from_index > selected_layer_i && selected_layer_i >= to_index){
		selectLayer(selected_layer_i+1,selected_layer.target);
	}else if(from_index < selected_layer_i && selected_layer_i <= to_index){
		selectLayer(selected_layer_i-1,selected_layer.target);
	}
	
	if(clip_at_destination){
		clipSingleLayer(gf.getAtIndex(to_index),to_index);
	}
	
	selected_layer_multi = [selected_layer_i];
	
	gf.updateIdIndexMap();
	gf.updateClipMap();
	
	stackLayersUI();
	stackLiveView();
}

function performLayersOptionsMoveMask(to_index,copy_mode){
	var from_index = gf.drag_layer_i;
	
	if(to_index == from_index)return;
	
	gf.updateIdMaskMap();
	
	if(copy_mode == true){
		//copy mask
		
		history_keeper.store("arrangeMasks",current_tool,toolset_mode,selected_layer_i);
		
		gf.getAtIndex(to_index).copyMask(gf.getAtIndex(from_index));
		
		//console.log("copy mask");
	}else{
		//move
		
		history_keeper.store("arrangeMasks",current_tool,toolset_mode,selected_layer_i);
		
		gf.getAtIndex(to_index).insertMask(gf.getAtIndex(from_index));
		
		//moving currently active mask - deselect it
		if(selected_layer_i == from_index && gf.getAtIndex(from_index).target == "mask"){
			selected_layer.setTarget("layer");
		}
		
		gf.getAtIndex(from_index).removeMask();
		
		//console.log("move mask");
	}
	
	gf.updateIdMaskMap();
	stackLayersUI();
	stackLiveView();
}

//functions to process UI clicks

const toolOptionsUIMenuBinds = {
	"bucket_tool":UI.fill_config_menu,
	"auto_select_tool":UI.selection_config_menu,
	"lasso_tool":UI.lasso_config_menu,
	"select_tool":UI.select_area_config_menu,
	"move_tool":UI.move_config_menu,
	"brush_tool":UI.brush_config_menu,
	"eraser_tool":UI.eraser_config_menu,
}

function updateUIToolOptionsMenu(old_tool,new_tool){
	
	//hide existing
	if(toolOptionsUIMenuBinds[old_tool] != null){
		toolOptionsUIMenuBinds[old_tool].style.display = "none";
	}
	//show new tool
	if(toolOptionsUIMenuBinds[new_tool] == null){
		UI.tool_config_empty_menu.style.display = "block";
	}else{
		toolOptionsUIMenuBinds[new_tool].style.display = "block";
		UI.tool_config_empty_menu.style.display = "none";
	}
	
}

function updateUIToolbarSelection(){
	if(UI[current_tool]){
		UI[current_tool].checked = true;
	}
}

function changeTool(tool){
	
	//ui - remove focus from things like toolbar items after click
	var activeElement = document.activeElement;
	var activeElementType = activeElement.getAttribute("type");
	if(activeElementType == "radio" || activeElementType == "checkbox" || activeElementType == "range"){
		document.activeElement.blur();
	}
	//
	
	//cursor mode var
	var cursor_mode = "auto";
	
	
	//changing to tools that don't require special handling
	//go here, like: if(tool == "some_tool"){ activate it ... return }
	// ...
	
	
	//changing tool from things like cp_dropper_tool which don't go into toggler
	if(current_tool != tool_toggle[tool_toggle_i]){
		
		//switch out clean up for tools that don't go into toggler
		//go here, like if(current_tool == "some_tool"){ switch out of it }
		// ...
		

		//given tool is same as latest in tool_toggle
		if(tool == tool_toggle[tool_toggle_i]){
			current_tool = tool;
			tool_agent._updateCurrent();
			//
			if(tool == "brush_tool" || tool == "eraser_tool"){
				cursor_mode = "none";
				c_view.style.cursor = cursor_mode;
				canvas_view.drawCursor();
			}
			updateUIToolbarSelection();
			return;
		}
	}
	//----
	//tool toggle
	if(tool == tool_toggle[tool_toggle_i] && current_tool == tool_toggle[tool_toggle_i]){
		tool_toggle_i = 1-tool_toggle_i;
	}else{
		tool_toggle_i = 1-tool_toggle_i;
		tool_toggle[tool_toggle_i] = tool;
	}
	var old_tool = tool_toggle[1-tool_toggle_i];
	var new_tool = tool_toggle[tool_toggle_i];
	
	current_tool = old_tool;
	//can do switching out tool cleanup here
	
	if(old_tool == "move_tool"){
		//clean up
		hideUIElement(UI.mt_transform_box);
	}
	
	//----
	
	//may need rework with more tools added but for now ok
	if(new_tool == "brush_tool"){
		let blend_indicator_state = touch_module.getTouchKeyToggleState("blend_assist_tool");
		//
		current_tool = new_tool;
		setBrushSpreeMode(0);
		cursor_mode = "none";//hide system cursor
		updateUIBayValues();
		//
		if(blend_indicator_state){
			current_bay.setBlendAssist(true);
			touch_module.toggleTouchKeyOnUI("blend_assist_tool");
		}
	}else
	if(new_tool == "eraser_tool"){
		current_tool = new_tool;
		setBrushSpreeMode(0);
		cursor_mode = "none";//hide system cursor
		updateUIBayValues();
		
	}else
	if(new_tool == "bucket_tool"){
		if(old_tool == "brush_tool" || old_tool == "eraser_tool"){
			setBrushSpreeMode(0);
		}
		current_tool = new_tool;
		color_picker.updateColorId();
	}else
	if(new_tool == "lasso_tool"){
		current_tool = new_tool;
		selection_module.mode = 0;
	}else
	if(new_tool == "select_tool"){
		current_tool = new_tool;
		selection_module.mode = 0;
	}else
	if(new_tool == "auto_select_tool"){
		current_tool = new_tool;
		selection_module.mode = 0;
	}else
	if(new_tool == "move_tool"){
		current_tool = new_tool;
		move_module.updateUIConfigMenu();
		move_module.updateUITransformControls();
		showUIElement(UI.mt_transform_box);
	}
	
	tool_agent._updateCurrent();
	//cursor handling
	canvas_view.makeCursor(current_tool,current_bay.size);
	dynamic_ui_ctx.clearRect(0,0,dynamic_ui.width,dynamic_ui.height);
	c_view.style.cursor = cursor_mode;
	
	//update tool options menu
	updateUIToolOptionsMenu(old_tool,new_tool);
	updateUIToolbarSelection();
	
	
	//console.log(current_tool);
}

function toggleBrushSpreeMode(){
//MAYBE BUG, check how bay_keeper.select handles its own call on spree_mode change
//(no bug right now, it just sets the same bay_index that is read)
	spree_mode = 1-spree_mode;
	
	if(bay_keeper.single_brush_lock == true){
		bay_keeper.selectBay(bay_keeper.single_brush_bay);
	}else{
		bay_keeper.selectBay(bay_keeper.bay_tool[current_tool+"_"+spree_mode]);
	}
	
	//handle blend assist
	if(spree_mode == 1){
	//spree erasing
		current_bay.setBlendAssist(false);
		touch_module.toggleTouchKeyOffUI("blend_assist_tool");
	}
	
	let spree_mode_visual = (1-spree_mode)*255;
	UI.spree_indicator.style.background = "rgb("+[spree_mode_visual,spree_mode_visual,spree_mode_visual]+")";
	canvas_view.makeCursor(current_tool,current_bay.size);
}

function setBrushSpreeMode(mode){
	//note: also turns off blend assist
	spree_mode = mode;
	
	if(bay_keeper.single_brush_lock == true){
		bay_keeper.selectBay(bay_keeper.single_brush_bay);
	}else{
		bay_keeper.selectBay(bay_keeper.bay_tool[current_tool+"_"+spree_mode]);
	}
	
	//handle blend assist
	//if(spree_mode == 1){
		current_bay.setBlendAssist(false);
		touch_module.toggleTouchKeyOffUI("blend_assist_tool");
	//}
	
	let spree_mode_visual = (1-spree_mode)*255;
	UI.spree_indicator.style.background = "rgb("+[spree_mode_visual,spree_mode_visual,spree_mode_visual]+")";
	canvas_view.makeCursor(current_tool,current_bay.size);
}

function getRadioGroupValue(group_name){
	var radio_group = document.getElementsByName(group_name);
	
	for(var i=0;i<radio_group.length;i++){
		if(radio_group[i].checked)break;
	}
	if(!(i < radio_group.length)) return 0;
	
	return radio_group[i].value;
}

function selectRadioGroupBtn(group_name,index){
	var radio_group = document.getElementsByName(group_name);
	radio_group[index].checked = true;
}

function toggleUIMenu(menu){
	//note: "" empty string will revert computed style back to css stylesheet
	//due to essentially removing inline styling with js
	//expects display:none by default in css stylesheet
	if(menu.style.display == ""){
		menu.style.display = "block";
	}else{
		menu.style.display = "";
	}
}

function showUIElement(el){
	if(el.dataset.prev_display != null && el.dataset.prev_display != "" && el.dataset.prev_display != "none"){
		el.style.display = el.dataset.prev_display;
	}else{
		el.style.display = "block";
		el.dataset.prev_display = "block";
	}
	//to accomodate transitions
	void el.clientWidth;
	el.style.opacity = 1;
	
}

function hideUIElement(el, delay){
	el.style.opacity = 0;
	el.dataset.prev_display = el.style.display;
	
	if(delay != null){
	//transition fade out support
		setTimeout(function(){el.style.display = "none";}, delay);
	}else{
		el.style.display = "none";
	}
}

function showColorPicker(){
	UI.color_picker_menu.style.display = "block";
}

function hideColorPicker(){
	UI.color_picker_menu.style.display = "";
}

function toggleColorPicker(){
	if(UI.color_picker_menu.style.display == ""){
		UI.color_picker_menu.style.display = "block";
	}else{
		UI.color_picker_menu.style.display = "";
	}
}

function applyColorPickerColor(){
	//first switch to the drawing mode to get the active drawing bay
	try{
		current_color = color_picker.getColor();
		
		if(current_tool == "brush_tool"){
			setBrushSpreeMode(0);
			current_bay.setColor(current_color);
		}else if(current_tool == "cp_dropper_tool"){
			//set brush color from dropper
			if(tool_toggle[tool_toggle_i] == "brush_tool"){
				current_bay.setColor(current_color);
			}
		}
		color_picker.updateColorId();
	}catch(err){
		alert(err);
	}
	//check for auto solid maybe
	//also no need to solidify if eraser is active
	if(!spree_auto || tool_toggle[tool_toggle_i] == "eraser_tool" || move_module.opid == history_keeper.opid)return;
	solidifySpree();
}

function toggleColorPickerAutoApply(active){
	color_picker.auto_apply = active;
	if(active){
		applyColorPickerColor();
	}
	//
	uc_keeper.notifyGenUpdateNeeded("generalConfig", "misc_0");
}



//generic function that unifies values for input fields like number and slider
function parseSlider(callerInput,targetInput){
	UI[targetInput].value = callerInput.value;
}

function setBayOpacity(value){
	current_bay.setOpacity(value/100);
	
	//
	uc_keeper.notifyGenUpdateNeeded("generalConfig","bay_"+bay_keeper.selected_bay_i+"_basic");
}

function setBayFlow(value){
	current_bay.setFlow(value/100);
	
	//
	uc_keeper.notifyGenUpdateNeeded("generalConfig","bay_"+bay_keeper.selected_bay_i+"_basic");
}

function setBayHardness(value){
	current_bay.setHardness(value/100);
	
	//
	uc_keeper.notifyGenUpdateNeeded("generalConfig","bay_"+bay_keeper.selected_bay_i+"_basic");
}

function setBaySize(value){
	current_bay.setSize(value);
	//update cursor
	canvas_view.makeCursor(current_tool,current_bay.size);
	
	//
	//delaying notifying db updater in case of rapid firing
	clearTimeout(bay_keeper.bay_size_delay_db_action);
	bay_keeper.bay_size_delay_db_action = setTimeout(function(){
		uc_keeper.notifyGenUpdateNeeded("generalConfig","bay_"+bay_keeper.selected_bay_i+"_basic");
		if(current_bay.size_bay_link_active){
			uc_keeper.notifyGenUpdateNeeded("generalConfig","bay_"+current_bay.size_bay_link_ref+"_basic");
		}
	}, 200);
}


function setLayerOpacity(value){
	//history
	history_keeper.store("layerOpacity",current_tool,toolset_mode,selected_layer_i);
	
	selected_layer.setOpacity(value);
	stackLiveView();
}

function setLayerBlending(value){
	//history
	history_keeper.store("layerBlending",current_tool,toolset_mode,selected_layer_i);
	
	selected_layer.blending = value;
	stackLiveView();
	//console.log(value);
}

function timedQuickBrushSize(val){

	if(bay_keeper.quick_brush_size_active == false){
		setBaySize(current_bay.raw_size);
		
		var b_size = current_bay.getSize();
		UI.bay_size_value.value = b_size;
		UI.bay_size_slider.value = baySizeUIVtoS(b_size);
		canvas_view.makeCursor(current_tool,b_size);
		canvas_view.drawCursor();
		
		//brush icon
		brushTipSampleImgMaker.updateBayIcon(UI["bay_"+bay_keeper.selected_bay_i+"_icon"],current_bay);
		return;
	}
	if(current_tool == "brush_tool" || current_tool == "eraser_tool"){
		var b_size;
		current_bay.raw_size = Math.max(1,current_bay.raw_size*val);
		b_size = Math.max(1,Math.round(( parseInt(current_bay.raw_size) )));
		UI.bay_size_value.value = b_size;
		UI.bay_size_slider.value = baySizeUIVtoS(b_size);
		
		if(!c_view.matches(':hover')){
		//make brush cursor appear in center if there is no hover over canvas view
			canvas_view.cursor_posX = Math.floor(c_view_rect_x + c_view.offsetWidth/2);
			canvas_view.cursor_posY = Math.floor(c_view_rect_y + c_view.offsetHeight/2);
		}
		
		canvas_view.makeCursor(current_tool,b_size);
		canvas_view.drawCursor();
	}
	setTimeout(function(){
		timedQuickBrushSize(val);
	},10);
	
}


function toggleZoomSize(active){
	current_bay.zoom_size = active;
	current_bay.zoom_size_value = current_bay.raw_size * canvas_view.current_zoom;
}

function updateUIBayValues(){
	
	UI.bay_zoom_size_active.checked = current_bay.zoom_size;

	UI.bay_size_slider.value = baySizeUIVtoS(current_bay.getSize());
	UI.bay_size_value.value = current_bay.getSize();
	
	UI.bay_opacity_slider.value = Math.round(current_bay.getOpacity()*10*10);
	UI.bay_opacity_value.value = Math.round(current_bay.getOpacity()*10*10);
	
	UI.bay_flow_slider.value = Math.round(current_bay.getFlow()*10*10);
	UI.bay_flow_value.value = Math.round(current_bay.getFlow()*10*10);
	
	UI.bay_hardness_slider.value = Math.round(current_bay.getHardness()*10*10);
	UI.bay_hardness_value.value = Math.round(current_bay.getHardness()*10*10);
	
	UI.bay_link_active.checked = current_bay.getSizeBayLinkStatus();
	UI.bay_link_ref.value = current_bay.getSizeBayLinkRef();
	UI.bay_link_value.value = current_bay.getSizeBayLinkValue();
	
	UI.bay_keep_color_active.checked = current_bay.getKeepColor();
	
	UI.bay_clone_mode_active.checked = current_bay.getCloneMode();
	
	UI.color_id.style.background = current_bay.color;
}

//bay size UI slider to value convert
function baySizeUIStoV(val){
	//steps are 0-200 x1, 200-300 x3, 300-350 x30
	//note: steps comment may be outdated
	var result = 0;
	if(val > 300){
		//200 + 100*3 + remainder*30
		result = 500 + (val-300)*30;
	}else if(val > 200){
		//200 + remainder*3
		result = 200 + (val-200)*3;
	}else{
		result = val;
	}
	//console.log(val,result);
	return result;
}
//bay size UI value to slider convert
function baySizeUIVtoS(val){
	//steps are 0-100 x1, 100-180 x5, 180-200 x50
	//note: steps comment may be outdated
	var result = 0;
	if(val > 1500){
		result = 350;
	}else if(val > 500){
		result = 300 + (val-500)/30;
	}else if(val > 200){
		result = 200 + (val-200)/3;
	}else{
		result = val;
	}
	return Math.round(result);
}

function selectBay(index){
	bay_keeper.selectBay(index);
	updateUIBayValues();
	
	//update cursor
	canvas_view.makeCursor(current_tool,current_bay.size);
	
	//
	uc_keeper.notifyGenUpdateNeeded("generalConfig","bay_selection");
}

function setBaySizeLinkRef(ref_bay_index){
	current_bay.setSizeBayLinkRef(ref_bay_index);
	
	canvas_view.makeCursor(current_tool,current_bay.size);
	
	//
	uc_keeper.notifyGenUpdateNeeded("generalConfig","bay_"+bay_keeper.selected_bay_i+"_config");
}

function toggleBaySizeLink(active){
	current_bay.toggleSizeBayLink(active);
	
	canvas_view.makeCursor(current_tool,current_bay.size);
	
	//
	uc_keeper.notifyGenUpdateNeeded("generalConfig","bay_"+bay_keeper.selected_bay_i+"_config");
}

function setSizeBayLinkValue(value){
	current_bay.setSizeBayLinkValue(value);
	
	canvas_view.makeCursor(current_tool,current_bay.size);
		
	//
	uc_keeper.notifyGenUpdateNeeded("generalConfig","bay_"+bay_keeper.selected_bay_i+"_config");
}

function toggleBayKeepColor(active){
	current_bay.toggleKeepColor(active);
}

function toggleBayCloneMode(active){
	current_bay.setCloneMode(active);
}

function toggleSpreeAuto(active){
	spree_auto = active;
	uc_keeper.notifyGenUpdateNeeded("generalConfig","misc_0");
}



var general_menu_map = {
	"file" : {
		//
		"new" : function(){
			doc_config_keeper.openMenu();
		},
		//
		"open" : function(){
			UI.ts_open_document.click();
		},
		//
		"save" : function(){
			UI.saf_menu_doc_name.value = gf.proj_meta.name;
			showUIElement(UI.save_as_file_menu);
		},
		//
		"import image" : function(){
			UI.ts_import_image.click();
		},
		//
		"export selected" : function(){
			var filename = selected_layer.name;
			if(selected_layer.target == "layer"){
				solidifySpree();//because content is of layer, not layer view
				filename = "layer_"+selected_layer_i+"_"+filename;
			}else if(selected_layer.target == "mask"){
				filename = "mask_"+selected_layer_i+"_"+filename;
			}
			generateDownload(filename, move_module.exportSelectedContent());
		},
		//
		"exit" : async function(){
		
			try{
				if(gf.getOPIDStamp() != history_keeper.getOPID()){
				//saving project changes
				//using custom dialog box
					switch(await dialog_box.confirm('Save changes to the project "'+gf.proj_meta.name+'" ?',
						[["Yes","yes"],["No","no"],["Cancel","cancel"]])){
						
							case "yes":
								saveAsFile("project");
								return;
							break;
							//
							case "no":
							
							break;
							//
							case "cancel":
							
								return;
							break;
							//
							default:
								return;
							break;
						}
				}
				
			
				clearTimeout(uc_keeper.genUpdateTimer);
				await db_keeper.updateDBGen_async();
				await db_keeper.updateDBLib_async();
				
				if(isChromium){
				//special chromium case, 
				//because chromium seems to delay the actual write to db
				//workaround by sending a count request for each table
					await db_keeper.chromium_readBackDB_count();
				}
				MANUAL_USER_EXIT = true;
				setTimeout(window.close, 50);//just some buffer time
			}catch(err){
				console.log(err);
				if(confirm("Error occured: \n" + err + "\n Do you still want to exit?")){
					window.close();
				}
			}
		}
		
	},
	//
	"edit" : {
		//
		"undo" : function(){
			history_keeper.undo();
		},
		//
		"redo" : function(){
			history_keeper.redo();
		},
		//
		/* paste does not trigger programmatically 
		by permissions cannot read clipboard without user event*/
		"cut" : function(){
			//document.execCommand("cut");
			move_module.cutImage();
		},
		//
		"copy" : function(){
			//document.execCommand("copy");
			move_module.copyImage();
		},
		//
		"paste" : function(){
			//document.execCommand("paste");
			if(current_tool != "move_tool"){
				changeTool("move_tool");
			}
			checkToolsetMode();
			move_module.pasteImage();
		},
		
		//
		"fsc horizontal" : function(){
		//flip selected content horizontal
			if(current_tool != "move_tool"){
				solidifySpree();
			}
			move_module.flipSelectedContent(-1,1);
		},
		
		"fsc vertical" : function(){
		//flip selected content vertical
			if(current_tool != "move_tool"){
				solidifySpree();
			}
			move_module.flipSelectedContent(1,-1);
		},
		
		"bpfl" : function(){
		//brush preset from layer
			UI.brush_preset_lib.style.display = "block";
			bp_keeper.captureLayer();
			bp_keeper.setPresetPreviewImg(bp_keeper.selected_preset_i);
			bp_keeper.stackBrushPresetsUI();
			bp_keeper.updateUIPresetConfigValues();
		},
		
		//
		"bpfb" : function(){
		//brush preset from bay
			UI.brush_preset_lib.style.display = "block";
			bp_keeper.captureBay();
			bp_keeper.setPresetPreviewImg(bp_keeper.selected_preset_i);
			bp_keeper.stackBrushPresetsUI();
			bp_keeper.updateUIPresetConfigValues();
		},
		//
		"transform" : function(){
			if(current_tool != "move_tool"){
				changeTool("move_tool");
			}
		}
		//
	},
	//
	"image" : {
		//
		"adjustments" : function(){
			performColorFilterOptions("open");
		},
		//
		"image size" : function(){
			UI.doc_imgs_width.value = drawingAreaWidth;
			UI.doc_imgs_height.value = drawingAreaHeight;
			showUIElement(UI.doc_image_size);
			hideUIElement(UI.doc_canvas_size);
		},
		//
		"canvas size" : function(){
			UI.doc_cs_width.value = drawingAreaWidth;
			UI.doc_cs_height.value = drawingAreaHeight;
			showUIElement(UI.doc_canvas_size);
			hideUIElement(UI.doc_image_size);
		},
		//
		"crop" : function(){
			solidifySpree();

			history_keeper.store("snapshot",current_tool,toolset_mode,selected_layer_i);
			//x,y,w,h
			var crop_args = selection_module.getBoundingBox();
			cropCanvas(crop_args[0],crop_args[1],crop_args[2],crop_args[3]);
			
			canvas_view.zoomFit();
			canvas_view.makeCursor(current_tool,current_bay.size);
			
			stackLiveView();
			stackLayersUI();
			selection_module.makeSelectionOutline();
		},
		//
		"rc cw" : function(){
			history_keeper.store("rotateCanvas90",current_tool,toolset_mode,selected_layer_i,[1]);
			
			rotateCanvas90(1);
			
			canvas_view.zoomFit();
			canvas_view.makeCursor(current_tool,current_bay.size);
			
			stackLiveView();
			stackLayersUI();
		},
		//
		"rc ccw" : function(){
			history_keeper.store("rotateCanvas90",current_tool,toolset_mode,selected_layer_i,[-1]);
			
			rotateCanvas90(-1);
			
			canvas_view.zoomFit();
			canvas_view.makeCursor(current_tool,current_bay.size);
			
			stackLiveView();
			stackLayersUI();
		},
		//
		"fc horizontal" : function(){
			history_keeper.store("flipCanvas",current_tool,toolset_mode,selected_layer_i,[-1,1]);
			flipCanvas(-1,1);
			stackLiveView();
			
			//
			if(current_tool == "move_tool"){
				move_module.updateUIConfigMenu();
				move_module.updateUITransformControls();
			}
		},
		//
		"fc vertical" : function(){
			history_keeper.store("flipCanvas",current_tool,toolset_mode,selected_layer_i,[1,-1]);
			flipCanvas(1,-1);
			stackLiveView();
			
			//
			if(current_tool == "move_tool"){
				move_module.updateUIConfigMenu();
				move_module.updateUITransformControls();
			}
		}
	},
	//
	"filter" : {
		//
		"invert colors" : function(){
			if(selected_layer.target == "layer"){
				solidifySpree();
				history_keeper.store("layer",current_tool,toolset_mode,selected_layer_i);
				invertColors(selected_layer.c, selected_layer.ctx);
			}else if(selected_layer.target == "mask"){
				history_keeper.store("mask",current_tool,toolset_mode,selected_layer_i);
				invertMask(selected_layer.mask, selected_layer.mask_ctx);
			}
			selected_layer.updateView();
			stackLiveView();
		},
		//
		"bnw" : function(){
			solidifySpree();
			history_keeper.store("layer",current_tool,toolset_mode,selected_layer_i);
			BnWColors(selected_layer.c, selected_layer.ctx);
			selected_layer.updateView();
			stackLiveView();
		},
		//
		"desaturate avg" : function(){
			solidifySpree();
			history_keeper.store("layer",current_tool,toolset_mode,selected_layer_i);
			desaturateAvgColors(selected_layer.c, selected_layer.ctx);
			selected_layer.updateView();
			stackLiveView();
		},
		//
		"bnwalpha" : function(){
			solidifySpree();
			history_keeper.store("layer",current_tool,toolset_mode,selected_layer_i);
			BnWAlpha(selected_layer.c,selected_layer.ctx);
			selected_layer.updateView();
			stackLiveView();
		}
	
	},
	//
	"select" : {
		//
		"deselect" : function(){
			history_keeper.store("selection",current_tool,toolset_mode,selected_layer_i);
			selection_module.deselectAll();
			
			//
			if(current_tool == "move_tool"){
				move_module.updateUIConfigMenu();
				move_module.updateUITransformControls();
			}
		},
		//
		"select content" : function(){
			history_keeper.store("selection",current_tool,toolset_mode,selected_layer_i);
			selection_module.selectContent();
			
			//
			if(current_tool == "move_tool"){
				move_module.updateUIConfigMenu();
				move_module.updateUITransformControls();
			}
		},
		//
		"select all" : function(){
			history_keeper.store("selection",current_tool,toolset_mode,selected_layer_i);
			selection_module.selectAll();
			
			//
			if(current_tool == "move_tool"){
				move_module.updateUIConfigMenu();
				move_module.updateUITransformControls();
			}
		},
		//
		"toggle selection" : function(){
			history_keeper.store("selection",current_tool,toolset_mode,selected_layer_i);
			selection_module.toggleSelection();
			
			if(current_tool == "move_tool"){
				//move_module.defineBoundingBox();
				move_module.updateUIConfigMenu();
				move_module.updateUITransformControls();
			}
		},
		//
		"inverse" : function(){
			history_keeper.store("selection",current_tool,toolset_mode,selected_layer_i);
			selection_module.invertSelection();
			
			//
			if(current_tool == "move_tool"){
				move_module.updateUIConfigMenu();
				move_module.updateUITransformControls();
			}
		},
		//
		"from layer add" : function(){
			history_keeper.store("selection",current_tool,toolset_mode,selected_layer_i);
			selection_module.selectionFromLayerAdd(selected_layer_i);
			
			//
			if(current_tool == "move_tool"){
				move_module.updateUIConfigMenu();
				move_module.updateUITransformControls();
			}
		},
		//
		"from layer subtract" : function(){
			history_keeper.store("selection",current_tool,toolset_mode,selected_layer_i);
			selection_module.selectionFromLayerSubtract(selected_layer_i);
			
			//
			if(current_tool == "move_tool"){
				move_module.updateUIConfigMenu();
				move_module.updateUITransformControls();
			}
		},
		//
		"make opaque" : function(){
			history_keeper.store("selection",current_tool,toolset_mode,selected_layer_i);
			selection_module.makeSelectionOpaque();
		},
		//
		"from spree" : function(){
			//selection from spree
			history_keeper.store("custom",current_tool,toolset_mode,selected_layer_i,["selection","spree"]);
			selection_module.deselectAll();
			selection_module.selectionFromSpree();
			spree.clear();
			//
			selected_layer.updateView();
			stackLiveView();
			
			
			//
			if(current_tool == "move_tool"){
				move_module.updateUIConfigMenu();
				move_module.updateUITransformControls();
			}
		},
		//
		"wrap" : function(){
			history_keeper.store("selection",current_tool,toolset_mode,selected_layer_i);
			selection_module.selectWrap();
			
			//
			if(current_tool == "move_tool"){
				move_module.updateUIConfigMenu();
				move_module.updateUITransformControls();
			}
		},
	},
	//
	"other" : {
		//
		"bpl" : function(){
			UI.brush_preset_lib.style.display = "block";
		},
		//
		"rll" : function(){
			showUIElement(UI.ref_layer_lib);
			rlp_keeper.updateUIPresetConfigValues();
		}
	},
	//
	"help" : {
		//
		"import settings" : function(){
			
			if(UI.ts_import_settings == null){
				UI.ts_import_settings = document.createElement('input');
				UI.ts_import_settings.setAttribute('type','file');
				UI.ts_import_settings.setAttribute('autocomplete','off');
				UI.ts_import_settings.setAttribute('accept', '.dat');
				
				//
				UI.ts_import_settings.addEventListener("change", function(e){
					
					var f = UI.ts_import_settings.files[0];
					if(!f)return;
					var reader = new FileReader()
					reader.onload = async function(e){
						try{
							//
							var dbconfig = JSON.parse(e.target.result);
							//need to listen for transaction complete before reloading
							var tx = await uc_keeper.importDBConfig(dbconfig);
							tx.addEventListener('complete', event => {
								MANUAL_USER_EXIT = true;
								setTimeout(async function(){window.location.reload();return false;}, 50);
							});
							
							//
						}catch(err){
							console("Error: "+err);
							alert("Error importing settings \n"+err);
						}
					}
					reader.readAsText(f);
					
				});
				//
			}
			
			//
			UI.ts_import_settings.click();
			
		},
		//
		"export settings" : async function(){
			clearTimeout(uc_keeper.genUpdateTimer);
			await db_keeper.updateDBGen_async();
			await db_keeper.updateDBLib_async();
			var db_mirror = {};
			await db_keeper.getAll(db_mirror);
			
			var currentDate = new Date();
			var day = currentDate.getDate();
			var month = currentDate.getMonth() + 1;
			var year = currentDate.getFullYear();
			
			generateDownload(db_name+"-"+year+"-"+month+"-"+day+".dat","data:text/plain;charset=UTF-8,"+JSON.stringify(db_mirror));
		},
		//
		"reset settings" : async function(){
			if(confirm("Resetting all settings will also clear all presets (e.g. brush and palette presets).\n"+
						"It is recommended that you backup any valuable data by exporting first.\n\n"+
						"Do you wish to reset now?")){
				//console.log("resetAll");
				MANUAL_USER_EXIT = true;
				uc_keeper.resetAll();
			}
			
		},
		//
		"tool options" : function(){
			manual_keeper.demoToolOptions(1);
		},
		//
		"hotkeys" : function(){
			showUIElement(UI.hk_list);
		},
		//
		"manual" : function(){
			showUIElement(UI.manual_menu);
		},
		//
		"about" : function(){
			showUIElement(UI.about);
		}
	}
	//
}

function processGeneralMenu(section,menu){
	var val = menu.value;
	//console.log(val);
	
	general_menu_map[section][val]();

	menu.value = section;
	document.activeElement.blur();
}

//general menu-related binds
UI.ts_import_image.addEventListener("change", function(e){
	var imgReader = encodeImageFileAsURL(this);
	
	imgReader.onload = function(){
		
		var img = new Image();

		img.onload = function(){
			if(current_tool != "move_tool"){
				changeTool("move_tool");
			}
			checkToolsetMode();
			move_module.importImage(img);
			
			UI.ts_import_image.value = "";
		};

		img.src = imgReader.result;
	}
});

UI.ts_open_document.addEventListener("change", async function(e){

	var f = UI.ts_open_document.files[0];
	if(!f)return;
	//
	if(gf.getOPIDStamp() != history_keeper.getOPID()){
	//saving project changes
	//using custom dialog box
		switch(await dialog_box.confirm('Save changes to the project "'+gf.proj_meta.name+'" ?', 
								[["Yes","yes"],["No","no"],["Cancel","cancel"]])){
			
			case "yes":
				//console.log("saving file");
				saveAsFile("project");
			break;
			//
			case "no":
			
			break;
			//
			case "cancel":
				UI.ts_open_document.value = "";
				return;
			break;
		}
	}
	//
	
	showUIElement(UI.file_loading_screen);//just a visual
	const project_extension = PROJECT_FORMAT;
	const img_extension = ["png", "jpg", "jpeg", "gif",	"bmp", "webp", "webm", "svg"];
	var file_name_proc = UI.ts_open_document.files[0].name.split('.');
	//process "file name" for the name and format
	//accounts for multiple '.' symbols in name
	var f_extension = file_name_proc.pop().toLowerCase();
	var f_name = file_name_proc.join('.');
	
	if(f_extension == project_extension){
	//project file
		var reader = new FileReader();
		reader.onload = async function(e){
			try{
				//
				const p_file = JSON.parse(e.target.result);
				await loadProjectFile(p_file, f_name);
				
				//history keeper
				history_keeper.init(51);
				history_keeper.store("snapshot",current_tool,toolset_mode,selected_layer_i);
				
				//
				canvas_view.zoomFit();
				canvas_view.makeCursor(current_tool,current_bay.size);
				//
				stackLayersUI();
				stackLiveView();
				
				move_module.updateUIConfigMenu();
				move_module.updateUITransformControls();
				selection_module.makeSelectionOutline();
				
				UI.ts_open_document.value = "";
				
				hideUIElement(UI.file_loading_screen);
				canvas_view.canvasFadeIn();
				//
				gf.stampOPID();
				//
			}catch(err){
				console.log(err);
				alert("Error opening project file");
				hideUIElement(UI.file_loading_screen);
			}
		}
		reader.readAsText(f);
	
	}else if(img_extension.includes(f_extension)){
	//image file
		var reader = new FileReader();
		reader.onload = async function(e){
			try{
				var img = new Image();
				img.src = e.target.result;
				await img.decode();
				await loadImageFile(img, f_name);
				
				//history keeper
				history_keeper.init(51);
				history_keeper.store("snapshot",current_tool,toolset_mode,selected_layer_i);
				
				//
				canvas_view.zoomFit();
				canvas_view.makeCursor(current_tool,current_bay.size);
				//
				stackLayersUI();
				stackLiveView();
				
				move_module.updateUIConfigMenu();
				move_module.updateUITransformControls();
				selection_module.makeSelectionOutline();
				
				UI.ts_open_document.value = "";
				
				hideUIElement(UI.file_loading_screen);
				canvas_view.canvasFadeIn();
				//
				gf.stampOPID();
				//
			}catch(err){
				console.log(err);
				alert("Error opening image");
				hideUIElement(UI.file_loading_screen);
			}
		
		}
		reader.readAsDataURL(f);
	}else{
		alert("File format is not supported, \n"+
			"Please choose a file of the following formats:\n"+
			PROGRAM_NAME+" project: "+project_extension+"\n"+
			"Image: "+img_extension);
		hideUIElement(UI.file_loading_screen);
	}
	
	
});










//note: maybe manually add event listener to each object with 
//a proper correspnding function
//instead of just generic processUIClick
//example: UI.move_tool.addEventListener....
//console.log(UI);


//left bar tools area
UI.move_tool.addEventListener("click", function(e){e.stopPropagation();changeTool("move_tool");});
UI.select_tool.addEventListener("click", function(e){e.stopPropagation();changeTool("select_tool");});
UI.lasso_tool.addEventListener("click", function(e){e.stopPropagation();changeTool("lasso_tool");});
UI.auto_select_tool.addEventListener("click", function(e){e.stopPropagation();changeTool("auto_select_tool");});
UI.bucket_tool.addEventListener("click", function(e){e.stopPropagation();changeTool("bucket_tool");});
UI.brush_tool.addEventListener("click", function(e){e.stopPropagation();changeTool("brush_tool");});
UI.eraser_tool.addEventListener("click", function(e){e.stopPropagation();changeTool("eraser_tool");});

UI.color_id.addEventListener("pointerdown", function(e){e.stopPropagation();toggleColorPicker();});

UI.spree_indicator.addEventListener("pointerdown", function(e){e.stopPropagation();spreeIndicatorSwitch();});

UI.zoom_fit.addEventListener("click", function(e){
	e.stopPropagation();
	canvas_view.zoomFit();
	canvas_view.makeCursor(current_tool,current_bay.size);
});
UI.zoom_scale_one.addEventListener("click", function(e){
	e.stopPropagation();
	canvas_view.zoomScaleOne();
	canvas_view.makeCursor(current_tool,current_bay.size);
});
UI.zoom_toggle.addEventListener("click", function(e){
	e.stopPropagation();
	canvas_view.zoomToggle();
	canvas_view.makeCursor(current_tool,current_bay.size);
});
UI.zoom_value.addEventListener("change", function(e){
	e.stopPropagation();
	canvas_view.setZoomDirect(parseInt(this.value)/100);
	canvas_view.makeCursor(current_tool,current_bay.size);
});

// touch keys tool btn
UI.cp_dropper_tool.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	
	if(touch_module.toggleTouchKeyUI("cp_dropper_tool")){
		color_picker.openToolDropperCanvas(true);
		
		//mutually exclusive dropper and palette
		if(touch_module.getTouchKeyToggleState("color_palette_tool") == 1){
			touch_module.toggleTouchKeyOffUI("color_palette_tool");
			color_picker.closeToolDropperRefLayer();
		}
	}else{
		color_picker.closeToolDropperCanvas();
	}
});
UI.color_palette_tool.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	
	if(touch_module.toggleTouchKeyUI("color_palette_tool")){
		color_picker.openToolDropperRefLayer(true);
		
		//mutually exclusive dropper and palette
		if(touch_module.getTouchKeyToggleState("cp_dropper_tool") == 1){
			touch_module.toggleTouchKeyOffUI("cp_dropper_tool");
			color_picker.closeToolDropperCanvas();
		}
	}else{
		color_picker.closeToolDropperRefLayer();
	}
});
UI.blend_assist_tool.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	//auto switch to brush and spree draw mode
	if(current_tool != "brush_tool"){
		changeTool("brush_tool");
	}else if(spree_mode == 1){
		setBrushSpreeMode(0);
	}
	
	//note: this works different from hotkey Z, as touch key also is an indicator
	//also: will not trigger on hotkey use
	if(touch_module.toggleTouchKeyUI("blend_assist_tool")){
		current_bay.setBlendAssist(true);
	}else{
		current_bay.setBlendAssist(false);
	}
});
UI.hand_tool.addEventListener("pointerdown", function(e){
	e.stopPropagation();
	
	if(touch_module.toggleTouchKeyUI("hand_tool")){
		canvas_view.openToolHand();
	}else{
		canvas_view.closeToolHand();
	}
});
UI.undo_btn_tool.addEventListener("click", function(e){
	e.stopPropagation();
	history_keeper.undo();
});
//

UI.spree_auto.addEventListener("change", function(e){e.stopPropagation();toggleSpreeAuto(UI.spree_auto.checked)});
UI.spree_solid_1.addEventListener("click", function(e){e.stopPropagation();solidifySpree()});
UI.spree_discard.addEventListener("click", function(e){e.stopPropagation();discardSpree();});

//nav tab
UI.tiny_preview_hide.addEventListener("change", function(e){
	e.stopPropagation();
	toggleUIMenu(UI.tiny_preview_hide_screen);
	
	//
	uc_keeper.notifyGenUpdateNeeded("generalConfig", "misc_0");
});
//
UI.tiny_preview_mirror.addEventListener("change", function(e){
	e.stopPropagation();
	if(UI.tiny_preview_mirror.checked){
		tiny_preview.classList.add("mirror-content");
	}else{
		tiny_preview.classList.remove("mirror-content");
	}
});
//
UI.tiny_preview_bnw.addEventListener("change", function(e){
	e.stopPropagation();
	if(UI.tiny_preview_bnw.checked){
		tiny_preview.classList.add("filter-grayscale-100");
	}else{
		tiny_preview.classList.remove("filter-grayscale-100");
	}
});


//right bar layers area
UI.add_layers_item_mask.addEventListener("click", function(e){e.stopPropagation();performLayersOptions("mask")});
UI.add_layer.addEventListener("click", function(e){e.stopPropagation();performLayersOptions("layer")});
UI.delete_layers_item.addEventListener("click", function(e){e.stopPropagation();performLayersOptions("delete")});

UI.layer_opacity_value.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"layer_opacity_slider");setLayerOpacity(UI.layer_opacity_value.value)});
UI.layer_opacity_slider.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"layer_opacity_value");setLayerOpacity(UI.layer_opacity_slider.value);document.activeElement.blur();});
UI.layer_opacity_slider.addEventListener("input", function(e){e.stopPropagation();parseSlider(this,"layer_opacity_value");});
UI.layer_blending.addEventListener("change", function(e){e.stopPropagation();setLayerBlending(UI.layer_blending.value);document.activeElement.blur();});

UI.layer_options.addEventListener("change", function(e){
	e.stopPropagation();
	performLayersOptionsMenu(this.value);
	this.value="options";
	document.activeElement.blur();
});
UI.layer_options_cl_btn.addEventListener("click", function(e){e.stopPropagation();performLayersOptions("cl");});
UI.layer_options_visibility_btn.addEventListener("click", function(e){e.stopPropagation();performLayersOptions("vis");});

//top bar general options area


//Bay area
//note:visibly bays will appear reversed from right to left 
//because of css float:right in .bay-shell class
//has a check for current tool to be brush or eraser, for direct switch to brush through bay click
UI.bay_0.addEventListener("click", function(e){e.stopPropagation();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(0);selectBay(0)});
UI.bay_1.addEventListener("click", function(e){e.stopPropagation();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(0);selectBay(1)});
UI.bay_2.addEventListener("click", function(e){e.stopPropagation();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(0);selectBay(2)});
UI.bay_3.addEventListener("click", function(e){e.stopPropagation();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(0);selectBay(3)});
UI.bay_4.addEventListener("click", function(e){e.stopPropagation();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(0);selectBay(4)});
UI.bay_5.addEventListener("click", function(e){e.stopPropagation();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(0);selectBay(5)});
UI.bay_6.addEventListener("click", function(e){e.stopPropagation();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(0);selectBay(6)});
UI.bay_7.addEventListener("click", function(e){e.stopPropagation();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(0);selectBay(7)});

UI.bay_0_erase.addEventListener("click", function(e){e.stopPropagation();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(1);selectBay(0)});
UI.bay_1_erase.addEventListener("click", function(e){e.stopPropagation();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(1);selectBay(1)});
UI.bay_2_erase.addEventListener("click", function(e){e.stopPropagation();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(1);selectBay(2)});
UI.bay_3_erase.addEventListener("click", function(e){e.stopPropagation();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(1);selectBay(3)});
UI.bay_4_erase.addEventListener("click", function(e){e.stopPropagation();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(1);selectBay(4)});
UI.bay_5_erase.addEventListener("click", function(e){e.stopPropagation();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(1);selectBay(5)});
UI.bay_6_erase.addEventListener("click", function(e){e.stopPropagation();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(1);selectBay(6)});
UI.bay_7_erase.addEventListener("click", function(e){e.stopPropagation();if(current_tool != "brush_tool" && current_tool != "eraser_tool"){changeTool("brush_tool");}setBrushSpreeMode(1);selectBay(7)});

UI.bay_zoom_size_active.addEventListener("change", function(e){e.stopPropagation();toggleZoomSize(UI.bay_zoom_size_active.checked)});

UI.bay_size_value.addEventListener("change", function(e){
	e.stopPropagation();
	UI.bay_size_slider.value = baySizeUIVtoS(parseInt(this.value));
	setBaySize(UI.bay_size_value.value);
	
	//brush icon
	brushTipSampleImgMaker.updateBayIcon(UI["bay_"+bay_keeper.selected_bay_i+"_icon"],current_bay);
	
	//make brush cursor appear in center and preview size
	if(current_tool == "brush_tool" || current_tool == "eraser_tool"){
		canvas_view.cursor_posX = Math.floor(dynamic_ui_rect_x + dynamic_ui.offsetWidth/2);
		canvas_view.cursor_posY = Math.floor(dynamic_ui_rect_y + dynamic_ui.offsetHeight/2);
		canvas_view.makeCursor(current_tool,parseInt(this.value));
		canvas_view.drawCursor();
	}
});

UI.bay_size_slider.addEventListener("change", function(e){
	e.stopPropagation();
	UI.bay_size_value.value = baySizeUIStoV(parseInt(this.value));
	setBaySize(UI.bay_size_value.value);
	
	//brush icon
	brushTipSampleImgMaker.updateBayIcon(UI["bay_"+bay_keeper.selected_bay_i+"_icon"],current_bay);
});
UI.bay_size_slider.addEventListener("input", function(e){
	e.stopPropagation();
	let bay_size_val = baySizeUIStoV(parseInt(this.value));
	UI.bay_size_value.value = bay_size_val;
	
	//make brush cursor appear in center and preview size
	if(current_tool == "brush_tool" || current_tool == "eraser_tool"){
		canvas_view.cursor_posX = Math.floor(dynamic_ui_rect_x + dynamic_ui.offsetWidth/2);
		canvas_view.cursor_posY = Math.floor(dynamic_ui_rect_y + dynamic_ui.offsetHeight/2);
		canvas_view.makeCursor(current_tool,bay_size_val);
		canvas_view.drawCursor();
	}
});
UI.bay_opacity_value.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"bay_opacity_slider");setBayOpacity(UI.bay_opacity_value.value)});
UI.bay_opacity_slider.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"bay_opacity_value");setBayOpacity(UI.bay_opacity_value.value)});
UI.bay_opacity_slider.addEventListener("input", function(e){e.stopPropagation();parseSlider(this,"bay_opacity_value");});
UI.bay_flow_value.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"bay_flow_slider");setBayFlow(UI.bay_flow_value.value)});
UI.bay_flow_slider.addEventListener("change", function(e){e.stopPropagation();parseSlider(this,"bay_flow_value");setBayFlow(UI.bay_flow_value.value)});
UI.bay_flow_slider.addEventListener("input", function(e){e.stopPropagation();parseSlider(this,"bay_flow_value");});
UI.bay_hardness_value.addEventListener("change", function(e){
	e.stopPropagation();
	parseSlider(this,"bay_hardness_slider");
	setBayHardness(UI.bay_hardness_value.value);
	//brush icon
	brushTipSampleImgMaker.updateBayIcon(UI["bay_"+bay_keeper.selected_bay_i+"_icon"],current_bay);
});
UI.bay_hardness_slider.addEventListener("change", function(e){
	e.stopPropagation();
	parseSlider(this,"bay_hardness_value");
	setBayHardness(UI.bay_hardness_value.value);
	//brush icon
	brushTipSampleImgMaker.updateBayIcon(UI["bay_"+bay_keeper.selected_bay_i+"_icon"]);
});
UI.bay_hardness_slider.addEventListener("input", function(e){parseSlider(this,"bay_hardness_value");});

UI.bay_link_ref.addEventListener("change", function(e){e.stopPropagation();setBaySizeLinkRef(UI.bay_link_ref.value);updateUIBayValues();});
UI.bay_link_active.addEventListener("change", function(e){e.stopPropagation();toggleBaySizeLink(UI.bay_link_active.checked);updateUIBayValues();});
UI.bay_link_value.addEventListener("change", function(e){e.stopPropagation();setSizeBayLinkValue(parseInt(UI.bay_link_value.value));updateUIBayValues();});

UI.bay_keep_color_active.addEventListener("change", function(e){e.stopPropagation();toggleBayKeepColor(UI.bay_keep_color_active.checked)});
//
UI.bay_clone_mode_active.addEventListener("change", function(e){
	e.stopPropagation();
	document.activeElement.blur();
	let val = UI.bay_clone_mode_active.checked;
	if(val == false){
		toggleBayCloneMode(val);
		UI.stamp_sample_screen.style.display = "";
	}else if(val == true){
		UI.stamp_sample_screen.style.display = "block";
	}
});
UI.stamp_sample_screen.addEventListener("pointerdown", function(e){
	canvas_view.cursor_posX = e.x;
	canvas_view.cursor_posY = e.y;
	canvas_view.drawCursor();
	if(e.pointerType == "touch")return;
	makeBrushCloneSample(canvas_view.cursor_posX, canvas_view.cursor_posY);
	toggleBayCloneMode(true);
});
UI.stamp_sample_screen.addEventListener("touchend", function(e){
	makeBrushCloneSample(canvas_view.cursor_posX, canvas_view.cursor_posY);
	toggleBayCloneMode(true);
});
UI.stamp_sample_screen.addEventListener("pointermove", function(e){
	canvas_view.cursor_posX = e.x;
	canvas_view.cursor_posY = e.y;
	canvas_view.drawCursor();
});
UI.stamp_sample_screen.addEventListener("pointerup", function(){UI.stamp_sample_screen.style.display = "";});
//

UI.bay_single_brush_lock.addEventListener("change", function(e){e.stopPropagation();bay_keeper.setSingleBrushLock(this.checked)});

UI.undo_btn.addEventListener("click", function(e){
	e.stopPropagation();
	history_keeper.undo();
});
UI.redo_btn.addEventListener("click", function(e){
	e.stopPropagation();
	history_keeper.redo();
});

//Tool options
//UI.tool_config_menu_btn.addEventListener("click", function(e){e.stopPropagation();toggleUIMenu(UI.tool_config_menu);UI.tool_config_menu_toggler.checked = !UI.tool_config_menu_toggler.checked;});
//Fill options
UI.fill_config_menu.addEventListener("click", function(e){e.stopPropagation()});
UI.fc_basic_fill.addEventListener("change", function(e){e.stopPropagation();fill_module.setConfigBucketTool("basic_fill",this.checked)});
UI.fc_direct.addEventListener("change", function(e){e.stopPropagation();fill_module.setConfigBucketTool("direct",this.checked)});
UI.fc_lasso_fill.addEventListener("change", function(e){e.stopPropagation();fill_module.setConfig("lasso_fill",this.checked)});
UI.fc_all_layers.addEventListener("change", function(e){
	e.stopPropagation();
	//exclusive
	fill_module.setConfig("top_visible", false);
	
	fill_module.setConfigBucketTool("all_layers",this.checked);
	UI.fc_top_visible.checked = false;
});
UI.fc_top_visible.addEventListener("change", function(e){
	e.stopPropagation();
	//exclusive
	fill_module.setConfig("all_layers", false);
	
	fill_module.setConfigBucketTool("top_visible",this.checked);
	UI.fc_all_layers.checked = false;
});
UI.fc_rgb_margin.addEventListener("change", function(e){e.stopPropagation();fill_module.setConfigBucketTool("rgb_margin",parseInt(this.value))});
UI.fc_opacity_barrier.addEventListener("change", function(e){e.stopPropagation();fill_module.setOpacityBarrier(parseInt(this.value))});


//Selection Auto options
UI.selection_config_menu.addEventListener("click", function(e){e.stopPropagation()});
UI.sm_all_layers.addEventListener("change", function(e){e.stopPropagation();selection_module.setConfigAutoSelect("all_layers",this.checked)});
UI.sm_contiguous.addEventListener("change", function(e){e.stopPropagation();selection_module.setConfigAutoSelect("contiguous",this.checked)});
UI.sm_rgb_margin.addEventListener("change", function(e){e.stopPropagation();selection_module.setConfigAutoSelect("rgb_margin",parseInt(this.value))});
UI.sm_tone_margin.addEventListener("change", function(e){e.stopPropagation();selection_module.setConfigAutoSelect("tone_margin",parseInt(this.value))});


//Move options
UI.mt_area_pos_x.addEventListener("change", function(e){
	e.stopPropagation();
	move_module.setTranslate(parseInt(UI.mt_area_pos_x.value),parseInt(UI.mt_area_pos_y.value));
	move_module.updateUITransformControls();
});
UI.mt_area_pos_y.addEventListener("change", function(e){
	e.stopPropagation();
	move_module.setTranslate(parseInt(UI.mt_area_pos_x.value),parseInt(UI.mt_area_pos_y.value));
	move_module.updateUITransformControls();
});
UI.mt_area_angle.addEventListener("change", function(e){
	e.stopPropagation();
	move_module.setTransformRotate(parseFloat(UI.mt_area_angle.value)/180*Math.PI);
	move_module.updateUITransformControls();
});
UI.mt_area_reset_angle.addEventListener("click", function(e){
	e.stopPropagation();
	move_module.setTransformRotate(0);
	move_module.updateUITransformControls();
});
UI.mt_area_w.addEventListener("change", function(e){
	e.stopPropagation();
	move_module.setTransformSize(parseInt(UI.mt_area_w.value), parseInt(UI.mt_area_h.value));
	move_module.updateUITransformControls();
});
UI.mt_area_h.addEventListener("change", function(e){
	e.stopPropagation();
	move_module.setTransformSize(parseInt(UI.mt_area_w.value), parseInt(UI.mt_area_h.value));
	move_module.updateUITransformControls();
});
UI.mt_area_fit_dimensions.addEventListener("click", function(e){
	e.stopPropagation();
	move_module.fitTransformDimensions();
	move_module.updateUITransformControls();
});
UI.mt_area_pos_center_x.addEventListener("click", function(e){
	e.stopPropagation();
	move_module.centerContentHV(0.5, false);
	move_module.updateUITransformControls();
});
UI.mt_area_pos_center_y.addEventListener("click", function(e){
	e.stopPropagation();
	move_module.centerContentHV(false, 0.5);
	move_module.updateUITransformControls();
});
UI.mt_area_reset_dimensions.addEventListener("click", function(e){
	e.stopPropagation();
	move_module.resetTransformDimensions();
	move_module.updateUITransformControls();
});


//Selection Area options
//make area
UI.sm_make_selection_area_btn.addEventListener("click", function(e){
	e.stopPropagation();
	history_keeper.store("selection",current_tool,toolset_mode,selected_layer_i);
	selection_module.makeSelectionArea(parseInt(UI.sm_make_selection_area_w.value),parseInt(UI.sm_make_selection_area_h.value))
});
//lock aspect
UI.sm_select_area_aspect_w.addEventListener("change", function(e){selection_module.setConfig("selectArea_aspect_ratio",parseInt(UI.sm_select_area_aspect_w.value) / parseInt(UI.sm_select_area_aspect_h.value))});
UI.sm_select_area_aspect_h.addEventListener("change", function(e){selection_module.setConfig("selectArea_aspect_ratio",parseInt(UI.sm_select_area_aspect_w.value) / parseInt(UI.sm_select_area_aspect_h.value))});
UI.sm_select_area_aspect_lock.addEventListener("change", function(e){e.stopPropagation();selection_module.setConfig("selectArea_aspect_lock",this.checked)});


//Brush config menu
UI.brush_smoothing_value.addEventListener("change", function(e){brushSpacing_tracker.setSmoothing(parseInt(this.value));});

//Eraser config menu
UI.eraser_smoothing_value.addEventListener("change", function(e){brushSpacing_tracker.setSmoothing(parseInt(this.value));});

//General options menu area
UI.general_file_menu.addEventListener("change", function(e){e.stopPropagation();processGeneralMenu("file",this)});
UI.general_edit_menu.addEventListener("change", function(e){e.stopPropagation();processGeneralMenu("edit",this)});
UI.general_image_menu.addEventListener("change", function(e){e.stopPropagation();processGeneralMenu("image",this)});
UI.general_filter_menu.addEventListener("change", function(e){e.stopPropagation();processGeneralMenu("filter",this)});
UI.general_select_menu.addEventListener("change", function(e){e.stopPropagation();processGeneralMenu("select",this)});
UI.general_other_menu.addEventListener("change", function(e){e.stopPropagation();processGeneralMenu("other",this)});
UI.general_help_menu.addEventListener("change", function(e){e.stopPropagation();processGeneralMenu("help",this)});
UI.general_exit_btn.addEventListener("click", function(e){e.stopPropagation();general_menu_map["file"]["exit"]()});
UI.general_donate_btn.addEventListener("click", function(e){
	window.open("https://www.light-brush.art/donate/", "_blank");
});

//Color picker inputs and buttons
UI.cp_close.addEventListener("click", function(e){e.stopPropagation();hideColorPicker()});
UI.cp_auto_apply.addEventListener("change", function(e){e.stopPropagation();toggleColorPickerAutoApply(UI.cp_auto_apply.checked)});
UI.cp_apply.addEventListener("click", function(e){
	e.stopPropagation();
	applyColorPickerColor();
	if(color_picker.auto_apply == true){
		hideColorPicker();
	}
});

history_keeper.init(51);
//start with a snapshot
history_keeper.store("snapshot",current_tool,toolset_mode,selected_layer_i);
stackLayersUI();
changeTool("brush_tool");

//----------------------Technical Support 2
var windowResizeTimer;
var technicalCanvasBuffer = new canvasBuffer();
window.addEventListener("resize",function(){
	clearTimeout(windowResizeTimer);
	windowResizeTimer = setTimeout(function() {

		requestAnimationFrame( function(){ 
			sizeUICore();
			canvas_view.resizeWindowView();
			rlp_keeper.resizeWindowView();
		});
		//console.log("window resized");
	}, 200);
});



window.onbeforeunload = function(e){

	if(MANUAL_USER_EXIT == false){
		try{
			clearTimeout(uc_keeper.genUpdateTimer);
			db_keeper.updateDBGen();
			db_keeper.updateDBLib();
			//seem to work faster without async
			//await db_keeper.updateDBGen_async();
			//await db_keeper.updateDBLib_async();
		}catch(err){
			console.log("Unload error: "+err);
		}
		//confirm leave
		return "wait for config save";
	}
};


//disable "right click" menu
//note: this is not on capture mode, so can enable contextmenu locally
//by intercepting event and stopping propagation.
document.addEventListener('contextmenu', function(e){
	e.preventDefault();
	e.stopPropagation();
	return false;
});
//----------------------Init DB Module Data

async function prepareDB(){
//1-success,2-db unavailable,3-upgrade
	var indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB || window.shimIndexedDB;
	
	if(!indexedDB){
		return 2;
	}
	var req = indexedDB.open(db_name, dbVersion);
	return new Promise((resolve,reject) => {
		 
		 req.onupgradeneeded = async function(e){
		 
			//console.log("upgrading db");
			var db = {};
			db.result = req.result;
			
			var missing_table_name_list = uc_keeper.missing_table_name_list;
			//
			if (!db.result.objectStoreNames.contains("generalConfig")) {
				db.store = db.result.createObjectStore("generalConfig", {keyPath: "configName"});
				missing_table_name_list.push("generalConfig");
			}
			//
			for(var table_name in lib_update_que){
				if (!db.result.objectStoreNames.contains(table_name)) {
					db.store = db.result.createObjectStore(table_name, {keyPath: "id"});
					missing_table_name_list.push(table_name);
				}
				
			}
			//
			//console.log(missing_table_name_list);
			//async fill in missing tables with rows from default config
			//note: userConfigDefault structure:
			// { table_name : [ { column_name : "value", column_name : "value" }, ... ] , ... }
			
			
			resolve(3);
		 }
		 
		 req.onsuccess = e => resolve(1);
		 
		 req.onerror = e => reject(req.error);
	
	});
}

(async function(){

//loading time
var t1,t_elapsed;
t1 = performance.now();
var show_welcome_manual = false;

//1-success,2-db unavailable,3-upgrade
var db_status = await prepareDB();
if(db_status == 3){
//upgrade happened
	if(uc_keeper.missing_table_name_list.length > 0){
		await uc_keeper.populateMissingTable();
	}
	show_welcome_manual = true;
}

if(db_status == 2){
	uc_keeper.db_available = false;
	console.log("db unavailable, using default settings");
	await uc_keeper.getDBConfig(userConfigDefault);
}else{
//ok
	uc_keeper.db_available = true;
	//console.log("db open");
	await uc_keeper.getDBConfig();
}


//brush preset library
bp_keeper.load(uc_keeper.config["BrushPresets"],uc_keeper.config["BrushPresetOrder"]);
bp_keeper.stackBrushPresetsUI();
bp_keeper.updateUIPresetConfigValues();


//bay
bay_keeper.loadConfigBay(uc_keeper.config["BayConfig"]);
bay_keeper.loadConfigBaySelection(uc_keeper.config["BaySelection"]);
updateUIBayValues();
//init make cursor from selected bay
canvas_view.makeCursor("brush_tool",current_bay.size);


//ref preset library
rlp_keeper.load(uc_keeper.config["RefPresets"],uc_keeper.config["RefPresetOrder"]);
rlp_keeper.contents_preview_image[0].onload = function(){
	rlp_keeper.usePreset(0);
	ref_layer.style.display = "none";
};
rlp_keeper.stackRefLayerPresetsUI();
hideUIElement(UI.ref_layer_lib);

//tool options / config menu
selection_module.loadConfigAutoSelect(uc_keeper.config["ToolOptionsAutoSelect"]);
selection_module.updateUISelectionConfig();

brushSpacing_tracker.load(uc_keeper.config["ToolOptionsBrushSmoothing"]);
brushSpacing_tracker.updateUITrackerConfig();

fill_module.load(uc_keeper.config["ToolOptionsBucketTool"]);
fill_module.updateUIFillConfig();

doc_config_keeper.loadPrevPresets(uc_keeper.config["DocNewPrevPresets"]);

uc_keeper.loadConfigMisc();
//
doc_config_keeper.prepareConfigPresets();
doc_config_keeper.updateUIDocConfig();
//

//
uc_keeper.config = {};

//

gf.stampOPID();

//



//deal with splash screen
t_elapsed = performance.now() - t1;
//timed version
setTimeout(function(){
	hideUIElement(UI.splash_screen,640);
	hideUIElement(UI.canvas_loading_screen,640);
	hideUIElement(UI.splash_badge);
	//show welcome manual
	if(show_welcome_manual == true){
		showUIElement(UI.manual_menu);
		//
		attentionToElementAdd(UI.tool_config_menu_btn, "element-attention-pulse");
		UI.tool_config_menu_toggler.addEventListener("change", function(e){
			attentionToElementRemove(UI.tool_config_menu_btn, "element-attention-pulse");
			alert("This is a Tool Options menu. An overview of available options per each tool will be shown now.");
			general_menu_map["help"]["tool options"]();
		}, {once : true});
	}
	//
	doc_config_keeper.openMenu();
	
},Math.max(0, 1200-t_elapsed));


})();//launch end
//

// Have a wonderful time painting! :)
// -Dmitriy Burmistrov
</script>


</body>
</html>

